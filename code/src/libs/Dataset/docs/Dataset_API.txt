 
LIBRARY NAME: Dataset
PRODUCTS:     ResourceHandler.h DataUtilities.h HTTPConnection.h Bounds.h Timestamp.h MapProjection.h Albers.h Lambert.h Mercator.h Stereographic.h DataFilterParameters.h CMAQGridParameters.h QueryParameters.h Dataset.h RegriddedDataset.h PointDataset.h RegriddedPointDataset.h SiteDataset.h RegriddedSiteDataset.h CMAQDataset.h SwathDataset.h RegriddedSwathDataset.h AircraftDataset.h RegriddedAircraftDataset.h ProfileDataset.h RegriddedProfileDataset.h CALIPSODataset.h RegriddedCALIPSODataset.h PolygonDataset.h DatasetManager.h libDataset.debug.a libDataset.a
USES LIBS:    -lUtilities.debug -lnetcdf -lshp -lGPC -lPNG -lz -lm -L../../../lib/Darwin 
 
-------------------------------------------------------------------------------

PURPOSE: Dataset.h - Dataset non-instantiable ADT ABC.

TYPES:

namespace emvl {

/*
 * Point must be a compact POD (for C compatibility, e.g., graphics pipeline).
 * longitude is in [-180, 180], latitude is in [-90, 90].
 * latitude is on a WGS84 spheroid.
 * elevation is in meters above mean sea level.
*/

typedef struct { double longitude; double latitude; double elevation; } Point;
bool operator==( const Point& a, const Point& b );
bool operator!=( const Point& a, const Point& b );
bool isPoint( const Point& point ); // Does point have valid geo-coordinates?

class Dataset {

public:

  // Types:
  
  // If dataFileOffset_ != 0, then data_[variable][time][cells] contains only
  // data for BUFFERED_DATA_TIMESTEPS timesteps:

  enum { BUFFERED_DATA_TIMESTEPS = 24 };
  enum { POINT, QUADRILATERAL, POLYGONS, HEXAHEDRON, CELL_TYPES };
  enum { SW, SE, NE, NW }; // QUADRILATERAL cell vertex order.

  /*
   * QUADRILATERAL vertex order =
   *  (west, south), (east, south), (east, north), (west, north)
   * HEXAHEDRON vertex order =
   *  (west, south, lower), (east, south, lower),
   *  (east, north, lower), (west, north, lower)
   *  (west, south, upper), (east, south, upper),
   *  (east, north, upper), (west, north, upper)
   * POLYGONS = one or more triangle strips per data value.
   */

  /*
   * subset() returns a vector (possibly of size 1) of these PODs.
   * Some datasets, such as MOZAIC aircraft flights, have a variable number of
   * flights within a time range so the result of subset() is a vector of
   * SubsetPointers - one per flight. Whereas other datasets such as ground
   * sites have just one set of SubsetPointers.
   * For isStationary(), ! isGroup() datasets such as ground stations,
   * coordinates is the same for all data - coordinates == &coordinates[ 0 ].
   * For other datasets such as aircraft flights, coordinates is an offset into
   * coordinates_.
   * For some datasets such as CMAQ grids, coordinates are computed rather than
   * stored (to greatly reduce memory) so coordinates == 0 and cellVertices()
   * must be called to get a copy of cellVertexCount() vertices for each data
   * value.
   * cellType() is called to determine the type of cell, e.g., HEXAHEDRON.
   */

  typedef struct {
    size_t coordinatesCount;  // Number of coordinates.
    const Point* coordinates; // Offset into coordinates_ or 0 if computed and
                              // cellVertices() must be used instead.
    size_t dataCount;         // Number of values in data[].
    const double* data;       // data[dataCount] offset into data_ for subset.
    size_t notesCount;        // Number of values in notes[] or 0.
    const std::string* notes; // notes[notesCount] MOZAIC flight info or 0.
  } SubsetPointers;

protected:

  std::string fileName_; // File name if data was read from a file, else empty.
  mutable FILE* outputKMLFile_; // Opened file for writing KML content or 0.
  mutable DataColor outputKMLDataColorFunction_; // Data color function for KML.
  std::string name_;
  std::string description_;
  Bounds bounds_;
  Timestamp startingTimestamp_;
  Timestamp endingTimestamp_;
  size_t timesteps_;            // Total number of timesteps of data.
  size_t dataFileOffset_;       // Byte offset in file of first data value.
  mutable size_t firstDataTimestep_; // 0-based 1st  time index of data_ in mem
  mutable size_t lastDataTimestep_;  // 0-based last time index of data_ in mem
  int variables_;
  int dataVariable_;
  int cellType_;
  bool hasElevation_;
  bool hasArea_;
  bool hasVolume_;
  bool isStationary_;
  bool isGroup_;
  bool isStructuredGrid_;
  bool isVector_; // Default is false. Length is variables_.
  bool isDaily_; // Is data daily? Default is false for hourly data.
  std::vector<std::string> variableNames_;
  std::vector<std::string> variableUnits_;
  std::vector<double> minimums_;     // [variable].
  std::vector<double> maximums_;     // [variable].
  mutable std::vector<double> data_; // [variable][time][cell].
  std::vector<Point> coordinates_;   // [cell].

  Dataset();

  // Helper routines:

  static bool pointInCell( const double longitude, const double latitude,
                           const double elevation, const size_t count,
                           const Point vertices[] );

  /*
   * Some dataset's time-stepped data is too large to fit into memory.
   * When this is the case, then:
   *   1. The data must be read from a file (! fileName_.empty()).
   *   2. dataFileOffset_ is used to seek from file.
   *   3. [firstDataTimestep_, lastDataTimestep_] is a sub-range of
   *      [0, timesteps_ - 1].
   *   4. loadedDataSubset() is used to check/load a sub-time-range of data
   *      from fileName_ into data_.
   *      It returns false if the dataset does not contain any data for the
   *      time-range.
   *      It throws stl::runtime_error if it was unable to load the data from
   *      the file.
   *      This is called by probe(), subset(), etc.
   */

  virtual bool loadedDataSubset( const Timestamp firstTimestamp,
                                 const Timestamp lastTimestamp ) const;

  /*
   * The following protected virtual member functions:
   * vprobe(), vtimeseries(), vsubset()
   * are called by their corresponding non-virtual public member functions:
   * probe(), timeseries(), subset().
   * This design allows for default arguments.
   * (Template Method Design Pattern):
   */

  virtual double vprobe( const Timestamp timestamp,
                         const double longitude,
                         const double latitude,
                         const double elevation,
                         const int variable ) const = 0;

  // Default implementation of vtimeseries() calls probe() per hour in range:

  virtual void vtimeseries( const Timestamp beginTimestamp,
                            const Timestamp endTimestamp,
                            const double longitude,
                            const double latitude,
                            const double elevation,
                            std::vector<double>& result ) const;

  virtual std::vector<SubsetPointers> vsubset( const Timestamp beginTimestamp,
                                               const Timestamp endTimestamp,
                                               const int variable ) const = 0;

  void copy( const Dataset& other ); //x Copy above attributes.
  bool equal( const Dataset& other ) const; // Compare with above attributes.
  bool isValidName() const;
  bool isValidDescription() const;
  bool isValidVariableNamesAndUnits() const;
  bool isValidCoordinates() const;
  bool isValidData() const;
  bool isValidRange() const;

  bool isInBounds( const double longitude, const double latitude,
                   const double nearEnough ) const;

  Point cellCenter( const size_t cellIndex ) const;
  static void computeVerticalRectangleCoordinates( const size_t groundPoints,
                                                   const size_t verticalPoints,
                                              const double longitudeCenters[],
                                              const double latitudeCenters[],
                                              const double elevationCenters[],
                                              const double thicknessCenters[],
                                        std::vector<Point>& coordinates ); //x

  bool isInTimeRange( const Timestamp& timestamp ) const;
  bool isInTimeRange( const Timestamp& timestamp, size_t& timestep ) const;
  bool isInTimeRange( const Timestamp& timestamp, Timestamp& firstHour ) const;

  bool overlappedTimeRange( Timestamp& beginTimestamp,
                            Timestamp& endTimestamp ) const;

  bool overlappedTimeRange( const Timestamp& beginTimestamp,
                            const Timestamp& endTimestamp,
                            size_t& firstTimestep,
                            size_t& matchingTimesteps ) const;

  bool overlappedTimeRange( const Timestamp& beginTimestamp,
                            const Timestamp& endTimestamp,
                            size_t& firstTimestep,
                            size_t& matchingTimesteps,
                            size_t& skippedHours ) const;

  bool overlappedTimeRange( Timestamp& beginTimestamp,
                            Timestamp& endTimestamp,
                            Timestamp& firstHour,
                            Timestamp& lastHour ) const;

  bool matchingTimestamps( const Timestamp& timestamp,
                           const std::vector<Timestamp>& timestamps,
                           size_t& first, size_t& last ) const;

  bool matchingTimestamps( const Timestamp& timestamp,
                           const std::vector<Timestamp>& startingTimestamps,
                           const std::vector<Timestamp>& endingTimestamps,
                           size_t& first, size_t& last ) const;

  bool matchingTimestamps( const Timestamp& startTimestamp,
                           const Timestamp& endTimestamp,
                           const std::vector<Timestamp>& timestamps,
                           size_t& first, size_t& last ) const;

  bool matchingTimestamps( const Timestamp& beginTimestamp,
                           const Timestamp& endTimestamp,
                           const std::vector<Timestamp>& startingTimestamps,
                           const std::vector<Timestamp>& endingTimestamps,
                           size_t& first, size_t& last ) const;

  static bool allZeroHour( const std::vector<Timestamp>& timestamps );

  virtual void computeBounds();
  void computeVariableRanges(); //x
  void skipLine( FILE* file ); //x
  void skipBytes( FILE* file, const size_t bytes ); //x
  void readAndMatchLine( FILE* file, const char* match ); //x

  int readAndMatchLine2( FILE* file,
                         const char* const match1,
                         const char* const match2 ); //x

  void readDescription( FILE* file ); //x
  void readTimestamp( FILE* file, const bool two ); //x
  void readDimensions( FILE* file, const size_t count, size_t dimensions[]);//x
  void readVariablesAndUnits( FILE* file, const size_t count ); //x
  void setEndingTimestamp(); // From startingTimestep_, isDaily_ timesteps_.
  void setDatasetNameFromDescriptionAndVariable();
  void readRegridded64BitVariables(FILE* stream,const size_t layersPerPoint);//x
  void readRegridded32BitVariables( FILE* stream ); //x
  void writeRegridded64BitCoordinatesAndVariables( FILE* stream ) const; //x
  void writeRegridded32BitCoordinatesAndVariables( FILE* stream ) const; //x

  void writeIOAPIHeader( const int file,
                         const bool andElevation,
                         const bool forceUppercase,
                         const int skipVariables,
                         const int layers,
                         const int rows,
                         const int columns,
                         const CMAQGridParameters& gridParameters,
                         const size_t subsetIndices[ 4 ][ 2 ],
                         const MapProjection* mapProjection,
                         int dimensionIds[ 6 ] ) const; //x

  void writeIOAPIAttributes( const int file,
                             const bool andElevation,
                             const bool forceUppercase,
                             const int skipVariables,
                             const CMAQGridParameters& gridParameters,
                             const size_t subsetIndices[ 4 ][ 2 ] ) const; //x

  void writeIOAPITFLAGVariable( const int file,
                                const int outputVariables ) const; //x

  void computeCMAQGridLongitudesLatitudes(
                                    const CMAQGridParameters& gridParameters,
                                    const size_t subsetIndices[ 4 ][ 2 ],
                                    const MapProjection* mapProjection,
                                    std::vector<float>& longitudes,
                                    std::vector<float>& latitudes ) const; //x

  void writeCOARDSCommon( const int file,
                          const int skipVariables,
                          const bool isRegridded,
                          const int dimensions,
                          const int dimensionIds[],
                          const int dimensionSizes[],
                          const std::vector<Timestamp>& timestamps ) const; //x

  void createCOARDSVariables( const int file,
                              const bool isRegridded,
                              const int skipVariables,
                              const int dimensions,
                              const int dimensionIds[] ) const; //x

  void writeCOARDSVariables( const int file,
                             const int skipVariables,
                             const int integerVariables,
                             const int dimensions,
                             const int dimensionSizes[] ) const; //x

  void writeBufferedCOARDSVariables( const int file,
                                     const int skipVariables,
                                     const int integerVariables,
                                     const int dimensions,
                                     const int dimensionSizes[] ) const; //x

  void writeCOARDSCoordinates( const int file,
                               const int dimensions,
                               const int dimensionSizes[] ) const; //x

  static void readBounds(FILE* stream, const size_t count, Bounds bounds[]);//x

  static void writeBounds( FILE* stream, const size_t count,
                           const Bounds bounds[] ); //x

  static void readStrings( FILE* stream, const size_t length,
                           std::vector<std::string>& strings ); //x

  static void writeStrings( FILE* stream, const size_t length,
                            const std::vector<std::string>& strings ); //x

  static void readProjectionAndGrid( FILE* stream,
                                     MapProjection*& mapProjection,
                                     CMAQGridParameters& gridParameters ); //x

  static void writeProjectionAndGrid( FILE* stream,
                                      const CMAQGridParameters&
                                        gridParameters ); //x

  static void readProjectionParameters( FILE* stream,
                                        double& sphereRadius,
                                        double& p_alp,
                                        double& p_bet,
                                        double& xcent,
                                        double& ycent,
                                        int& gdtyp ); //x

  static void writeProjectionParameters( FILE* stream,
                                         const CMAQGridParameters&
                                           gridParameters ); //x

  static void writeCOARDSDateTime( const int file,
                                  const std::vector<Timestamp>& timestamps);//x

  static void writeCOARDSNotes( const int file, const size_t length,
                                const std::vector<std::string>& notes ); //x

  virtual void copyOutLongitudes( std::vector<float>& result ) const;

  virtual void copyOutLatitudes( std::vector<float>& result ) const;

  virtual void copyOutElevations( std::vector<float>& result ) const;

  void copyOutVariable( const int variable,
                        const float minimum, const float maximum,
                        std::vector<float>& result ) const;

  template <typename T>
  void readCoordinates( FILE* stream, const bool readElevations,
                        T buffer[] ); //x

  template <typename T>
  void writeCoordinates( FILE* stream, T buffer[] ) const; //x

  template <typename T>
  void readVariable( FILE* stream, const int variable,
                     const T minimum, const T maximum, T buffer[] ); //x

  template <typename T>
  void writeVariable( FILE* stream, const int variable,
                      const T minimum, const T maximum, T buffer[] ) const; //x

  template <typename T>
  static void readIntegers( FILE* stream, const T minimum, const T maximum,
                            std::vector<size_t>& result ); //x

  template <typename T>
  static void writeIntegers( FILE* stream, const T minimum, const T maximum,
                             const std::vector<size_t>& result ); //x

public:

  // Commands:

  virtual ~Dataset();
  void dataVariable( const int variable );
  virtual Dataset* sample( const Dataset& other ) const = 0; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const = 0; //x

  virtual void write( const std::string& directory,
                      const int format ) const = 0; //x

  void write( const std::string& directory,
                      const int format,
                      const int regridMethod,
                      const CMAQGridParameters&
                        cmaqGridParameters ) const; //x calls regrid();write().

  void outputKMLFile( FILE* file ) const { outputKMLFile_ = file; }
  void outputKMLDataColorFunction( DataColor dataColorFunction ) const {
    outputKMLDataColorFunction_ = dataColorFunction;
  }

  // Queries:

  virtual bool invariant() const;
  const std::string& fileName() const; // If read from a file, else empty.
  const std::string& name() const;
  const std::string& description() const;
  const Bounds& bounds() const;
  Timestamp startingTimestamp() const;
  Timestamp endingTimestamp() const;
  virtual size_t timesteps() const;
  int variables() const;
  int dataVariable() const;
  int cellType() const;
  int cellVertexCount() const;
  bool hasElevation() const;
  bool hasArea() const;
  bool hasVolume() const;
  bool isStationary() const;
  bool isGroup() const;
  bool isStructuredGrid() const;
  bool isVector() const;
  bool isDaily() const;
  virtual bool isSurfaceData() const;
  virtual size_t layers() const;
  virtual size_t rows() const;
  virtual size_t columns() const;
  const std::string& variableName( const int variable = IMISSING ) const;
  const std::string& variableUnits( const int variable = IMISSING ) const;
  std::string pathedFileName( const std::string& directory,
                              const int format ) const;
  FILE* outputKMLFile() const { return outputKMLFile_; }
  DataColor outputKMLDataColorFunction() const { return outputKMLDataColorFunction_; }
  double minimum( const int variable = IMISSING ) const;
  double maximum( const int variable = IMISSING ) const;
  virtual void cellVertices( const size_t cell, Point points[] ) const;

  // Return a single data value nearest a probed location:

  double probe( const Timestamp timestamp,
                const double longitude,
                const double latitude,
                const double elevation = MISSING,
                const int variable = IMISSING ) const; // Calls vprobe().

  void timeseries( const Timestamp beginTimestamp,
                   const Timestamp endTimestamp,
                   const double longitude,
                   const double latitude,
                   const double elevation,
                   std::vector<double>& result ) const;

  std::vector<SubsetPointers>
  subset( const Timestamp beginTimestamp,
          const Timestamp endTimestamp,
          const int variable = IMISSING ) const; // Calls vsubset().
};



/******************************************************************************
PURPOSE: readCoordinates - Read XDR binary coordinates from a stream.
INPUTS:  FILE* stream  Stream to read from.
         const bool readElevations  Read elevations after longitudes,latitudes?
         coordinates_.size()  Is number of points to read.
OUTPUTS: coordinates_[ * ]    Read/converted/checked coordinates.
         T buffer[]           Buffer of size coordinates_.size() to read into.
NOTES:   Throws exception upon failure to read valid data from a stream.
******************************************************************************/

template <typename T>
void Dataset::readCoordinates( FILE* stream, const bool readElevations,
                               T buffer[] ) {
  PRE03( stream, coordinates_.size(), buffer );
  const size_t points = coordinates_.size();
  const size_t coordinates = 2 + readElevations;
  const double ranges[ 3 ][ 2 ] = {
    { -180.0, 180.0 },
    { -90.0, 90.0 },
    { QueryParameters::MINIMUM_ELEVATION, QueryParameters::MAXIMUM_ELEVATION }
  };
  bool ok = true;

  for ( size_t coordinate = 0; AND2( ok, coordinate < coordinates );
        ++coordinate ) {
    ok = fread( buffer, sizeof buffer[ 0 ], points, stream ) == points;

    if ( ok ) {

      if ( sizeof buffer[ 0 ] == 4 ) {
        reverse4ByteWordsIfLittleEndian( buffer, points );
      } else if ( sizeof buffer[ 0 ] == 8 ) {
        reverse8ByteWordsIfLittleEndian( buffer, points );
      }

      for ( size_t point = 0; AND2( ok, point < points ) ; ++point ) {
        const double value = buffer[ point ];
        ok = IN_RANGE( value,
                       ranges[ coordinate ][ MINIMUM ],
                       ranges[ coordinate ][ MAXIMUM ] );

        if ( ok ) {
          Point& p = coordinates_[ point ];

          switch ( coordinate ) {
          case LONGITUDE:
            p.longitude = value;
            break;
          case LATITUDE:
            p.latitude = value;
            break;
          default:
            p.elevation = value;
            break;
          }

          coordinates_[ point ] = p;
        }
      }
    }
  }

  if ( ! ok ) {
    throw std::runtime_error( "Failed to read valid coordinates." ); //x
  } else {
    computeBounds();
  }

  POST0( isValidCoordinates() );
}



/******************************************************************************
PURPOSE: writeCoordinates - Write XDR binary coordinates to a stream.
INPUTS:  FILE* stream   Stream to read from.
OUTPUTS: T buffer[ coordinates_.size() / cellVertexCount() ] Buffer to copy to.
NOTES:   Throws exception upon failure to read valid data from a stream.
******************************************************************************/

template <typename T>
void Dataset::writeCoordinates( FILE* stream, T buffer[] ) const {
  PRE2( stream, buffer );
  const size_t verticesPerCell = cellVertexCount();
  const size_t cells = coordinates_.size() / verticesPerCell;
  const size_t coordinates = hasElevation() ? 3 : 2;
  bool ok = true;

  for ( size_t coordinate = 0;
        AND2( ok, coordinate < coordinates );
        ++coordinate ) {

    for ( size_t cell = 0; cell < cells; ++cell ) {
      const size_t cellOffset = cell * verticesPerCell;
      buffer[ cell ] = 0.0;

      for ( size_t vertex = 0; vertex < verticesPerCell; ++vertex ) {
        const size_t index = cellOffset + vertex;
        CHECK( IN_RANGE( index, 0, coordinates_.size() - 1 ) );
        const Point& coordinatePoint = coordinates_[ index ];
        const double value =
          coordinate == LONGITUDE ? coordinatePoint.longitude
          : coordinate == LATITUDE  ? coordinatePoint.latitude
          : coordinatePoint.elevation;
        buffer[ cell ] += value; // Sum values.
      }

      buffer[ cell ] /= verticesPerCell; // Mean is centroid.
    }

    if ( sizeof buffer[ 0 ] == 4 ) {
      reverse4ByteWordsIfLittleEndian( buffer, cells );
    } else if ( sizeof buffer[ 0 ] == 8 ) {
      reverse8ByteWordsIfLittleEndian( buffer, cells );
    }

    ok = fwrite( buffer, sizeof buffer[ 0 ], cells, stream ) == cells;
  }

  if ( ! ok ) {
    throw std::runtime_error( "Failed to write XDR binary coordinates." ); //x
  }

  POST( true );
}



/******************************************************************************
PURPOSE: readVariable - Read XDR binary variable from stream.
INPUTS:  FILE* stream        Stream to write to.
         const int variable  Index of variable to read.
         const T minimum     Minimum value to check input data.
         const T maximum     Maximum value to check input data.
OUTPUTS: FILE* stream        Updated stream.
         T buffer[]          Buffer to use for endian conversion.
NOTES:   Throws exception upon failure.
******************************************************************************/

template <typename T>
void Dataset::readVariable( FILE* stream, const int variable,
                            const T minimum, const T maximum,
                            T buffer[] ) {
  PRE07( stream, IN_RANGE( variable, 0, variables_ - 1 ),
        isFinite( minimum ), isFinite( maximum ), minimum <= maximum,
        buffer, data_.size() );
  const size_t points = data_.size() / variables_;
  const size_t dataOffset = variable * points;
  const double minimum2 = minimum;
  const double maximum2 = maximum;
  const bool ok = readConvertedArray( stream, buffer, points,
                                      minimum2, maximum2,
                                      &data_[ dataOffset ] );

  if ( ! ok ) {
    throw std::runtime_error( "Failed to read XDR binary variable." );//x
  }

  POST0( true );
}



/******************************************************************************
PURPOSE: writeVariable - Write XDR binary variable to stream.
INPUTS:  FILE* stream        Stream to write to.
         const int variable  Index of variable to write.
         const T minimum     Minimum value to clamp output data.
         const T maximum     Maximum value to clamp output data.
OUTPUTS: FILE* stream        Updated stream.
         T buffer[]          Buffer to use for endian conversion.
NOTES:   Throws exception upon failure.
******************************************************************************/

template <typename T>
void Dataset::writeVariable( FILE* stream, const int variable,
                             const T minimum, const T maximum,
                             T buffer[] ) const {
  PRE6( stream, IN_RANGE( variable, 0, variables_ - 1 ),
        isFinite( minimum ), isFinite( maximum ), minimum <= maximum,
        buffer );
  const size_t points = data_.size() / variables_;
  const size_t dataOffset = variable * points;
  const bool ok = writeConvertedArray( stream, buffer, points,
                                       minimum, maximum,
                                       &data_[ dataOffset ] );

  if ( ! ok ) {
    throw std::runtime_error( "Failed to write XDR binary variable." ); //x
  }

  POST( true );
}



/******************************************************************************
PURPOSE: readIntegers - Read and convert XDR-format array of integers from
         stream.
INPUTS:  FILE* stream                 Stream to read from.
         const T minimum              Minimum valid value to read.
         const T maximum              Maximum valid value to read.
OUTPUTS: std::vector<size_t>& result  Read/converted/checked values.
NOTES:   Throws exception upon failure to read valid data from a stream.
******************************************************************************/

template <typename T>
void Dataset::readIntegers( FILE* stream, const T minimum, const T maximum,
                            std::vector<size_t>& result ) {
  PRE04( stream, minimum >= 0, minimum <= maximum, result.size() >= 1 );
  const size_t count = result.size();
  std::vector<T> buffer( count ); //x
  const size_t minimum2 = minimum;
  const size_t maximum2 = maximum;
  const bool ok =
    readConvertedArray( stream, &buffer[ 0 ], count, minimum2, maximum2,
                        &result[ 0 ] );

  if ( ! ok ) {
    throw std::runtime_error( "Failed to read valid array of integers." ); //x
  }

  POST02( emvl::minimum( &result[ 0 ], result.size() ) >= (size_t) minimum,
          emvl::maximum( &result[ 0 ], result.size() ) <= (size_t) maximum );
}



/******************************************************************************
PURPOSE: writeIntegers - Write clamped/converted XDR-format array of integers
         to stream.
INPUTS:  FILE* stream                 Stream to write to.
         const T minimum              Minimum value to clamp to.
         const T maximum              Maximum value to clamp to.
         const std::vector<size_t>& result  Copied/converted/clamped values.
NOTES:   Throws exception upon failure to write data to a stream.
******************************************************************************/

template <typename T>
void Dataset::writeIntegers( FILE* stream, const T minimum, const T maximum,
                             const std::vector<size_t>& result ) {
  PRE04( stream, minimum >= 0, minimum <= maximum, result.size() >= 1 );
  const size_t count = result.size();
  std::vector<T> buffer( count ); //x
  const bool ok =
    writeConvertedArray( stream, &buffer[ 0 ], count, minimum, maximum,
                         &result[ 0 ] );

  if ( ! ok ) {
    throw std::runtime_error( "Failed to write array of integers." ); //x
  }
}


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: Dataset - Construct a Dataset.
INTERFACE:
Dataset::Dataset()

-------------------------------------------------------------------------------

PURPOSE: ~Dataset - Destruct a Dataset.
INTERFACE:
Dataset::~Dataset()

-------------------------------------------------------------------------------

PURPOSE: dataVariable - Select variable to be used as data.
RETURNS: const int variable  0-based index of variable to be used as data.
INTERFACE:
void Dataset::dataVariable( const int variable )
PRE( IN_RANGE( variable, 0, variables() - 1 ) )
POST( this->dataVariable() == variable )

-------------------------------------------------------------------------------

PURPOSE: write - Write regridded dataset to a directory file in the specified
         format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
         const int regridMethod        REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters&     Regridding parameters.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Calls virtual members regrid() and write(). Template Method Pattern.
         Throws exception upon failure.
INTERFACE:
void Dataset::write( const std::string& directory,
                     const CMAQGridParameters& cmaqGridParameters) const
PRE4( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ),
      IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      cmaqGridParameters.invariant() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool Dataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: fileName - Name of file this dataset was read from or else empty if
         it was not read from a file (e.g., from a socket instead).
RETURNS: const std::string&  Name of file this dataset was read from or empty.
INTERFACE:
const std::string& Dataset::fileName() const
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: name - Name of this dataset.
RETURNS: const std::string&  Name of this dataset.
INTERFACE:
const std::string& Dataset::name() const
PRE( true )
POST( result.length() > 0 )

-------------------------------------------------------------------------------

PURPOSE: description - Description (e.g., metadata link) of this dataset.
RETURNS: const std::string&  Description of this dataset.
INTERFACE:
const std::string& Dataset::description() const
PRE( true )
POST( result.length() > 0 )

-------------------------------------------------------------------------------

PURPOSE: bounds - Longitude-latitude extent of this dataset.
RETURNS: const Bounds&  Bounds of this dataset.
INTERFACE:
const Bounds& Dataset::bounds() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: startingTimestamp - Starting timestamp from retrieval query.
RETURNS: Timestamp  Starting timestamp of this dataset.
INTERFACE:
Timestamp Dataset::startingTimestamp() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: endingTimestamp - Ending timestamp from retrieval query.
RETURNS: Timestamp  Ending timestamp of this dataset.
INTERFACE:
Timestamp Dataset::endingTimestamp() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: variables - Number of data variables (excluding coordinates).
RETURNS: int Number of variables.
INTERFACE:
int Dataset::variables() const
PRE( true )
POST( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: dataVariable - Index of variable to be used as data.
RETURNS: int Index of data variable.
INTERFACE:
int Dataset::dataVariable() const
PRE( true )
POST( IN_RANGE( result, 0, variables() - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: timesteps - Number of timesteps of data.
RETURNS: size_t number of timesteps of data.
INTERFACE:
size_t Dataset::timesteps() const

-------------------------------------------------------------------------------

PURPOSE: cellType - Type of coordinate cell.
RETURNS: int type of coordinate cell.
INTERFACE:
int Dataset::cellType() const

-------------------------------------------------------------------------------

PURPOSE: cellVertexCount - Number of vertices per coordinate cell.
RETURNS: int number of vertices per coordinate cell.
INTERFACE:
int Dataset::cellVertexCount() const

-------------------------------------------------------------------------------

PURPOSE: hasElevation - Does this dataset have elevation coordinates?
RETURNS: bool true if this dataset has elevation coordinates, else false.
INTERFACE:
bool Dataset::hasElevation() const

-------------------------------------------------------------------------------

PURPOSE: hasArea - Does this dataset have area cells?
RETURNS: bool true if this dataset has area cells, else false.
INTERFACE:
bool Dataset::hasArea() const

-------------------------------------------------------------------------------

PURPOSE: hasVolume - Does this dataset have volume cells?
RETURNS: bool true if this dataset has volume cells, else false.
INTERFACE:
bool Dataset::hasVolume() const

-------------------------------------------------------------------------------

PURPOSE: isStationary - Does this dataset have non-time-varying coordinates?
RETURNS: bool true if this dataset has fixed coordinates, else false.
INTERFACE:
bool Dataset::isStationary() const

-------------------------------------------------------------------------------

PURPOSE: isGroup - Does this dataset have disjoint sets of coordinates?
RETURNS: bool true if this dataset has groups of coordinates, else false.
INTERFACE:
bool Dataset::isGroup() const

-------------------------------------------------------------------------------

PURPOSE: isStructuredGrid - Does this dataset have a structued grid with one or
         more layers, rows and columns?
RETURNS: bool true if this dataset has a structued grid, else false.
INTERFACE:
bool Dataset::isStructuredGrid() const

-------------------------------------------------------------------------------

PURPOSE: isVector - Is this dataset variable a vector?
RETURNS: bool true if this dataset variable is a vector, else false.
INTERFACE:
bool Dataset::isVector() const

-------------------------------------------------------------------------------

PURPOSE: isDaily - Does this dataset have daily data timesteps?
RETURNS: bool true if this dataset has daily data timesteps, else false.
INTERFACE:
bool Dataset::isDaily() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool true if this dataset has data only on the Earth surface,
         else false if the data is in the atmosphere.
NOTES:   Default implementation of this virtual function returns layers() == 0.
INTERFACE:
bool Dataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: layers - Number of layers in this structured grid.
RETURNS: size_t Number of layers in this structured grid.
NOTES:   Default implementation of this virtual function returns 0.
INTERFACE:
size_t Dataset::layers() const

-------------------------------------------------------------------------------

PURPOSE: rows - Number of rows in this structured grid.
RETURNS: size_t Number of rows in this structured grid.
NOTES:   Default implementation of this virtual function returns 0.
INTERFACE:
size_t Dataset::rows() const

-------------------------------------------------------------------------------

PURPOSE: columns - Number of columns in this structured grid.
RETURNS: size_t Number of columns in this structured grid.
NOTES:   Default implementation of this virtual function returns 0.
INTERFACE:
size_t Dataset::columns() const

-------------------------------------------------------------------------------

PURPOSE: variableName - Name of indexed variable.
INPUTS:  int variable  Index of variable to name.
RETURNS: const std::string& Name of variable.
INTERFACE:
const std::string& Dataset::variableName( const int variable ) const
PRE( OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 ) ) )
POST( result.length() > 0 )

-------------------------------------------------------------------------------

PURPOSE: variableUnits - Units of indexed variable.
INPUTS:  int variable  Index of variable.
RETURNS: const std::string& Units of variable.
INTERFACE:
const std::string& Dataset::variableUnits( const int variable ) const
PRE( OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 ) ) )
POST( result.length() > 0 )

-------------------------------------------------------------------------------

PURPOSE: pathedFileName - Construct a pathed file name for this Dataset.
INPUTS:  const std::string& directory  Directory to write this Dataset.
         const int format              File format to write this Dataset.
RETURNS: const std::string  Pathed file name of this Dataset.
INTERFACE:
std::string Dataset::pathedFileName( const std::string& directory,
                                     const int format ) const
PRE02( directory.length(),
       IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST0( result.length() > directory.length() + name_.length() )

-------------------------------------------------------------------------------

PURPOSE: minimum - Minimum value of variable.
INPUTS:  int variable  Index of variable or IMISSING.
RETURNS: double minimum value of variable.
INTERFACE:
double Dataset::minimum( const int variable ) const
PRE( OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 ) ) )
POST( ! isNan( result ) )

-------------------------------------------------------------------------------

PURPOSE: maximum - Maximum value of variable.
INPUTS:  int variable  Index of variable or IMISSING.
RETURNS: double maximum value of variable.
INTERFACE:
double Dataset::maximum( const int variable ) const
PRE( OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 ) ) )
POST( ! isNan( result ) )

-------------------------------------------------------------------------------

PURPOSE: pointInCell - Is point within a cell with given vertices?
INPUTS:  const double longitude   Longitude of point to check.
         const double latitude    Latitude  of point to check.
         const double elevation   Elevation of point to check or MISSING.
         const size_t count       Number of cell vertices.
         const Point  vertices[]  Array of cell vertices in order
                                  described in Dataset.h.
RETURNS: true if inside else false.
INTERFACE:
bool Dataset::pointInCell( const double longitude, const double latitude,
                           const size_t count, const Point vertices[] )
PRE05( isLongitudeLatitude( longitude, latitude ),
       IN4( count, 3, 4, 8 ),
       vertices,
       isPoint( vertices[ 0 ] ),
       isPoint( vertices[ count - 1 ] ) )

-------------------------------------------------------------------------------

PURPOSE: probe - Return nearest data point to time-space location.
INPUTS:  const Timestamp& timestamp  Timestamp of probe.
         const double longitude      Longitude of probe.
         const double latitude       Latitude of probe.
         const double elevation      Elevation of probe.
         const int variable          Index of variable.
RETURNS: double Data value nearest probe or MISSING if not near any data.
NOTES:   Calls pure virtual member function vprobe() which must be implemented
         by concrete derived classes. Template Method Design Pattern.
INTERFACE:
double Dataset::probe( const Timestamp timestamp,
                       const int variable ) const
PRE4( timestamp.invariant(),
      isLongitudeLatitude( longitude, latitude ),
      OR2( elevation == MISSING, isElevation( elevation ) ),
      OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 )))
POST( OR2( result == MISSING,
           IN_RANGE( result, minimum( variable ), maximum( variable ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: timeseries - Probe dataset over time range at a specified location.
INPUTS:  const Timestamp& beginTimestamp  Beginning timestamp of sample.
         const Timestamp& endTimestamp    Ending timestamp of sample.
         const double longitude           Longitude of probe.
         const double latitude            Latitude of probe.
         const double elevation           Elevation of probe or MISSING.
OUTPUTS: std::vector<double>& result      Hourly values (or MISSING) over time
                                          range at location.
NOTES:   Calls non-pure virtual member function vtimeseries() which may be
         implemented by concrete derived classes. Template Method Pattern.
INTERFACE:
void Dataset::timeseries( const Timestamp beginTimestamp,
                          const
PRE5( beginTimestamp.invariant(),
      endTimestamp.invariant(),
      beginTimestamp <= endTimestamp,
      isLongitudeLatitude( longitude, latitude ),
      OR2( elevation == MISSING, isElevation( elevation ) ) )
POST3( result.size() >=
         1 + beginTimestamp.hoursUntil( endTimestamp ),
       OR2( ::emvl::minimum( &result[ 0 ], result.size() ) == MISSING,
            IMPLIES( ! isVector(),
                     IN_RANGE( ::emvl::minimum( &result[ 0 ], result.size() ),
                               minimum(), maximum() ) ) ),
       OR2( ::emvl::maximum( &result[ 0 ], result.size() ) == MISSING,
            IMPLIES( ! isVector(),
                     IN_RANGE( ::emvl::maximum( &result[ 0 ], result.size() ),
                               ::emvl::minimum( &result[ 0 ], result.size() ),
                               maximum() ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: subset - Extract a reference to the subset of data for the given
         time-range for data with time-varying coordinates.
INPUTS:  const Timestamp& beginTimestamp  Beginning timestamp of subset.
         const Timestamp& endTimestamp    End timestamp of subset.
         const int variable               Index of data variable.
RETURNS: std::vector<Dataset::SubsetPointers>
                                       Pointers to subset coordinates and data.
NOTES:   Calls virtual member function vsubset() which has a default
         implementation that returns an empty vector
         but may be overridden by concrete derived classes.
         Template Method Design Pattern.
INTERFACE:
Dataset::subset( const Timestamp beginTimestamp,
                 const int variable ) const
PRE4( beginTimestamp.invariant(),
      endTimestamp.invariant(),
      beginTimestamp <= endTimestamp,
      OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 )))
POST( IMPLIES( result.size(),
               AND16( result[ 0 ].dataCount,
                      result[ 0 ].coordinatesCount,
                      IMPLIES( cellType_ != POLYGONS,
                               result[0].coordinatesCount / cellVertexCount()
                        <= result[ 0 ].dataCount ),
                      result[ 0 ].data,
                      IMPLIES( result[ 0 ].coordinates,
                               AND2( isPoint( result[ 0 ].coordinates[ 0 ] ),
                                     isPoint( result[ 0 ].coordinates[
                                       result[ 0 ].coordinatesCount - 1 ]))),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::minimum( result[ 0 ].data,
                                                    result[ 0 ].dataCount )
                                     > MISSING ),
                               IN_RANGE( emvl::minimum( result[0].data,
                                                        result[0].dataCount),
                                         minimum( variable ),
                                         maximum( variable ) ) ),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::maximum( result[ 0 ].data,
                                                    result[ 0 ].dataCount )
                                     > MISSING ),
                               IN_RANGE( emvl::maximum( result[0].data,
                                                        result[0].dataCount),
                                         minimum( variable ),
                                         maximum( variable ) ) ),
                      IMPLIES( result[ 0 ].notesCount, result[ 0 ].notes ),
                      result[ result.size() - 1 ].dataCount,
                      result[ result.size() - 1 ].coordinatesCount,
                      IMPLIES( cellType_ != POLYGONS,
                               result[ result.size() - 1 ].coordinatesCount
                                 / cellVertexCount()
                                 <= result[ result.size() - 1 ].dataCount ),
                      result[ result.size() - 1 ].data,
                      IMPLIES( result[ result.size() - 1 ].coordinates,
                               AND2( isPoint( result[ result.size() - 1 ]
                                              .coordinates[ 0 ] ),
                                     isPoint( result[ result.size() - 1 ]
                                              .coordinates[
                        result[ result.size() - 1 ].coordinatesCount - 1]))),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::minimum(
                                       result[result.size() - 1].data,
                                       result[result.size() - 1].dataCount )
                                     > MISSING ),
                               IN_RANGE( emvl::minimum(
                                        result[result.size() - 1].data,
                                        result[result.size() - 1].dataCount),
                                         minimum( variable ),
                                         maximum( variable ) ) ),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::maximum(
                                      result[ result.size() - 1 ].data,
                                      result[ result.size() - 1 ].dataCount )
                                     > MISSING ),
                               IN_RANGE( emvl::maximum(
                                        result[result.size() - 1].data,
                                        result[result.size() - 1].dataCount),
                                         minimum( variable ),
                                         maximum( variable ) ) ),
                      IMPLIES( result[ result.size() - 1 ].notesCount,
                               result[ result.size() - 1 ].notes ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: cellVertices - Get a copy of a cell's vertices. This is needed when
         subset() results have coordinates == 0 indicating that coordinats are
         not stored, but rather computed by this routine.
INPUTS:  const size_t cell  Index of cell.
OUTPUTS: Point points[ cellVertexCount() ]  Cell's vertices.
NOTES:   If subset() returns SubsetPointers with coordinates != 0 then the
         cell vertices can be accessed directly without copying.
INTERFACE:
void Dataset::cellVertices( const size_t cell, Point points[] ) const
PRE3( coordinates_.size(),
      points,
      IN_RANGE( cell, 0, coordinates_.size() / cellVertexCount() - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: copy - Copy other's attributes.
INPUTS:  const Dataset& other  Other object to copy.
INTERFACE:
void Dataset::copy( const Dataset& other )
PRE0( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: equal - Compare to other's attributes.
INPUTS:  const Dataset& other  Other object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Dataset::equal( const Dataset& other ) const
PRE( other.invariant() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: loadedDataSubset - Determine if data is available for the given time
         range and, if available and not already in data_ then read it from
         fileName_ into data_.
INPUTS:  const Timestamp firstTimestamp  Timestamp of start of data needed.
         const Timestamp lastTimestamp   Timestamp of end   of data needed.
OUTPUTS: firstDataTimestep_, lastDataTimestep_, data_.
RETURNS: bool true if data is available, else false if no data is available.
NOTES:   This is called by Dataset::probe() and Dataset::subset().
         Default implementation does nothing but return true.
INTERFACE:
bool Dataset::loadedDataSubset( const Timestamp firstTimestamp,
                                const Timestamp lastTimestamp ) const
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: isValidName - Does name_ start with a letter and contain only
         [a-z,A-Z,0-9,_,.]?
INTERFACE:
bool Dataset::isValidName() const

-------------------------------------------------------------------------------

PURPOSE: isValidDescription - Does description_ start with a letter or digit
         and contain only printable characters?
INTERFACE:
bool Dataset::isValidDescription() const

-------------------------------------------------------------------------------

PURPOSE: isValidVariableNamesAndUnits - Do variableNames_ consist only of
         letters, numbers and _,
         and do the matching variableUnits_ consist only of
         [A-Z,a-z,0-9,-,_,%,/,*,^]
         and are the counts matching variables_?
INTERFACE:
bool Dataset::isValidVariableNamesAndUnits() const

-------------------------------------------------------------------------------

PURPOSE: isValidCoordinates - Are coordinates valid?
INTERFACE:
bool Dataset::isValidCoordinates() const

-------------------------------------------------------------------------------

PURPOSE: isValidData - Are data valid?
INTERFACE:
bool Dataset::isValidData() const

-------------------------------------------------------------------------------

PURPOSE: isValidRange - Are minimums and maximums valid?
INTERFACE:
bool Dataset::isValidRange() const

-------------------------------------------------------------------------------

PURPOSE: isInBounds - Is probe point within bounds (approximately)?
INPUTS:  const double longitude   Longitude of point to check.
         const double latitude    Latitude of point to check.
         const double nearEnough  Distance considered within bounds.
RETURNS: bool true if within bounds, else false.
INTERFACE:
bool Dataset::isInBounds( const double longitude, const double latitude,
                          const double nearEnough ) const
PRE2( isLongitudeLatitude( longitude, latitude ),
      IN_RANGE( nearEnough, 0.0, 1.0 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: isInTimeRange - Is timestamp within time range of dataset
         (expanded to full hour)?
INPUTS:  const Timestamp& timestamp  Timestamp to check.
RETURNS: bool true if within time range (within hour), else false.
INTERFACE:
bool Dataset::isInTimeRange( const Timestamp& timestamp ) const
PRE( timestamp.invariant() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: isInTimeRange - Is timestamp within time range of dataset
         (expanded to full hour)? If so, set timestep index.
INPUTS:  const Timestamp& timestamp  Timestamp to check.
OUTPUTS: size_t& timestep            Index of timestep matching timestamp.
RETURNS: bool true if within time range (within hour), else false.
NOTES:   Used for temporally non-sparse hourly or daily data.
INTERFACE:
bool Dataset::isInTimeRange( const Timestamp& timestamp,
                             size_t& timestep ) const
PRE( timestamp.invariant() )
POST( IMPLIES_ELSE( result,
                    IN_RANGE( timestep, 0, timesteps_ - 1 ),
                    timestep == 0 ) )

-------------------------------------------------------------------------------

PURPOSE: isInTimeRange - Is timestamp within time range of dataset
         (expanded to full hour)?
INPUTS:  const Timestamp& timestamp  Timestamp to check.
OUTPUTS: Timestamp& firstHour        Hour of first data.
RETURNS: bool true if within time range (within hour), else false.
INTERFACE:
bool Dataset::isInTimeRange( const Timestamp& timestamp,
                             Timestamp& firstHour ) const
PRE2( timestamp.invariant(), firstHour.invariant() )
POST( firstHour.invariant() )

-------------------------------------------------------------------------------

PURPOSE: overlappedTimeRange - Does time range overlap this data time range?
INPUTS:  Timestamp& beginTimestamp  Beginning timestamp to check.
         Timestamp& endTimestamp    Ending timestamp to check.
OUTPUTS: Timestamp& beginTimestamp  Adjusted to start of hour (and day if daily)
         Timestamp& endTimestamp    Adjusted to end   of hour (and day if daily)
RETURNS: bool true if within time range (within hour), else false.
INTERFACE:
bool Dataset::overlappedTimeRange( Timestamp& beginTimestamp,
                                   Timestamp& endTimestamp ) const
PRE3( beginTimestamp.invariant(), endTimestamp.invariant(),
      beginTimestamp <= endTimestamp )
POST2( beginTimestamp.invariant(), endTimestamp.invariant() )

-------------------------------------------------------------------------------

PURPOSE: overlappedTimeRange - Does time range overlap this data time range?
         If so output the first and last timestep indices within range.
INPUTS:  const Timestamp beginTimestamp  Beginning timestamp to check.
         const Timestamp endTimestamp    Ending timestamp to check.
OUTPUTS: size_t& firstTimestep           First timestep index within range.
         size_t& matchingTimesteps       Number of timesteps within range.
RETURNS: bool true if within time range (within hour), else false.
NOTES:   Used for temporally non-sparse hourly or daily data.
INTERFACE:
bool Dataset::overlappedTimeRange( const Timestamp& beginTimestamp,
                                   size_t& matchingTimesteps ) const
PRE3( beginTimestamp.invariant(), endTimestamp.invariant(),
      beginTimestamp <= endTimestamp )
POST3( beginTimestamp.invariant(), endTimestamp.invariant(),
       IMPLIES_ELSE( result,
                     AND2( IN_RANGE( firstTimestep, 0, timesteps_ - 1 ),
                           IN_RANGE( firstTimestep + matchingTimesteps,
                                     1, timesteps_ ) ),
                     IS_ZERO2( firstTimestep, matchingTimesteps ) ) )

-------------------------------------------------------------------------------

PURPOSE: overlappedTimeRange - Does time range overlap this data time range?
         If so output the first and last timestep indices within range.
INPUTS:  const Timestamp beginTimestamp  Beginning timestamp to check.
         const Timestamp endTimestamp    Ending timestamp to check.
OUTPUTS: size_t& firstTimestep           First timestep index within range.
         size_t& matchingTimesteps       Number of timesteps within range.
         size_t& skippedHours            Number of hours in range skipped
                                         before firstTimestep.
RETURNS: bool true if within time range (within hour), else false.
NOTES:   Used for temporally non-sparse hourly or daily data.
INTERFACE:
bool Dataset::overlappedTimeRange( const Timestamp& beginTimestamp,
                                   size_t& skippedHours ) const
PRE3( beginTimestamp.invariant(), endTimestamp.invariant(),
      beginTimestamp <= endTimestamp )
POST3( beginTimestamp.invariant(), endTimestamp.invariant(),
       IMPLIES_ELSE( result,
                     AND2( IN_RANGE( firstTimestep, 0, timesteps_ - 1 ),
                           IN_RANGE( firstTimestep + matchingTimesteps,
                                     1, timesteps_ ) ),
                     IS_ZERO2( firstTimestep, matchingTimesteps ) ) )

-------------------------------------------------------------------------------

PURPOSE: overlappedTimeRange - Does time range overlap this data time range?
INPUTS:  Timestamp& beginTimestamp  Beginning timestamp to check.
         Timestamp& endTimestamp    Ending timestamp to check.
OUTPUTS: Timestamp& beginTimestamp  Adjusted to start of hour (and day if daily)
         Timestamp& endTimestamp    Adjusted to end   of hour (and day if daily)
         Timestamp& firstHour       startingTimestamp adjusted to start of hour
                                    (and day if daily variable).
         Timestamp& lastHour        endingTimestamp adjusted to end of hour
                                    (and day if daily variable).
RETURNS: bool true if within time range (within hour), else false.
INTERFACE:
bool Dataset::overlappedTimeRange( Timestamp& beginTimestamp,
                                   Timestamp& lastHour ) const
PRE6( beginTimestamp.invariant(), endTimestamp.invariant(),
      beginTimestamp <= endTimestamp,
      firstHour.invariant(), lastHour.invariant(), firstHour <= lastHour )
POST4( beginTimestamp.invariant(), endTimestamp.invariant(),
       firstHour.invariant(), lastHour.invariant() )

-------------------------------------------------------------------------------

PURPOSE: matchingTimestamps - Find index of first and last timestamp matching
         a given timestamp - i.e., same day for daily data else same hour.
INPUTS:  const Timestamp& timestamp                Timestamp to find.
         const std::vector<Timestamp>& timestamps  Sorted Timestamps to search.
OUTPUTS: size_t& first                       Index of first matching timestamp.
         size_t& last                        Index of last  matching timestamp.
RETURNS: bool true if found matches else false if no matches found.
INTERFACE:
bool Dataset::matchingTimestamps( const Timestamp& timestamp,
                                  size_t& first, size_t& last ) const
PRE04( timestamp.invariant(),
       timestamps.size(),
       timestamps[ 0 ].invariant(),
       timestamps[ timestamps.size() - 1 ].invariant() )
POST0( IMPLIES( result,
                AND2( IN_RANGE( first, 0, timestamps.size() - 1 ),
                      IN_RANGE( last,  first, timestamps.size() - 1 ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: matchingTimestamps - Find index of first and last timestamp matching
         a given timestamp - i.e., same day for daily data else same hour.
INPUTS:  const Timestamp& timestamp                Timestamp to find.
         const std::vector<Timestamp>& startingTimestamps  Sorted starting
                                                           Timestamps to search.
         const std::vector<Timestamp>& endingTimestamps    Sorted ending
                                                           Timestamps to search.
OUTPUTS: size_t& first                       Index of first matching timestamp.
         size_t& last                        Index of last  matching timestamp.
RETURNS: bool true if found matches else false if no matches found.
INTERFACE:
bool Dataset::matchingTimestamps( const Timestamp& timestamp,
                                  size_t& first, size_t& last ) const
PRE07( timestamp.invariant(),
       startingTimestamps.size(),
       startingTimestamps[ 0 ].invariant(),
       startingTimestamps[ startingTimestamps.size() - 1 ].invariant(),
       endingTimestamps.size() == startingTimestamps.size(),
       endingTimestamps[ 0 ].invariant(),
       endingTimestamps[ endingTimestamps.size() - 1 ].invariant() )
POST0( IMPLIES( result,
                AND2( IN_RANGE( first, 0, startingTimestamps.size() - 1 ),
                      IN_RANGE( last,  first, startingTimestamps.size()-1))))

-------------------------------------------------------------------------------

PURPOSE: matchingTimestamps - Find index of first and last timestamp matching
         a given timestamp range - i.e., same day for daily data
         else same hour.
INPUTS:  const Timestamp& beginTimestamp          Beginning timestamp to find
         const Timestamp& endTimestamp            Ending    timestamp to find
         const std::vector<Timestamp>& timestamps Sorted Timestamps to search.
OUTPUTS: size_t& first                      Index of first matching timestamp.
         size_t& last                       Index of last  matching timestamp.
RETURNS: bool true if found matches else false if no matches found.
INTERFACE:
bool Dataset::matchingTimestamps( const Timestamp& beginTimestamp,
                                  size_t& first, size_t& last ) const
PRE06( beginTimestamp.invariant(),
       endTimestamp.invariant(),
       beginTimestamp <= endTimestamp,
       timestamps.size(),
       timestamps[ 0 ].invariant(),
       timestamps[ timestamps.size() - 1 ].invariant() )
POST0( IMPLIES( result,
                AND2( IN_RANGE( first, 0, timestamps.size() - 1 ),
                      IN_RANGE( last,  first, timestamps.size() - 1 ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: matchingTimestamps - Find index of first and last timestamp matching
         a given timestamp - i.e., same day for daily data else same hour.
INPUTS:  const Timestamp& beginTimestamp          Beginning timestamp to find
         const Timestamp& endTimestamp            Ending    timestamp to find
         const std::vector<Timestamp>& startingTimestamps  Sorted starting
                                                           Timestamps to search.
         const std::vector<Timestamp>& endingTimestamps    Sorted ending
                                                           Timestamps to search.
OUTPUTS: size_t& first                       Index of first matching timestamp.
         size_t& last                        Index of last  matching timestamp.
RETURNS: bool true if found matches else false if no matches found.
INTERFACE:
bool Dataset::matchingTimestamps( const Timestamp& beginTimestamp,
                                  size_t& first, size_t& last ) const
PRE09( beginTimestamp.invariant(),
       endTimestamp.invariant(),
       beginTimestamp <= endTimestamp,
       startingTimestamps.size(),
       startingTimestamps[ 0 ].invariant(),
       startingTimestamps[ startingTimestamps.size() - 1 ].invariant(),
       endingTimestamps.size() == startingTimestamps.size(),
       endingTimestamps[ 0 ].invariant(),
       endingTimestamps[ endingTimestamps.size() - 1 ].invariant() )
POST0( IMPLIES( result,
                AND2( IN_RANGE( first, 0, startingTimestamps.size() - 1 ),
                      IN_RANGE( last,  first, startingTimestamps.size()-1))))

-------------------------------------------------------------------------------

PURPOSE: vtimeseries - Probe dataset over time range at a specified location.
INPUTS:  const Timestamp& beginTimestamp  Beginning timestamp of sample.
         const Timestamp& endTimestamp    Ending timestamp of sample.
         const double longitude           Longitude of probe.
         const double latitude            Latitude of probe.
         const double elevation           Elevation of probe or MISSING.
OUTPUTS: std::vector<double>& result      Hourly values (or MISSING) over time
                                          range at location.
NOTES:   Called by base class member function timeseries().
         Template Method Design Pattern.
         This vitual default implementation calls probe() for each hour in
         the specified time range. Derived classes may have their own
         implementation that is more efficient.
INTERFACE:
void Dataset::vtimeseries( const Timestamp beginTimestamp,
                           std::vector<double>& result ) const
PRE5( beginTimestamp.invariant(),
      endTimestamp.invariant(),
      beginTimestamp <= endTimestamp,
      isLongitudeLatitude( longitude, latitude ),
      OR2( elevation == MISSING, isElevation( elevation ) ) )
POST3( result.size() >=
         1 + beginTimestamp.hoursUntil( endTimestamp ),
       OR2( ::emvl::minimum( &result[ 0 ], result.size() ) == MISSING,
            IMPLIES( ! isVector(),
                     IN_RANGE( ::emvl::minimum( &result[ 0 ], result.size() ),
                               minimum(), maximum() ) ) ),
       OR2( ::emvl::maximum( &result[ 0 ], result.size() ) == MISSING,
            IMPLIES( ! isVector(),
                     IN_RANGE( ::emvl::maximum( &result[ 0 ], result.size() ),
                               ::emvl::minimum( &result[ 0 ], result.size() ),
                               maximum() ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: allZeroHour - Do all Timestamps have hhmm == 00:00?
INPUTS:  const std::vector<Timestamp>& timestamps  Timestamps to search.
RETURNS: bool true if all Timestamps have hhmm == 00:00, else false.
INTERFACE:
bool Dataset::allZeroHour( const std::vector<Timestamp>& timestamps )
PRE03( timestamps.size(),
       timestamps[ 0 ].invariant(),
       timestamps[ timestamps.size() - 1 ].invariant() )
POST0( IMPLIES_ELSE( result,
                     timestamps[ 0 ].hhmmss() == 0,
                     timestamps[ 0 ].hhmmss() != 0 ) )

-------------------------------------------------------------------------------

PURPOSE: computeBounds - Compute bounds from coordinates.
INTERFACE:
void Dataset::computeBounds()
PRE02( coordinates_.size(), isValidCoordinates() )
POST0( bounds_.invariant() )

-------------------------------------------------------------------------------

PURPOSE: cellCenter - Average of cell vertices.
INPUTS:  const size_t cell  Index of cell.
RETURNS: Point center  Average of cell vertices.
INTERFACE:
Point Dataset::cellCenter( const size_t cell ) const
PRE( IN_RANGE( cell, 0, coordinates_.size() / cellVertexCount() - 1 ) )
POST2( isLongitudeLatitude( result.longitude, result.latitude ),
       isElevation( result.elevation ) )

-------------------------------------------------------------------------------

PURPOSE: computeVerticalRectangleCoordinates - Given cell center longitude,
         latitude, and elevation points, compute and store vertices of
         vertically-oriented rectangular cells for each cell center.
INPUTS:  const size_t groundPoints         Number of ground points.
         const size_t verticalPoints       Number of vertical points above
                                           each ground point.
         const double longitudeCenters[ groundPoints ] Cell center longitudes.
         const double latitudeCenters[  groundPoints ] Cell center latitudes.
         const double elevationCenters[  groundPoints * verticalPoints ]
                                         Cell center elevations.
         const double thicknessCenters[  groundPoints * verticalPoints ]
                                         Cell thicknesses or 0.
OUTPUTS: std::vector<Point>& coordinates  Coordinates to append each cell's
                                          4 vertices to.
NOTES:   Throws exception upon failure if invalid coordinate are in the data.
INTERFACE:
void Dataset::computeVerticalRectangleCoordinates( const size_t groundPoints,
                                            std::vector<Point>& coordinates )
PRE05( groundPoints > 0, verticalPoints > 0,
       longitudeCenters, latitudeCenters, elevationCenters)

-------------------------------------------------------------------------------

PURPOSE: computeVariableRanges - Compute range of each data variable.
INPUTS:  variables_, totalPoints_, data_
OUTPUTS: minimums_, maximums_
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::computeVariableRanges()
PRE06( variables_ > 0,
       data_.size() > 0,
       data_.size() % variables_ == 0,
       allFinite( &data_[ 0 ], data_.size() ),
       minimums_.size() == 0,
       maximums_.size() == 0 )
POST0( isValidRange() )

-------------------------------------------------------------------------------

PURPOSE: skipLine - Read and discard a line (of maximum length 255 characters)
         from a stream.
INPUTS:  FILE* file  Stream to read from.
OUTPUTS: FILE* file  Advanced stream.
NOTES:   throws std::runtime_error if unable to read a line (of length <= 255).
INTERFACE:
void Dataset::skipLine( FILE* file )
PRE0( file )

-------------------------------------------------------------------------------

PURPOSE: skipBytes - Read and discard bytes from a stream.
INPUTS:  FILE* file          Stream to read from.
         const size_t bytes  Bytes to skip.
OUTPUTS: FILE* file          Advanced stream.
NOTES:   throws std::runtime_error if unable to read bytes.
INTERFACE:
void Dataset::skipBytes( FILE* file, const size_t bytes )
PRE02( file, bytes )

-------------------------------------------------------------------------------

PURPOSE: readAndMatchLine - Read and match a line from a stream.
INPUTS:  FILE* file               Stream to read from.
         const char* const match  Line to match.
OUTPUTS: FILE* file               Advanced stream.
NOTES:   throws std::runtime_error if unable to read a matched line.
INTERFACE:
void Dataset::readAndMatchLine( FILE* file, const char* match )
PRE05( file, match, *match, strlen( match ) < 256,
       match[ strlen( match ) - 1 ] == '\n' )

-------------------------------------------------------------------------------

PURPOSE: readAndMatchLine2 - Read and match one or 2 lines from a stream.
INPUTS:  FILE* file                Stream to read from.
         const char* const match1  1st possible line to match.
         const char* const match2  2nd possible line to match.
OUTPUTS: FILE* file                Advanced stream.
RETURNS: int 1 if first line matched or 2 if second line matched.
NOTES:   throws std::runtime_error if unable to read a matched line.
INTERFACE:
int Dataset::readAndMatchLine2( FILE* file,
                                const char* const match2 )
PRE09( file,
       match1,
       *match1,
       strlen( match1 ) < 256,
       match1[ strlen( match1 ) - 1 ] == '\n',
       match2,
       *match2,
       strlen( match2 ) < 256,
       match2[ strlen( match2 ) - 1 ] == '\n' )

-------------------------------------------------------------------------------

PURPOSE: readDescription - Read description line from a stream.
INPUTS:  FILE* file    Stream to read from.
OUTPUTS: FILE* file    Advanced stream.
         description_  Description read.
NOTES:   throws std::runtime_error if unable to read a valid description.
INTERFACE:
void Dataset::readDescription( FILE* file )
PRE0( file )
POST0( isValidDescription() )

-------------------------------------------------------------------------------

PURPOSE: readTimestamp - Read timestamp line from a stream.
INPUTS:  FILE* file      Stream to read from.
         const bool two  Read two timestamps?
OUTPUTS: FILE* file      Advanced stream.
         startingTimestamp_  1st timestamp read.
         endingTimestamp_    if two then 2nd timestamp read else same as 1st.
NOTES:   throws std::runtime_error if unable to read a valid description.
INTERFACE:
void Dataset::readTimestamp( FILE* file, const bool two )
PRE0( file )
POST04( startingTimestamp_.invariant(),
        endingTimestamp_.invariant(),
        endingTimestamp_ >= startingTimestamp_,
        timesteps_ == 1 + startingTimestamp_.hoursUntil( endingTimestamp_ ) )

-------------------------------------------------------------------------------

PURPOSE: readDimensions - Read integer dimensions from a stream.
INPUTS:  FILE* file                  Stream to read from.
         const size_t count          Number of integers to read.
OUTPUTS: FILE* file                  Advanced stream.
         size_t dimensions[ count ]  Integer dimensions read.
NOTES:   throws std::runtime_error if unable to read a valid dimensions.
INTERFACE:
void Dataset::readDimensions( FILE* file, const size_t count,
                              size_t dimensions[] )
PRE03( file, count > 0, dimensions )
POST0( emvl::minimum( dimensions, count ) > 0 )

-------------------------------------------------------------------------------

PURPOSE: readVariablesAndUnits - Read variable names and units from a stream
         and append them to variableNames_ and variableUnits_.
INPUTS:  FILE* file          Stream to read from.
         const size_t count  Number of name/unit pairs to read
                             or 0 if unknown.
OUTPUTS: FILE* file          Advanced stream.
         variables_          Increased by count.
         dataVariable_       Set to variables_ - 1.
         variableNames_      Variable names read and appended.
         variableUnits_          Unit names read and appended.
NOTES:   throws std::runtime_error if unable to read a valid dimensions.
INTERFACE:
void Dataset::readVariablesAndUnits( FILE* file, const size_t count )
PRE02( file,
       IMPLIES_ELSE( variables_, isValidVariableNamesAndUnits(),
                     IS_ZERO3( dataVariable_,
                               variableNames_.size(),
                               variableUnits_.size() ) ) )
POST05( (size_t) variables_ >= count,
        (size_t) variables_ == variableNames_.size(),
        (size_t) variables_ == variableUnits_.size(),
        dataVariable_ == variables_ - 1,
        isValidVariableNamesAndUnits() )

-------------------------------------------------------------------------------

PURPOSE: setEndingTimestamp - Set endingTimestamp_ based on startingTimestamp_,
         timesteps_ and isDaily_.
INPUTS:  startingTimestamp_
         timesteps_
         isDaily_
OUTPUTS: endingTimestamp_
INTERFACE:
void Dataset::setEndingTimestamp()
PRE02( startingTimestamp_.invariant(), timesteps_ > 0 )
POST02( endingTimestamp_.invariant(), endingTimestamp_ > startingTimestamp_)

-------------------------------------------------------------------------------

PURPOSE: setDatasetNameFromDescriptionAndVariable - Parse description and
         name of current variable and use to set name of dataset.
INPUTS:  dataVariable_
         variableNames_  E.g., "co".
         description_    E.g., "regridded.MOZAIC.profile.co"
OUTPUTS: name_
INTERFACE:
void Dataset::setDatasetNameFromDescriptionAndVariable()
PRE03( isValidDescription(),
       dataVariable_ == variables_ - 1,
       isValidVariableNamesAndUnits() )
POST0( isValidName() )

-------------------------------------------------------------------------------

PURPOSE: readRegridded64BitVariables - Read XDR regridded variable 64-bit data
         from a stream.
INPUTS:  FILE* stream                 Stream to read from.
         const size_t layersPerPoint  Number of layers per point.
OUTPUTS: data_
         minimums_
         maximums_
NOTES:   Throws exception upon failure to read valid data from a stream.
INTERFACE:
void Dataset::readRegridded64BitVariables( FILE* stream,
                                           const size_t layersPerPoint )
PRE06( stream,
       variables_ > 0,
       coordinates_.size() / cellVertexCount(),
       data_.size() == 0,
       minimums_.size() == 0,
       maximums_.size() == 0 )
POST03( data_.size() == variables_ * coordinates_.size() / cellVertexCount(),
        isValidData(), isValidRange() )

-------------------------------------------------------------------------------

PURPOSE: readRegridded32BitVariables - Read XDR regridded variable 32-bit data
         from a stream.
INPUTS:  FILE* stream  Stream to read from.
OUTPUTS: data_
         minimums_
         maximums_
NOTES:   Throws exception upon failure to read valid data from a stream.
INTERFACE:
void Dataset::readRegridded32BitVariables( FILE* stream )
PRE06( stream,
       variables_ >= 3,
       coordinates_.size() / cellVertexCount(),
       data_.size() == 0,
       minimums_.size() == 0,
       maximums_.size() == 0 )
POST03( data_.size() == variables_ * coordinates_.size() / cellVertexCount(),
        isValidData(), isValidRange() )

-------------------------------------------------------------------------------

PURPOSE: writeRegridded64BitCoordinatesAndVariables - Write XDR regridded
         64-bit coordinates and variable data to a stream.
INPUTS:  FILE* stream          Stream to write to.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeRegridded64BitCoordinatesAndVariables( FILE* stream) const
PRE( stream )

-------------------------------------------------------------------------------

PURPOSE: writeRegridded32BitCoordinatesAndVariables - Write XDR regridded
         32-bit coordinates and variable data to a stream.
INPUTS:  FILE* stream  Stream to write to.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeRegridded32BitCoordinatesAndVariables( FILE* stream) const
PRE( stream )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDSCoordinates - Write COARDS-format longitude
         latitude and optionally elevation data to file.
INPUTS:  const int file        NetCDF file to write to.
         const int dimensions  Number of coordinate dimensions.
         const int dimensionSizes[ dimensions ]  Size of coordinate dimensions.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeCOARDSCoordinates( const int file,
                                      const int dimensionSizes[] ) const
PRE4( file > 0,
      dimensions > 0,
      dimensionSizes[ 0 ] > 0,
      dimensionSizes[ dimensions - 1 ] > 0 )

-------------------------------------------------------------------------------

PURPOSE: copyOutLongitudes - Copy longitude coordinate from coordinates_
         computing the cell center for multi-vertex cells.
INPUTS:  coordinates_
OUTPUTS: std::vector<float>& result  Copy of coordinates_[*].longitude.
INTERFACE:
void Dataset::copyOutLongitudes( std::vector<float>& result ) const
PRE( result.size() >= coordinates_.size() / cellVertexCount() )

-------------------------------------------------------------------------------

PURPOSE: copyOutLatitudes - Copy latitude coordinate from coordinates_
         computing the cell center for multi-vertex cells.
INPUTS:  coordinates_
OUTPUTS: std::vector<float>& result  Copy of coordinates_[*].latitude.
INTERFACE:
void Dataset::copyOutLatitudes( std::vector<float>& result ) const
PRE( result.size() >= coordinates_.size() / cellVertexCount() )

-------------------------------------------------------------------------------

PURPOSE: copyOutElevations - Copy elevation coordinate from coordinates_
         computing the cell center for multi-vertex cells.
INPUTS:  coordinates_
OUTPUTS: std::vector<float>& result  Copy of coordinates_[*].elevation.
INTERFACE:
void Dataset::copyOutElevations( std::vector<float>& result ) const
PRE( result.size() >= coordinates_.size() / cellVertexCount() )

-------------------------------------------------------------------------------

PURPOSE: copyOutVariable - Copy specified variable from data_.
INPUTS:  const int variable  Index of variable to copy.
         const float minimum  Minimum converted value to clamp to.
         const float maximum  Maximum converted value to clamp to.
         data_
OUTPUTS: std::vector<float>& result  Copy of data_[ variable ][ * ].
INTERFACE:
void Dataset::copyOutVariable( const int variable,
                               std::vector<float>& result ) const
PRE5( IN_RANGE( variable, 0, variables_ - 1 ),
      isFinite( minimum ), isFinite( maximum ), minimum <= maximum,
      result.size() >= data_.size() / variables_ )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDSVariables - Write COARDS-format variable data to file.
INPUTS:  const int file  NetCDF file to write to.
         const int skipVariables      Number of beginning data variables to
                                      skip / ignore / not write.
         const int integerVariables   Number of (remaining) data variables
                                      to write as integer data or 0.
         const int dimensionIds[]     Dimension ids.
         const int dimensionSizes[]   Size of each dimension.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeCOARDSVariables( const int file,
                                    const int dimensionSizes[] ) const
PRE6( file > 0,
      IN_RANGE( skipVariables, 0, variables_ ),
      IN_RANGE( integerVariables, 0, variables_ ),
      IN_RANGE( dimensions, 1, 4 ),
      emvl::minimum( dimensionSizes, dimensions ) > 0,
      dataFileOffset_ == 0 )

-------------------------------------------------------------------------------

PURPOSE: writeBufferedCOARDSVariables - Write COARDS-format variable data to
         file using buffering from fileName_.
INPUTS:  const int file  NetCDF file to write to.
         const int skipVariables      Number of beginning data variables to
                                      skip / ignore / not write.
         const int integerVariables   Number of (remaining) data variables
                                      to write as integer data or 0.
         const int dimensionIds[]     Dimension ids.
         const int dimensionSizes[]   Size of each dimension.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeBufferedCOARDSVariables( const int file,
                                            const int dimensionSizes[]) const
PRE10( file > 0,
       IN_RANGE( skipVariables, 0, variables_ ),
       IN_RANGE( integerVariables, 0, variables_ ),
       IN_RANGE( dimensions, 1, 4 ),
       emvl::minimum( dimensionSizes, dimensions ) > 0,
       dataFileOffset_ > 0,
       ! fileName_.empty(),
       timesteps_ > BUFFERED_DATA_TIMESTEPS,
       timesteps_ % BUFFERED_DATA_TIMESTEPS == 0,
       data_.size() % BUFFERED_DATA_TIMESTEPS == 0 )

-------------------------------------------------------------------------------

PURPOSE: createCOARDSVariables - Create definitions of COARDS-format
         coordinates, data variables and auxiliary variables in file.
INPUTS:  const int file               NetCDF file to update.
         const bool isRegridded       Create variables for column, row, layer?
         const int skipVariables      Number of data variables to skip.
         const int dimensions         Number of dimensions for each variable.
         const int dimensionIds[]     Dimension ids.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::createCOARDSVariables( const int file,
                                     const int dimensionIds[] ) const
PRE4( file > 0,
      IN_RANGE( skipVariables, 0, variables_ ),
      dimensions > 0,
      emvl::minimum( dimensionIds, dimensions ) >= 0 )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDSCommon - Create definitions of common COARDS-format
         variables and attributes and write coordinates, data variables and
         auxiliary variables in file.
INPUTS:  const int file               NetCDF file to update.
         const int skipVariables      Number of data variables to skip.
         const bool isRegridded       Create variables for column, row, layer?
         const int dimensions         Number of dimensions for each variable.
         const int dimensionIds[]     Dimension ids.
         const int dimensionSizes[]   Size of each dimension.
         const std::vector<Timestamp>& timestamps  Timestamps to write.
NOTES:   Throws exception upon failure. Ends definition of NetCDF file header.
INTERFACE:
void Dataset::writeCOARDSCommon( const int file,
                                   timestamps ) const
PRE10( file > 0,
       IN_RANGE( skipVariables, 0, variables_ ),
       IMPLIES( isRegridded, skipVariables == 0 ),
       dimensions > 0,
       dimensionIds,
       emvl::minimum( dimensionIds, dimensions ) >= 0,
       dimensionSizes,
       emvl::minimum( dimensionSizes, dimensions ) > 0,
       timestamps.size() == (size_t) dimensionSizes[ 0 ],
       startingTimestamp_ <= timestamps[ 0 ] )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPIHeader - Create definitions of common IOAPI-format
         dimensions, variables and attributes in file header.
INPUTS:  const int file               NetCDF file to write to.
         const bool andElevation      Create elevation variable definition?
         const bool forceUppercase    Ensure variable names are all capitals?
         const int skipVariables      Number of data variables to skip.
         const int layers             Number of grid layers.
         const int rows               Number of grid rows.
         const int columns            Number of grid columns.
         const CMAQGridParameters& gridParameters  Unsubsetted parameters.
         const size_t subsetIndices[ 4 ][ 2 ]  Optional subset grid indices:
                                          [TIME,LAYER,ROW,COLUMN][FIRST,LAST].
         const MapProjection* mapProjection  Map projcetion or 0 if lon-lat.
OUTPUTS: int dimensionIds[ 6 ]        NetCDF dimension ids:
                          dimensionIds[ TSTEP, DATE-TIME, LAY, VAR, ROW, COL ]
NOTES:   Throws exception upon failure. Ends definition of NetCDF file header.
INTERFACE:
void Dataset::writeIOAPIHeader( const int file,
                                int dimensionIds[ 6 ] ) const
PRE9( file > 0,
      skipVariables >= 0,
      layers > 0,
      rows > 0,
      columns > 0,
      gridParameters.invariant(),
      IMPLIES( subsetIndices,
               AND12( subsetIndices[ TIME   ][ FIRST ] >= 0,
                      subsetIndices[ TIME   ][ LAST  ] >=
                        subsetIndices[ TIME   ][ FIRST],
                      subsetIndices[ LAYER  ][ FIRST ] >= 1,
                      subsetIndices[ LAYER  ][ LAST  ] >=
                        subsetIndices[ LAYER ][ FIRST ],
                      subsetIndices[ ROW    ][ FIRST ] >= 1,
                      subsetIndices[ ROW    ][ LAST  ] >=
                        subsetIndices[ ROW   ][ FIRST ],
                      subsetIndices[ COLUMN ][ FIRST ] >= 1,
                      subsetIndices[ COLUMN ][ LAST  ] >=
                        subsetIndices[ COLUMN ][ FIRST ],
                      timesteps_ == 1 +
                        subsetIndices[ TIME ][ LAST ] -
                        subsetIndices[ TIME ][ FIRST ],
                      layers == (int) ( 1 +
                        subsetIndices[ LAYER ][ LAST ] -
                        subsetIndices[ LAYER ][ FIRST] ),
                      rows == (int) ( 1 +
                        subsetIndices[ ROW ][ LAST ] -
                        subsetIndices[ ROW ][ FIRST ] ),
                      columns == (int) ( 1 +
                        subsetIndices[ COLUMN ][ LAST ] -
                        subsetIndices[ COLUMN ][ FIRST ] ) ) ),
      IMPLIES( mapProjection, mapProjection->invariant() ),
      dimensionIds )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPIAttributes - Create definitions of common IOAPI-format
         dimensions, variables and attributes in file header.
INPUTS:  const int file               NetCDF file to write to.
         const bool andElevation      Include ELEVATION variable?
         const bool forceUppercase    Ensure variable names are all capitals?
         const int skipVariables      Number of variables to skip.
         const CMAQGridParameters& gridParameters  Unsubsetted parameters.
         const size_t subsetIndices[ 4 ][ 2 ]  Optional subset grid indices:
                                          [TIME,LAYER,ROW,COLUMN][FIRST,LAST].
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeIOAPIAttributes( const int file,
                                    const size_t subsetIndices[4][2] ) const
PRE4( file > 0,
      skipVariables >= 0,
      gridParameters.invariant(),
      IMPLIES( subsetIndices,
               AND9( subsetIndices[ TIME   ][ FIRST ] >= 0,
                     subsetIndices[ TIME   ][ LAST  ] >=
                       subsetIndices[ TIME   ][ FIRST],
                     subsetIndices[ LAYER  ][ FIRST ] >= 1,
                     subsetIndices[ LAYER  ][ LAST  ] >=
                       subsetIndices[ LAYER ][ FIRST ],
                     subsetIndices[ ROW    ][ FIRST ] >= 1,
                     subsetIndices[ ROW    ][ LAST  ] >=
                       subsetIndices[ ROW   ][ FIRST ],
                     subsetIndices[ COLUMN ][ FIRST ] >= 1,
                     subsetIndices[ COLUMN ][ LAST  ] >=
                       subsetIndices[ COLUMN ][ FIRST ],
                     timesteps_ == 1 +
                       subsetIndices[ TIME ][ LAST ] -
                       subsetIndices[ TIME ][ FIRST ] ) ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPITFLAGVariable - Write IOAPI-format TFLAG variable.
INPUTS:  const int file               NetCDF file to write to.
         const int outputVariables    Number of variables to write.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeIOAPITFLAGVariable( const int file,
                                       const int outputVariables ) const
PRE2( file > 0, outputVariables >= 3 )

-------------------------------------------------------------------------------

PURPOSE: computeCMAQGridLongitudesLatitudes - Compute longitude/latitude at
         each grid cell center using gridParameters.
INPUTS:  const CMAQGridParameters& gridParameters  Unsubsetted parameters.
         const size_t subsetIndices[ 4 ][ 2 ]  Optional subset grid indices:
                                          [TIME,LAYER,ROW,COLUMN][FIRST,LAST].
         const MapProjection* mapProjection  Map projcetion or 0 if lon-lat.
OUTPUTS: std::vector<float>& longitudes  Longitudes at grid cell centers.
         std::vector<float>& latitudes   Latitudes  at grid cell centers.
NOTES:   Throws exception upon failure to allocate data.
INTERFACE:
void Dataset::computeCMAQGridLongitudesLatitudes(
                                    std::vector<float>& latitudes ) const
PRE3( gridParameters.invariant(),
      IMPLIES( subsetIndices,
               AND9( subsetIndices[ TIME   ][ FIRST ] >= 0,
                     subsetIndices[ TIME   ][ LAST  ] >=
                       subsetIndices[ TIME   ][ FIRST],
                     subsetIndices[ LAYER  ][ FIRST ] >= 1,
                     subsetIndices[ LAYER  ][ LAST  ] >=
                       subsetIndices[ LAYER ][ FIRST ],
                     subsetIndices[ ROW    ][ FIRST ] >= 1,
                     subsetIndices[ ROW    ][ LAST  ] >=
                       subsetIndices[ ROW   ][ FIRST ],
                     subsetIndices[ COLUMN ][ FIRST ] >= 1,
                     subsetIndices[ COLUMN ][ LAST  ] >=
                       subsetIndices[ COLUMN ][ FIRST ],
                     timesteps_ == 1 +
                       subsetIndices[ TIME ][ LAST ] -
                       subsetIndices[ TIME ][ FIRST ] ) ),
      IMPLIES( mapProjection, mapProjection->invariant() ) )
POST4( isLongitude( emvl::minimum( &longitudes[ 0 ], longitudes.size() ) ),
       isLongitude( emvl::maximum( &longitudes[ 0 ], longitudes.size() ) ),
       isLatitude(  emvl::minimum( &latitudes[  0 ], latitudes.size() ) ),
       isLatitude(  emvl::maximum( &latitudes[  0 ], latitudes.size() ) ) )

-------------------------------------------------------------------------------

PURPOSE: readBounds - Read XDR-format array of bounds from a stream.
INPUTS:  FILE* stream            Stream to read from.
         const size_t count      Number of bounds to read.
OUTPUTS: Bounds output[ count ]  Array of bounds read.
NOTES:   Throws exception upon failure to read valid data from a stream.
INTERFACE:
void Dataset::readBounds( FILE* stream, const size_t count, Bounds bounds[] )
PRE03( stream, count >= 1, bounds )
POST02( bounds[ 0 ].invariant(), bounds[ count - 1 ].invariant() )

-------------------------------------------------------------------------------

PURPOSE: writeBounds - Write XDR-format array of bounds to a stream.
INPUTS:  FILE* stream  Stream to write to.
         const size_t count      Number of bounds to write.
         const Bounds bounds[ count ]  Array of bounds to write.
NOTES:   Throws exception upon failure to write valid data to a stream.
INTERFACE:
void Dataset::writeBounds( FILE* stream, const size_t count,
                           const Bounds bounds[] )
PRE05( stream, count >= 1, bounds,
       bounds[ 0 ].invariant(), bounds[ count - 1 ].invariant() )

-------------------------------------------------------------------------------

PURPOSE: readStrings - Read an array of strings from a stream.
INPUTS:  FILE* stream                      Stream to read from.
         const size_t length               Blank-padded + \n length.
OUTPUTS: std::vector<std::string>& strings Strings read w/o trailing spaces.
         FILE* stream                      Updated stream.
NOTES:   Throws exception upon failure to read valid data from a stream.
INTERFACE:
void Dataset::readStrings( FILE* stream, const size_t length,
                           std::vector<std::string>& strings )
PRE03( stream, IN_RANGE( length, 1, 1024 ), strings.size() >= 1 )
POST02( strings[ 0 ].length() < length,
        strings[ strings.size() - 1 ].length() < length )

-------------------------------------------------------------------------------

PURPOSE: writeStrings - Write an array of strings to a stream.
INPUTS:  FILE* stream                             Stream to write to.
         const size_t length                      Blank-padded + \n length.
         const std::vector<std::string>& strings  String to write.
OUTPUTS: FILE* stream                             Updated stream.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeStrings( FILE* stream, const size_t length,
                            const std::vector<std::string>& strings )
PRE03( stream, IN_RANGE( length, 1, 1024 ), strings.size() >= 1 )

-------------------------------------------------------------------------------

PURPOSE: readProjectionAndGrid - Read map projection and grid parameters of XDR
         header from a stream.
INPUTS:  FILE* stream                   Stream to read from.
         MapProjection*& mapProjection  Current projection object or 0.
OUTPUTS: MapProjection*& mapProjection  New projection object or 0 if lonlat.
         CMAQGridParameters& gridParameters Grid parameters read.
NOTES:   Throws exception upon failure to read valid input from a stream.
INTERFACE:
void Dataset::readProjectionAndGrid( FILE* stream,
                                     CMAQGridParameters& gridParameters )
PRE0( stream )
POST02( gridParameters.invariant(),
        IMPLIES_ELSE( gridParameters.gdtyp() == CMAQGridParameters::LATGRD3,
                      mapProjection == 0,
                      mapProjection->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: writeProjectionAndGrid - Write XDR format map projection and grid
         parameters to a stream.
INPUTS:  FILE* stream                              Stream to write to.
         const CMAQGridParameters& gridParameters  Grid description.
OUTPUTS: FILE* stream  Updated stream.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeProjectionAndGrid( FILE* stream,
                                        gridParameters )
PRE02( stream, gridParameters.invariant() )

-------------------------------------------------------------------------------

PURPOSE: readProjectionParameters - Read map projection parameters of XDR
         header from a stream.
INPUTS:  FILE* stream          Stream to read from.
OUTPUTS: FILE* stream          Advanced stream.
         double& sphereRadius  Spheroid radius.
         double& p_alp         p_alp projection parameter.
         double& p_bet         p_bet projection parameter.
         double& xcent         xcent projection parameter.
         double& ycent         ycent projection parameter.
         int& gdtyp            Projection type.
NOTES:   Throws exception upon failure to read valid data from a stream.
INTERFACE:
void Dataset::readProjectionParameters( FILE* stream,
                                        int& gdtyp )
PRE0( stream )

-------------------------------------------------------------------------------

PURPOSE: writeProjectionParameters - Write XDR format map projection parameters
         to a stream.
INPUTS:  FILE* stream  Stream to write to.
         const CMAQGridParameters& gridParameters  Grid description.
OUTPUTS: FILE* stream  Updated stream.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeProjectionParameters( FILE* stream,
                                           gridParameters )
PRE02( stream, gridParameters.invariant() )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDSNotes - Write COARDS-format notes array to file.
INPUTS:  const int file                        NetCDF file to write to.
         const size_t length                   Padded length of each string.
         const std::vector<std::string> notes  Notes to write.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeCOARDSNotes( const int file, const size_t length,
                                const std::vector<std::string>& notes )
PRE03( file > 0, IN_RANGE( length, 1, 1024 ), notes.size() )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDSDateTime - Write COARDS-format date and time data to file.
INPUTS:  const int file  NetCDF file to write to.
         const std::vector<Timestamp>& timestamps  Timestamps to write.
NOTES:   Throws exception upon failure.
INTERFACE:
void Dataset::writeCOARDSDateTime( const int file,
                                   const std::vector<Timestamp>& timestamps )
PRE02( file > 0, timestamps.size() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: ResourceHandler.h - Calls a handler on a resource in destructor.

TYPES:

namespace emvl {

template <typename T> class ResourceHandler {
public:
  typedef int   (*IntHandler)( T ); // Type of handler, e.g., fclose().
  typedef void (*VoidHandler)( T ); // Type of handler, e.g., free().
  typedef int   (*Handler2)( const char* ); // Type of 2nd handler. unlink().
public:

  /*
   * Constructors take a resource and a handler (returning either int or void)
   * to be called on resource when this object is destructed.
   */

  ResourceHandler( T resource, IntHandler handler )
    : resource( resource ), intHandler( handler ), voidHandler( 0 ),
    resource2( 0 ), handler2_( 0 ) {}
 
  ResourceHandler( T resource, VoidHandler handler )
    : resource( resource ), intHandler( 0 ), voidHandler( handler ),
    resource2( 0 ), handler2_( 0 ) {}

  // Destructor calls primary and optionally secondary handlers on resource:

  ~ResourceHandler() {
            
    if ( resource ) { // Doesn't call if resource is 0 (null).

      if ( intHandler ) {
        intHandler( resource );
      } else if ( voidHandler ) {
        voidHandler( resource );        
      }

      resource = 0;
      intHandler = 0;
      voidHandler = 0;

      if ( resource2 && handler2_ ) {
        handler2_( resource2 );
      }

      resource2 = 0;
      handler2_ = 0;
    }
  }

  // Set optional secondary handler:

  void handler2( const char* resource, Handler2 handler ) {
    resource2 = resource;
    handler2_ = handler;
  }

  T get() const { return resource; }
};

} // Namespace emvl.



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: DataUtilities.h - Declare basic low-level utility routines.

FUNCTIONS:

namespace emvl {

// Constants:

static const double MISSING = -9999.0;
static const int IMISSING = -99;
enum { LONGITUDE, LATITUDE, ELEVATION };
enum { MINIMUM, MAXIMUM };
enum { FIRST, LAST };
enum { COLUMN, ROW, LAYER, TIME };

// Basic numerics:

bool isSignedChar(       long long value );
bool isUnsignedChar(     long long value );
bool isSignedShort(      long long value );
bool isUnsignedShort(    long long value );
bool isSignedInt(        long long value );
bool isUnsignedInt(      long long value );
bool isSignedLong(       long long value );
bool isUnsignedLong(     long long value );
bool isSizet(            long long value );
bool isUnsignedLongLong( long long value );

long long toInteger( const char* string, long long lower, long long upper,
                     bool& ok );

double toReal( const char* string, double lower, double upper, bool& ok );


bool isInfinity(      double value );
bool isMinusInfinity( double value );
bool isFinite(        double value );
bool isNan(           double value );
template <typename T> bool isNan( const T* ) { return false; }
bool aboutEqual( double value1, double value2, double tolerance = 1e-6 );

bool isLongitude( double longitude );
bool isLatitude( double latitude );
bool isLongitudeLatitude( double longitude, double latitude );
double radians( double theDegrees );
double degrees( double theRadians );
  
double areaOfTriangle( const double x1, const double y1,
                       const double x2, const double y2,
                       const double x3, const double y3 );

bool pointInsideTriangle( const double x, const double y,
                          const double x1, const double y1,
                          const double x2, const double y2,
                          const double x3, const double y3 );

void reverse2ByteWordsIfLittleEndian( void* array, const size_t count = 1 );
void reverse4ByteWordsIfLittleEndian( void* array, const size_t count = 1 );
void reverse8ByteWordsIfLittleEndian( void* array, const size_t count = 1 );
void expand4ByteWords( double array[], const size_t count = 1 );
void expand4ByteWords( long long array[], const size_t count = 1 );
void expand4ByteWords( unsigned long long array[], const size_t count = 1 );

bool isNanFree( const double array[], const size_t count );
bool isNanFree( const float  array[], const size_t count );
template <typename T> bool isNanFree( const T*, const size_t ) { return true; }
bool allFinite( const double array[], const size_t count );
bool allFinite( const float  array[], const size_t count );
template <typename T> bool allFinite( const T*, const size_t ) { return true; }


// Are the only non-zero elements at indices of the given modulus?

template <typename T> bool onlyNonZeroModulo( const T modulus,
                                              const T array[],
                                              const size_t count ) {
  PRE03( modulus, array, count );
  bool result = AND2( count >= modulus, count % modulus == 0 );

  for ( size_t index = 0; AND2( result, index < count ); ++index ) {
    const T value = array[ index ];

    if ( index % modulus == 0 ) {
      result = value != 0;
    } else {
      result = value == 0;
    }
  }

  POST0( IMPLIES( result, array[ 0 ] ) );
  return result;
}


// Result is value clamped within range [low, high]:

template <typename T> T clampedToRange( const T value,
                                        const T low, const T high ) {
  PRE04( ! isNan( value ), ! isNan( low ), ! isNan( high ), low <= high );
  const T result = value < low ? low : value > high ? high : value;
  POST02( ! isNan( result ), IN_RANGE( result, low, high ) );
  return result;
}


// Are all array elements zero?

template <typename T> bool allZero( const T array[], const size_t count ) {
  PRE02( array, count );
  bool result = true;

  for ( size_t index = 0; AND2( result, index < count ); ++index ) {
    result = array[ index ] == 0;
  }

  POST02( IMPLIES( result, IS_ZERO2( array[ 0 ], array[ count - 1 ] ) ),
          IMPLIES( OR2( array[ 0 ], array[ count - 1 ] ), ! result ) );
  return result;
}


// Are all array elements non-zero?

template <typename T> bool allNonZero( const T array[], const size_t count ) {
  PRE02( array, count );
  bool result = true;

  for ( size_t index = 0; AND2( result, index < count ); ++index ) {
    result = array[ index ] != 0;
  }

  POST02( IMPLIES( result, ! IS_ZERO2( array[ 0 ], array[ count - 1 ] ) ),
          IMPLIES( OR2( ! array[ 0 ], ! array[ count - 1 ] ), ! result ) );
  return result;
}


// Are array elements ordered by <=?

template <typename T> bool isSorted( const T array[], const size_t count ) {
  PRE02( array, isNanFree( array, count ) );
  bool result = true;

  for ( size_t index = 1; AND2( result, index < count ); ++index ) {
    result = array[ index - 1 ] <= array[ index ];
  } 

  POST02( IMPLIES( result, array[ 0 ] <= array[ count - 1 ] ),
          IMPLIES( array[ 0 ] > array[ count - 1 ], ! result ) );
  return result;
}


// Are array elements ordered by <?

template <typename T> bool isIncreasing(const T array[], const size_t count) {
  PRE02( array, isNanFree( array, count ) );
  bool result = true;

  for ( size_t index = 1; AND2( result, index < count ); ++index ) {
    result = array[ index - 1 ] < array[ index ];
  } 

  POST02( IMPLIES( result, array[ 0 ] < array[ count - 1 ] ),
          IMPLIES( array[ 0 ] >= array[ count - 1 ], ! result ) );
  return result;
}


// Are array elements ordered by >?

template <typename T> bool isDecreasing(const T array[], const size_t count) {
  PRE02( array, isNanFree( array, count ) );
  bool result = true;

  for ( size_t index = 1; AND2( result, index < count ); ++index ) {
    result = array[ index - 1 ] > array[ index ];
  } 

  POST02( IMPLIES( result, array[ 0 ] > array[ count - 1 ] ),
          IMPLIES( array[ 0 ] <= array[ count - 1 ], ! result ) );
  return result;
}


// Is value in array?

template <typename T> bool has( const T array[], const size_t count, T value) {
  PRE04( array, count, isNanFree( array, count ), ! isNan( value ) );
  bool result = false;

  for ( size_t index = 0; AND2( ! result, index < count ); ++index ) {
    result = array[ index ] == value;
  }

  return result;
}


// Minimum element in array:

template <typename T> T minimum( const T array[], const size_t count ) {
  PRE03( array, count, isNanFree( array, count ) );
  T result = array[ 0 ];

  for ( size_t index = 1; index < count; ++index ) {
    const T value = array[ index ];

    if ( value < result ) {
      result = value;
    }
  }

  POST04( ! isNan( result ),
          result <= array[ 0 ],
          result <= array[ count - 1 ],
          has( array, count, result ) );
  return result;
}


// Maximum element in array:

template <typename T> T maximum( const T array[], const size_t count ) {
  PRE03( array, count, isNanFree( array, count ) );
  T result = array[ 0 ];

  for ( size_t index = 1; index < count; ++index ) {
    const T value = array[ index ];

    if ( value > result ) {
      result = value;
    }
  }

  POST04( ! isNan( result ),
          result >= array[ 0 ],
          result >= array[ count - 1 ],
          has( array, count, result ) );
  return result;
}


// Minimum and maximum elements in array:

template <typename T>
void range( const T array[], const size_t count, T& minimum, T& maximum ) {
  PRE03( array, count, isNanFree( array, count ) );
  minimum = maximum = array[ 0 ];

  for ( size_t index = 1; index < count; ++index ) {
    const T value = array[ index ];

    if ( value < minimum ) {
      minimum = value;
    } else if ( value > maximum ) {
      maximum = value;
    }
  }

  POST09( ! isNan( minimum ),
          ! isNan( maximum ),
          minimum <= maximum,
          minimum <= array[ 0 ],
          minimum <= array[ count - 1 ],
          maximum >= array[ 0 ],
          maximum >= array[ count - 1 ],
          has( array, count, minimum ),
          has( array, count, maximum ) );
}


// Minimum and maximum elements in array > threshold:

template <typename T>
void range( const T array[], const size_t count, const T threshold,
            T& minimum, T& maximum ) {
  PRE04( array, count, ! isNan( threshold ), isNanFree( array, count ) );
  minimum = maximum = array[ 0 ]; // Initialize to first item.

  for ( size_t index = 1; index < count; ++index ) {
    const T value = array[ index ];

    if ( value > threshold ) { // Only consider values > threshold.

      if ( minimum <= threshold ) { // Re-initialize to 1st item > threshold.
        minimum = maximum = value;
      } else if ( value < minimum ) {
        minimum = value;
      } else if ( value > maximum ) {
        maximum = value;
      }
    }
  }

  if ( minimum < threshold ) {
    minimum = threshold;
  }

  if ( maximum < minimum ) {
    maximum = minimum;
  }

  POST07( ! isNan( minimum ),
          ! isNan( maximum ),
          minimum <= maximum,
          IMPLIES( array[ 0 ] > threshold,
                   AND2( minimum <= array[ 0 ],
                         maximum >= array[ 0 ] ) ),
          IMPLIES( array[ count - 1 ] > threshold,
                   AND2( minimum <= array[ count - 1 ],
                         maximum >= array[ count - 1 ] ) ),
          IMPLIES( minimum != threshold,
                   AND2( minimum > threshold,
                         has( array, count, minimum ) ) ),
          IMPLIES( maximum != threshold,
                   AND2( maximum > threshold,
                         has( array, count, maximum ) ) ) );
}


// Sum of array elements.

template <typename T>
T sum( const T array[], const size_t count ) {
  PRE03( array, count, allFinite( array, count ) );
  T result = array[ 0 ];

  for ( size_t index = 1; index < count; ++index ) {
    result += array[ index ];
  }

  POST0( ! isNan( result ) );
  return result;
}


// Sum product of each pair of adjacent array elements.

template <typename T>
T sumProduct2( const T array[], const size_t count ) {
  PRE04( array, count, count % 2 == 0, allFinite( array, count ) );
  T result = 0;

  for ( size_t index = 0; index < count; index += 2 ) {
    result += array[ index ] * array[ index + 1 ];
  }

  POST0( ! isNan( result ) );
  return result;
}


// Maximum of products of pairs of adjacent array elements.

template <typename T>
T maximumProduct2( const T array[], const size_t count ) {
  PRE04( array, count, count % 2 == 0, allFinite( array, count ) );
  T result = 0;

  for ( size_t index = 0; index < count; index += 2 ) {
    const T product = array[ index ] * array[ index + 1 ];

    if ( product > result ) {
      result = product;
    }
  }

  POST0( ! isNan( result ) );
  return result;
}


// output += input.

template <typename T>
void accumulate( const T input[], T output[], const size_t count ) {
  PRE05( input, output, count,
         allFinite( input, count ), isNanFree( output, count ) );

  for ( size_t index = 0; index < count; ++index ) {
    output[ index ] += input[ index ];
  }

  POST0( isNanFree( output, count ) );
}


// if array > threshold then array *= scale. Returns maximum scaled element.

template <typename T>
T scaledMaximum( T array[], const size_t count, T scale, T threshold ) {
  PRE07( array, count, isNanFree( array, count ),
         scale, isFinite( scale ), ! isNan( scale ), ! isNan( threshold ) );
  bool initialized = false;
  T result = *array;

  for ( size_t index = 0; index < count; ++index ) {

    if ( array[ index ] > threshold ) {
      array[ index ] *= scale;

      if ( ! initialized ) {
        result = array[ index ];
        initialized = true;
      } else if ( array[ index ] > result ) {
        result = array[ index ];
      }
    }
  }

  POST0( ! isNan( result ) );
  return result;
}


// Swap row order of 2D array[ rows ][ columns ]:

template <typename T> void swapRows( T array[], const size_t rows,
                                     const size_t columns ) {
  PRE04( array, rows, columns, rows * columns );
  size_t lowerRowIndex = 0;
  size_t upperRowIndex = rows - 1;

  for ( ; lowerRowIndex < upperRowIndex; ++lowerRowIndex, --upperRowIndex ) {
    T* const lowerRowData = array + lowerRowIndex * columns;
    T* const upperRowData = array + upperRowIndex * columns;

    for ( size_t column = 0; column < columns; ++column ) {
      T temp = lowerRowData[ column ];
      lowerRowData[ column ] = upperRowData[ column ];
      upperRowData[ column ] = temp;
    }
  }
}


// Expand each 1-byte word in array to type T:

template <typename T> void expandBytes( T array[], const size_t count ) {
  PRE02( array, count );
  const unsigned char* input = (const unsigned char*) array;
  T* output = array + count;
  size_t counter = count;
  input += count;

  while ( counter-- ) {
    *--output = *--input;
  }
}


// Copy converted/clamped array data to output array.

template <typename T>
void copyArray( const double array[], const size_t count,
                const T minimum, const T maximum, T output[] ) {
  PRE07( array, count, isNanFree( array, count ),
         isFinite( minimum ), isFinite( maximum ), minimum <= maximum, output);

  for ( size_t index = 0; index < count; ++index ) {
    const double value = array[ index ];
    const double clampedValue =
      clampedToRange( value, (double) minimum, (double) maximum );
    const T convertedValue = (const T) clampedValue;
    output[ index ] = convertedValue;
  }
}


/*
 * Read from stream into buffer and convert/copy to output.
 * return true if converted values are in [minimum, maximum] else false.
 */

template <typename T1, typename T2>
bool readConvertedArray( FILE* const stream,
                         T1 buffer[], const size_t count,
                         const T2 minimum, const T2 maximum, T2 output[] ) {
  PRE05( stream, buffer, count, minimum <= maximum, output );
  bool result = fread( buffer, sizeof buffer[ 0 ], count, stream ) == count;

  if ( result ) {

    if ( sizeof buffer[ 0 ] == 8 ) {
      reverse8ByteWordsIfLittleEndian( buffer, count );
    } else if ( sizeof buffer[ 0 ] == 4 ) {
      reverse4ByteWordsIfLittleEndian( buffer, count );
    } else if ( sizeof buffer[ 0 ] == 2 ) {
      reverse2ByteWordsIfLittleEndian( buffer, count );
    }

    for ( size_t index = 0; AND2( result, index < count ); ++index ) {
      const T1 value = buffer[ index ];
      const T2 convertedValue = (const T2) value;
      result = IN_RANGE( convertedValue, minimum, maximum );

      if ( result ) {
        output[ index ] = convertedValue;
      }
    }
  }

  return result;
}


/*
 * Write to stream a buffer converted/copied from input and
 * clamped to [minimum, maximum].
 * returns true if successful.
 */

template <typename T1, typename T2>
bool writeConvertedArray( FILE* const stream,
                          T1 buffer[], const size_t count,
                          const T1 minimum, const T1 maximum,
                          const T2 input[] ) {
  PRE05( stream, buffer, count, minimum <= maximum, input );

  for ( size_t index = 0; index < count; ++index ) {
    const T2 value = input[ index ];
    const T1 convertedValue = (const T1) value;
    const T1 clampedValue =
      clampedToRange( convertedValue, minimum, maximum );
    buffer[ index ] = clampedValue;
  }

  if ( sizeof buffer[ 0 ] == 8 ) {
    reverse8ByteWordsIfLittleEndian( buffer, count );
  } else if ( sizeof buffer[ 0 ] == 4 ) {
    reverse4ByteWordsIfLittleEndian( buffer, count );
  } else if ( sizeof buffer[ 0 ] == 2 ) {
    reverse2ByteWordsIfLittleEndian( buffer, count );
  }

  const bool result =
    fwrite( buffer, sizeof buffer[ 0 ], count, stream ) == count;

  return result;
}


// String processing:

bool isValidArgs( int argc, const char* const argv[] );

size_t indexOfString( const char* string, const char* const strings[],
                      const size_t count );

size_t wordCount( const char* string );
size_t lineCount( const char* string );
bool isText( const char* string );
void lowercase( char string[] );
void eraseDoubleQuotedCommas( char string[] );

void substituteWord( const char* input,
                     const char* oldWord,
                     const char* newWord,
                     char* output );


// File processing:

bool fileExists( const char* fileName );
size_t fileSize( const char* fileName );
bool copyFile( const char* inputFileName, const char* outputFileName );
bool copyFileBytes( FILE* inputFile, FILE* outputFile );
bool copyFileBytes( FILE* inputFile, const char* outputFileName );
bool copyFileBytes( FILE* inputFile, const char* outputFileName,
                    const size_t bytes );
bool streamFile( const char* fileName );
bool streamFile( const char* fileName, FILE* stream );
void removeAllFiles( const char* const directoryName,
                     const char* const extensions = 0 );
void removeDirectory( const char* const directoryName );
bool isDirectory( const char* const name );
void directoryListing( const char* directoryName, const char* extensions,
                       size_t size, char buffer[] );


// Misc:

void elevationsAtSigmaPressures( const double g,
                                 const double R,
                                 const double A,
                                 const double T0s,
                                 const double P00,
                                 const double surfaceElevation,
                                 const int levels,
                                 const double topPressure,
                                 const double sigmaPressures[],
                                 double elevations[] );



} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: isSignedChar - Is value representable without loss as a signed char?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isSignedChar( long long value )
POST0( result == IN_RANGE( value, SCHAR_MIN, SCHAR_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: isUnsignedChar - Is value representable without loss as unsigned char?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isUnsignedChar( long long value )
POST0( result == IN_RANGE( value, 0, UCHAR_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: isSignedShort - Is value representable without loss as a signed short?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isSignedShort( long long value )
POST0( result == IN_RANGE( value, SHRT_MIN, SHRT_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: isUnsignedShort - Is value representable without loss as an unsigned
         short?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isUnsignedShort( long long value )
POST0( result == AND2( value >= 0,
                       OR2( sizeof (unsigned short) >= sizeof (long long),
                            value <= USHRT_MAX ) ) )

-------------------------------------------------------------------------------

PURPOSE: isSignedInt - Is value representable without loss as a signed int?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isSignedInt( long long value )
POST0( result == IN_RANGE( value, INT_MIN, INT_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: isUnsignedInt - Is value representable without loss as unsigned int?
INPUTS:  long long value The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isUnsignedInt( long long value )
POST0( result == AND2( value >= 0,
                       OR2( sizeof (unsigned int) >= sizeof (long long),
                            value <= UINT_MAX ) ) )

-------------------------------------------------------------------------------

PURPOSE: isSignedLong - Is value representable without loss as a signed long?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isSignedLong( long long value )
POST0( result == IN_RANGE( value, LONG_MIN, LONG_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: isUnsignedLong - Is value representable without loss as an unsigned
         long?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isUnsignedLong( long long value )
POST0( result == AND2( value >= 0,
                       OR2( sizeof (unsigned long) >= sizeof (long long),
                            value <= (long long) ULONG_MAX ) ) )

-------------------------------------------------------------------------------

PURPOSE: isSizet - Is value representable without loss as a size_t?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isSizet( long long value )
POST0( result == AND2( value >= 0,
                       OR2( sizeof (size_t) >= sizeof (long long),
                            value <= (long long) ULONG_MAX ) ) )

-------------------------------------------------------------------------------

PURPOSE: isUnsignedLongLong - Is value representable without loss as an
         unsigned long long?
INPUTS:  long long value  The value to test.
RETURNS: bool true if representable, else false.
INTERFACE:
bool isUnsignedLongLong( long long value )
POST0( result == AND2( value >= 0,
                       OR2(sizeof (unsigned long long) >= sizeof (long long),
                            (unsigned long long) value <= ULLONG_MAX ) ) )

-------------------------------------------------------------------------------

PURPOSE: toInteger - Integer value of string if within range [lower, upper].
INPUTS:  const char* string  - The string to convert.
         long long lower  The lower limit of valid range.
         long long upper  The upper limit of valid range.
OUTPUTS: bool& ok         Does string represent an integer in [lower,upper]?
RETURNS: long long value of string within range [lower, upper], else 0.
NOTES:   Unlike atoI(), strtoI() and scanf(), this routine rejects strings
         that would overflow or that contain non-digit characters (except
         an optional leading sign) or lack digit characters, or contain
         multiple whitespace-separated tokens.
INTERFACE:
long long toInteger( const char* string, long long lower, long long upper,
                     bool& ok )
PRE02( string, lower <= upper )
POST0( IMPLIES_ELSE( ok, IN_RANGE( result, lower, upper ), result == 0 ) )

-------------------------------------------------------------------------------

PURPOSE: toReal - Real value of string if within range [lower, upper].
INPUTS:  const char* string   The string to convert.
         double lower         The lower limit of valid range.
         double upper         The upper limit of valid range.
OUTPUTS: bool& ok             Is string an integer in [lower, upper]?
RETURNS: double value of string within range [lower, upper], else 0.0.
INTERFACE:
double toReal( const char* string, double lower, double upper, bool& ok )
PRE04( string, ! isNan( lower ), ! isNan( upper ), lower <= upper )
POST0( IMPLIES_ELSE( ok, IN_RANGE( result, lower, upper ), result == 0.0 ) )

-------------------------------------------------------------------------------

PURPOSE: isInfinity - Is the value so large that its recipricol is zero?
INPUTS:  double x - The value to test.
RETURNS: bool true if recipricol is zero, else false.
INTERFACE:
bool isInfinity( double x )
POST0( result == AND2( x > 0.0, OR2( x > DBL_MAX, 1.0 / x == 0.0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: isMinusInfinity - Is the value so small that its recipricol is zero?
INPUTS:  double x - The value to test.
RETURNS: bool true if recipricol is zero, else false.
INTERFACE:
bool isMinusInfinity( double x )
POST0( result == AND2( x < 0.0, OR2( x < -DBL_MAX, 1.0 / x == 0.0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: isFinite - Is the value and its recipricol
         non-NaN/+Infinity/-Infinity?
INPUTS:  double x - The value to test.
RETURNS: bool true if finite, else false.
INTERFACE:
bool isFinite( double x )
POST0( result == AND3( ! isNan(x), ! isInfinity(x), ! isMinusInfinity(x) ))

-------------------------------------------------------------------------------

PURPOSE: isNan - Is x a NaN (Not a Number)?
INPUTS:  double x - The 64-bit value to test.
RETURNS: bool true if x is a NaN, else false.
INTERFACE:
bool isNan( double x )

-------------------------------------------------------------------------------

PURPOSE: aboutEqual - Do x and y differ by less than (non-negative,
         finite) tolerance (i.e., fabs( x - y ) <= tolerance) or, for large
         values, differ only in digits beyond number of significant digits in
         tolerance? (E.g., tolerance = 1e-6 and 1.0000000001e30 and
         1.0000000002e30 are considered equal.)
INPUTS:  double x - first value to compare.
         double y - second value to compare.
         double tolerance - tolerance threshold (e.g., 1-e6).
RETURNS: bool reue if x and y differ (in significant digits) by less than
         tolerance, else false.
NOTES:   This function is commutative:
           withinTolerance( x, y, tolerance ) ==
           withinTolerance( y, x, tolerance )
         but not transitive:
           (withinTolerance( x, y, tolerance ) &&
            withinTolerance( x, z, tolerance ))
         does not imply
            withinTolerance( y, z, tolerance )
         (due to pivoting, e.g., about zero:
         if x == 0.0 and y = -tolerance and z == +tolerance,
         x ~ y and x ~ z but y !~ z)
         See: Squassabia, Alberto, "Comparing Floats", C++ Report, Vol 12,
         No 2, February 2000, pp 30-32, 39. SIGS Publications.
INTERFACE:
bool aboutEqual( double x, double y, double tolerance )
PRE02( ! isNan( tolerance ), IN_RANGE( tolerance, 0.0, 0.1 ) )

-------------------------------------------------------------------------------

PURPOSE: isLongitude - Is longitude in range [-180, 180]?
INPUTS:  double longitude Longitude to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool isLongitude( double longitude )
POST0( result == IN_RANGE( longitude, -180.0, 180.0 ) )

-------------------------------------------------------------------------------

PURPOSE: isLatitude - Is latitude in range [-90, 90]?
INPUTS:  double latitude Latitude to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool isLatitude( double latitude )
POST0( result == IN_RANGE( latitude, -90.0, 90.0 ) )

-------------------------------------------------------------------------------

PURPOSE: isLongitudeLatitude - Is (longitude, latitude) a valid point?
INPUTS:  double longitude Longitude to check.
         double latitude  Latitude  to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool isLongitudeLatitude( double longitude, double latitude )
POST0( result == AND2( isLongitude( longitude ), isLatitude( latitude ) ) )

-------------------------------------------------------------------------------

PURPOSE: radians - Radians of degrees.
INPUTS:  double theDegrees  The degrees to convert.
RETURNS: double radians of degrees.
INTERFACE:
double radians( double theDegrees )
PRE0( ! isNan( theDegrees ) )
POST03( ! isNan( result ),
        OR2( SIGN( result ) == SIGN( theDegrees ), result == 0.0 ),
        fabs( result ) <= fabs( theDegrees ) )

-------------------------------------------------------------------------------

PURPOSE: degrees - Degrees of radians.
INPUTS:  double theDegrees  The degrees to convert.
RETURNS: double radians of degrees.
INTERFACE:
double degrees( double theRadians )
PRE0( ! isNan( theRadians ) )
POST03( ! isNan( result ),
        OR2( SIGN( result ) == SIGN( theRadians ), result == 0.0 ),
        fabs( result ) >= fabs( theRadians ) )

-------------------------------------------------------------------------------

PURPOSE: areaOfTriangle - Area of triangle with vertices
         (x1, y1), (x2, y2), (x3, y3).
INPUTS:  const double x1   X-Coordinate of 1st vertex of triangle.
         const double y1   Y-Coordinate of 1st vertex of triangle.
         const double x2   X-Coordinate of 2nd vertex of triangle.
         const double y2   Y-Coordinate of 2nd vertex of triangle.
         const double x3   X-Coordinate of 3rd vertex of triangle.
         const double y3   Y-Coordinate of 3rd vertex of triangle.
RETURNS: double area.
INTERFACE:
double areaOfTriangle( const double x1, const double y1,
                       const double x3, const double y3 )

-------------------------------------------------------------------------------

PURPOSE: pointInsideTriangle - Determine if point (x, y) is inside triangle
         with vertices (x1, y1), (x2, y2), (x3, y3).
INPUTS:  const double x    X-Coordinate of point to test.
         const double y    Y-Coordinate of point to test.
         const double x1   X-Coordinate of 1st vertex of triangle.
         const double y1   Y-Coordinate of 1st vertex of triangle.
         const double x2   X-Coordinate of 2nd vertex of triangle.
         const double y2   Y-Coordinate of 2nd vertex of triangle.
         const double x3   X-Coordinate of 3rd vertex of triangle.
         const double y3   Y-Coordinate of 3rd vertex of triangle.
RETURNS: bool true if inside, else false.
INTERFACE:
bool pointInsideTriangle( const double x, const double y,
                          const double x3, const double y3 )

-------------------------------------------------------------------------------

PURPOSE: reverse2ByteWordsIfLittleEndian - Reverse 2-byte words of each array
         element if on a little-endian platform.
INPUTS:  void* array         Array of 2-byte values to reverse.
         const size_t count  Number of words in array.
OUTPUTS: void* array   Array of reversed values.
INTERFACE:
void reverse2ByteWordsIfLittleEndian( void* array, const size_t count )
PRE02( array, IN_RANGE( count, 1, LLONG_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: reverse4ByteWordsIfLittleEndian - Reverse 4-byte words of each array
         element if on a little-endian platform.
INPUTS:  void* array         Array of 4-byte values to reverse.
         const size_t count  Number of words in array.
OUTPUTS: void* array   Array of reversed values.
INTERFACE:
void reverse4ByteWordsIfLittleEndian( void* array, const size_t count )
PRE02( array, IN_RANGE( count, 1, LLONG_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: reverse8ByteWordsIfLittleEndian - Reverse 8-byte words of each array
         element if on a little-endian platform.
INPUTS:  void* array         Array of 8-byte values to reverse.
         const size_t count  Number of words in array.
OUTPUTS: void* array   Array of reversed values.
INTERFACE:
void reverse8ByteWordsIfLittleEndian( void* array, const size_t count )
PRE02( array, IN_RANGE( count, 1, LLONG_MAX ) )

-------------------------------------------------------------------------------

PURPOSE: expand4ByteWords - Expand 4-byte words of each array element stored
         at the first half of the array.
INPUTS:  double array[ count ]   Array of 4-byte floats to expand to double.
         const size_t count      Number of words in array.
OUTPUTS: double array[ count ]   Array of 8-byte doubles.
INTERFACE:
void expand4ByteWords( double array[], const size_t count )
PRE0( array )

-------------------------------------------------------------------------------

PURPOSE: expand4ByteWords - Expand 4-byte words of each array element stored
         at the first half of the array.
INPUTS:  long long array[ count ]  Array of 4-byte ints to expand to long long.
         const size_t count        Number of words in array.
OUTPUTS: long long array[ count ]  Array of 8-byte long longs
INTERFACE:
void expand4ByteWords( long long array[], const size_t count )
PRE0( array )

-------------------------------------------------------------------------------

PURPOSE: expand4ByteWords - Expand 4-byte words of each array element stored
         at the first half of the array.
INPUTS:  unsigned long long array[ count ]  Array of 4-byte unsigned ints to
                                            expand to unsigned long long.
         const size_t count        Number of words in array.
OUTPUTS: unsigned long long array[ count ]  Array of 8-byte unsigned long longs
INTERFACE:
void expand4ByteWords( unsigned long long array[], const size_t count )
PRE0( array )

-------------------------------------------------------------------------------

PURPOSE: isNanFree - Verify that an array contains no NaNs (Not A Number).
INPUTS:  const double* array  The array of values to check.
         size_t        count  The number of values in the array.
RETURNS: bool true if no NaNs found, else false.
INTERFACE:
bool isNanFree( const double array[], const size_t count )
PRE02( array, count )
POST0( IMPLIES( result,
                AND2( ! isNan( array[ 0 ] ), ! isNan( array[ count - 1 ]))))

-------------------------------------------------------------------------------

PURPOSE: isNanFree - Verify that an array contains no NaNs (Not A Number).
INPUTS:  const float* array  The array of values to check.
         size_t       count  The number of values in the array.
RETURNS: bool true if no NaNs found, else false.
INTERFACE:
bool isNanFree( const float array[], const size_t count )
PRE02( array, count )
POST0( IMPLIES( result,
                AND2( ! isNan( array[ 0 ] ), ! isNan( array[ count - 1 ]))))

-------------------------------------------------------------------------------

PURPOSE: allFinite - Are all array values finite?
INPUTS:  const double* array  The array of values to check.
         size_t count         The number of values in the array.
RETURNS: bool true if all values are finite, else false.
INTERFACE:
bool allFinite( const double array[], const size_t count )
PRE02( array, count )
POST0( IMPLIES( result,
                AND2( isFinite( array[ 0 ] ),
                      isFinite( array[ count - 1 ] ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: allFinite - Are all array values finite?
INPUTS:  const float* array  The array of values to check.
         size_t count        The number of values in the array.
RETURNS: bool true if all values are finite, else false.
INTERFACE:
bool allFinite( const float array[], const size_t count )
PRE02( array, count )
POST0( IMPLIES( result,
                AND2( isFinite( array[ 0 ] ),
                      isFinite( array[ count - 1 ] ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: isValidArgs() - Are each of the strings printable and blank-free?
INPUTS:  int argc                        Number of strings to check.
         const char* const argv[ argc ]  Strings to check.
RETURNS: bool true if non-zero, else 0.
INTERFACE:
bool isValidArgs( int argc, const char* const argv[] )

-------------------------------------------------------------------------------

PURPOSE: indexOfString - Index of string in strings[] or -1 if not present.
INPUTS:  const char* string           String to search for.
         const char* const strings[]  Strings to search.
         size_t count                 Size of strings[].
RETURNS: size_t index of string in strings[], else count if not present.
INTERFACE:
size_t indexOfString( const char* string, const char* const strings[],
                      size_t count)
PRE09( string, *string, strings, strings[ 0 ], *strings[ 0 ],
       count, strings[ count - 1 ], *strings[ count - 1 ],
       allNonZero( strings, count ) )
POST0( OR2( result == count,
            AND2( result < count,
                  ! strcmp( string, strings[ result ] ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: wordCount - Count number of whitespace-separated printable words
         in a string.
INPUTS:  const char* string  String to count.
RETURNS: size_t number of words in string.
INTERFACE:
size_t wordCount( const char* string )
PRE0( string )

-------------------------------------------------------------------------------

PURPOSE: wordCount - Count lines in a string.
INPUTS:  const char* string  String to count.
RETURNS: size_t number of lines ('\n' characters) in string.
INTERFACE:
size_t lineCount( const char* string )
PRE0( string )

-------------------------------------------------------------------------------

PURPOSE: isText - Is string non-empty and only contains isprint() characters?
INPUTS:  const char* string  String to check.
RETURNS: bool true if each character in string isprint(), else 0.
INTERFACE:
bool isText( const char* string )
PRE0( string )

-------------------------------------------------------------------------------

PURPOSE: lowercase - Convert a string to lowercase.
INPUTS:  char string[]  String to convert.
OUTPUTS: char string[]  Lowercase string.
INTERFACE:
void lowercase( char string[] )
PRE0( string )
POST0( IMPLIES( *string, ! isupper( *string ) ) )

-------------------------------------------------------------------------------

PURPOSE: eraseDoubleQuotedCommas - Change commas to space in each double-quoted
         portion of string.
INPUTS:  char string[]  String to convert.
OUTPUTS: char string[]  Converted string.
INTERFACE:
void eraseDoubleQuotedCommas( char string[] )
PRE0( string )

-------------------------------------------------------------------------------

PURPOSE: substituteWord - Change occurrences of oldWord to newWord in input.
INPUTS:  const char* input    String to read.
         const char* oldWord  Word to search for.
         const char* newWord  Word to substitute.
OUTPUTS: char* output         Resulting string.
INTERFACE:
void substituteWord( const char* input,
                     char* output )
PRE06( input, oldWord, *oldWord, newWord, output, input != output )
POST0( IMPLIES( strcmp( oldWord, newWord ), ! strstr( output, oldWord ) ) )

-------------------------------------------------------------------------------

PURPOSE: fileExists - Determine named file exists.
INPUTS:  const char* name  Name of file to examine.
RETURNS: bool truw if the named file exists, else false.
INTERFACE:
bool fileExists( const char* name )
PRE02( name, *name )

-------------------------------------------------------------------------------

PURPOSE: fileSize - Determine size of named file.
INPUTS:  const char* name  Name of file to examine.
RETURNS: size_t Size, in bytes, of named file, else 0 if failed.
INTERFACE:
size_t fileSize( const char* name )
PRE02( name, *name )

-------------------------------------------------------------------------------

PURPOSE: copyFileBytes - Copy all of a file's bytes to another file.
INPUTS:  FILE* inputFile   File to copy.
         FILE* outputFile  Created file.
RETURNS: bool true if successful, else false.
INTERFACE:
bool copyFileBytes( FILE* inputFile, FILE* outputFile )
PRE03( inputFile, outputFile, inputFile != outputFile )

-------------------------------------------------------------------------------

PURPOSE: copyFile - Copy a file.
INPUTS:  const char* inputFileName   Pathed name of file to copy.
         const char* outputFileName  Created file.
RETURNS: bool true if successful, else false.
INTERFACE:
bool copyFile( const char* inputFileName, const char* outputFileName )
PRE04( inputFileName, *inputFileName, outputFileName, *outputFileName )

-------------------------------------------------------------------------------

PURPOSE: copyFileBytes - Copy all of a file's bytes to another file.
INPUTS:  FILE* inputFile             File to copy.
         const char* outputFileName  Created file.
RETURNS: bool true if successful, else false.
INTERFACE:
bool copyFileBytes( FILE* inputFile, const char* outputFileName )
PRE03( inputFile, outputFileName, *outputFileName )

-------------------------------------------------------------------------------

PURPOSE: copyFileBytes - Copy some of file's bytes to another file.
INPUTS:  FILE* inputFile             File to copy.
         const char* outputFileName  Created file.
         size_t bytes                Bytes to read and write.
RETURNS: bool true if successful, else false.
INTERFACE:
bool copyFileBytes( FILE* inputFile, const char* outputFileName,
                    const size_t bytes)
PRE04( inputFile, outputFileName, *outputFileName, bytes )

-------------------------------------------------------------------------------

PURPOSE: streamFile - Stream bytes of a file to stdout.
INPUTS:  const char* fileName  Name of file to stream.
RETURNS: bool true if successful, else false.
INTERFACE:
bool streamFile( const char* fileName )
PRE02( fileName, *fileName )

-------------------------------------------------------------------------------

PURPOSE: streamFile - Stream bytes of named file to given stream.
INPUTS:  const char* fileName  Name of file to stream.
OUTPUTS: FILE* stream          Stream to write to.
RETURNS: bool true if successful, else false.
INTERFACE:
bool streamFile( const char* fileName, FILE* stream )
PRE03( fileName, *fileName, stream )

-------------------------------------------------------------------------------

PURPOSE: removeAllFiles - Remove all files (but not sub-directories) in a
         directory.
INPUTS:  const char* directoryName  Name of directory to remove files from.
         const char* extensions  Optional: file extensions to remove.
                                 E.g., "xdr nc" only removes .xdr and .nc files
                                 If extensions is 0 then all files are removed.
INTERFACE:
void removeAllFiles( const char* const directoryName,
                     const char* const extensions )
PRE0( isDirectory( directoryName ) )

-------------------------------------------------------------------------------

PURPOSE: removeDirectory - Remove a directory and its contents.
INPUTS:  const char* directoryName  Name of directory to remove.
INTERFACE:
void removeDirectory( const char* const directoryName )
PRE0( isDirectory( directoryName ) )

-------------------------------------------------------------------------------

PURPOSE: isDirectory - Is the given name a directory?
INPUTS:  const char* const name  Name of directory.
RETURNS: bool true if name is a directory, else false.
INTERFACE:
bool isDirectory( const char* const name )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: directoryListing - List files in a directory that end with one of
         the given extensions and are dated today.
INPUTS:  const char* directory   Name of directory.
         const char* extensions  Optional: file extensions to filter by.
                                 E.g., "shx shp txt".
         size_t size             Size of buffer[].
OUTPUTS: char buffer[ size ]     Result containing formatted columns:
                                 bytes hh:mm name
                                 sorted by file name.
INTERFACE:
void directoryListing( const char* directory, const char* extensions,
                       size_t size, char buffer[] )
PRE03( isDirectory( directory ), size, buffer )

-------------------------------------------------------------------------------

PURPOSE: elevationsAtSigmaPressures - Compute elevations in meters above mean
         sea-level at sigma-pressures.
INPUTS:  const double g                Gravitational force, e.g., 9.81 m/s^2.
         const double R                Gas constant. 287.04 J/kg/K = m^3/s/K.
         const double A                Atmospheric lapse rate, e.g., 50.0 K/kg.
         const double T0s              Reference surface temperature, 2900 K.
         const double P00              Reference surface pressure, 100000 Pa.
         const double surfaceElevation Elevation of surface in meters AMSL.
         const int levels              Number of levels of sigmaPressures.
         const double topPressure      Pressure in Pa at the top of the model.
         const double sigmaPressures[ levels ]  Sigma-pressures at levels.
OUTPUTS: double elevations[ levels ]  Elevation in meters above MSL at sigmas.
NOTES:   Based on formula used in MM5.
INTERFACE:
void elevationsAtSigmaPressures( const double g,
                                 double elevations[] )
PRE014( ! isNan( g ),
        ! isNan( R ),
        ! isNan( A ),
        ! isNan( T0s ),
        ! isNan( P00 ),
        ! isNan( surfaceElevation ),
        surfaceElevation > -1000.0,
        levels > 0,
        ! isNan( topPressure ),
        GT_ZERO6( topPressure, g, R, A, T0s, P00 ),
        isNanFree( sigmaPressures, levels ),
        minimum( sigmaPressures, levels ) >= 0.0,
        maximum( sigmaPressures, levels ) <= 1.0,
        elevations )
POST03( isNanFree( elevations, levels ),
        minimum( elevations, levels ) >= -1000.0,
        maximum( elevations, levels ) <= 1e6 )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: HTTPConenction.h - For opening/closing/reading from an HTTP/S GET URL.
NOTES:   Example usage

#include <stdio.h>
#include <string.h>

#include <HTTPConnection.h>

int main( void ) {

  try {
    const char* const command =
      "/usr/bin/curl -k --silent --retry 0 -L --tcp-nodelay --max-time";
    emvl::HTTPConnection::initialize( command );
    const char* const url =
      "https://ofmpub.epa.gov/rsig/rsigserver?"
      "SERVICE=wcs&VERSION=1.0.0&REQUEST=GetCoverage&"
      "COVERAGE=uvnet.irradiance&"
      "TIME=1996-01-01T00:00:00Z/1996-01-02T23:59:59Z&BBOX=-118,33,-117,35&"
      "FORMAT=ascii";
    const int timeoutSeconds = 300;
    emvl::HTTPConnection connection( url, timeoutSeconds );
    enum { LINE_SIZE = 256 };
    char line[ LINE_SIZE ] = "";

    while ( connection.read( LINE_SIZE, line ) ) {
      printf( "%s", line );
    }

  } catch ( ... ) {
    fprintf( stderr, "\nFailed!\n" );
  }

  return 0;
}


TYPES:

namespace emvl {

class HTTPConnection {
public:
  static void initialize( const char* anHTTPGetProgram );
  static const char* getHTTPGetProgram() { return HTTPGetProgram; }
  static bool isInitialized() { return *HTTPGetProgram != '\0'; }
  HTTPConnection( const char* url, const int timeoutSeconds ); //x
  ~HTTPConnection();
  bool invariant() const;
  FILE* getStream() const { return stream; };
  bool read( const size_t size, char line[] ); // Read a line of ASCII text.
  bool read( const size_t count, const size_t wordSize, void* array ); //binary
};

} // Namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: initialize - Initialize with program used to send HTTP queries.
INPUTS:  const char* const HTTPGetUtility  Pathed program command to use to get
                                           HTTP/HTTPS queries, for example,
         "/usr/bin/curl -k --silent --retry 0 -L --tcp-nodelay --max-time "
                                           Note that the HTTPGetUtility will
                                           have timeout (seconds) appended
                                           after it when used in the constructor
                                           below.
INTERFACE:
void HTTPConnection::initialize( const char* const HTTPGetUtility )
PRE02( HTTPGetUtility, *HTTPGetUtility )
POST0( isInitialized() )

-------------------------------------------------------------------------------

PURPOSE: HTTPConnection - Construct an HTTPConnection.
INPUTS:  const char* url           Full URL of HTTP query.
         const int timeoutSeconds  Maximum number of seconds to wait to receive
                                   data before giving up in failure or
                                   0 to wait indefinitely.
INTERFACE:
HTTPConnection::HTTPConnection( const char* url, const int timeoutSeconds )
PRE05( isInitialized(), url, *url,
       OR2( strstr( url, "http://" ) == url,
            strstr( url, "https://" ) == url ),
       timeoutSeconds >= 0 )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: ~HTTPConnection - Destruct a HTTPConnection.
INTERFACE:
HTTPConnection::~HTTPConnection()
PRE( true )
POST0( stream == 0 )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true or else there is a bug.
INTERFACE:
bool HTTPConnection::invariant() const

-------------------------------------------------------------------------------

PURPOSE: read - Read a line of text from a connection.
INPUTS:  const size_t size  Size of line.
OUTPUTS: char line[ size ]  Line of text read.
RETURNS: bool true if a line was read, else false.
INTERFACE:
bool HTTPConnection::read( const size_t size, char line[] )
PRE2( size, line )
POST0( result == AND3( *line != '\0', ! strchr( line, '\r' ), isText( line)))

-------------------------------------------------------------------------------

PURPOSE: read - Read an array of big-endian binary words from a connection.
INPUTS:  const size_t count     Number of words to read.
         const size_t wordSize  Size, in bytes, per word.
OUTPUTS: void* array            Data words read from stream.
RETURNS: bool true if the expected words of data were read, else false.
NOTES:   if wordSize is 2, 4 or 8 then word bytes will have been rotated on a
         little-endian platform.
INTERFACE:
bool HTTPConnection::read( const size_t count, const size_t wordSize,
                           void* array )
PRE3( count, IN5( wordSize, 1, 2, 4, 8 ), array )
POST( true )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Bounds.h - Longitude-latitude rectangle domain.

TYPES:

namespace emvl {

class Bounds {
public:

  // Commands:

  ~Bounds();
  Bounds( double west  = -180.0, double east  =  180.0,
          double south =  -90.0, double north =   90.0 );
  Bounds( const Bounds& );
  Bounds& operator=( const Bounds& );
  void west( double west );
  void east( double east );
  void south( double south );
  void north( double north );

  // Queries:

  double west() const;
  double east() const;
  double south() const;
  double north() const;
  bool operator==( const Bounds& ) const;
  bool operator!=( const Bounds& ) const;
  bool overlaps( const Bounds& ) const;
  bool invariant() const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Bounds - Destruct a Bounds.
INTERFACE:
Bounds::~Bounds()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Bounds - Construct a Bounds.
INPUTS:  double west  West bound.
         double east  East bound.
         double south South bound.
         double north North bound.
INTERFACE:
Bounds::Bounds( double west, double east, double south, double north )
PRE06( isLongitude( west ), isLongitude( east ),
       isLatitude( south ), isLatitude( north ),
       west <= east, south <= north )
POST4( this->west() == west, this->east() == east,
       this->south() == south, this->north() == north )

-------------------------------------------------------------------------------

PURPOSE: Bounds - Copy construct a Bounds.
INPUTS:  const Bounds& other  Other bounds to copy.
INTERFACE:
Bounds::Bounds( const Bounds& other )
PRE0( other.invariant() )
POST4( west() == other.west(), east() == east(),
       south() == other.south(), north() == other.north() )

-------------------------------------------------------------------------------

PURPOSE: oprator= - Assign a Bounds.
INPUTS:  const Bounds& other  Bounds to copy.
RETURNS: Bounds& this.
INTERFACE:
Bounds& Bounds::operator=( const Bounds& other )
PRE( other.invariant() )
POST( operator==( other ) )

-------------------------------------------------------------------------------

PURPOSE: west - Set west edge of bounds.
INPUTS: double west edge of bounds.
INTERFACE:
void Bounds::west( double west )
PRE( isLongitude( west ) )
POST( this->west() == west )

-------------------------------------------------------------------------------

PURPOSE: east - Set east edge of bounds.
INPUTS: double east edge of bounds.
INTERFACE:
void Bounds::east( double east )
PRE( isLongitude( east ) )
POST( this->east() == east )

-------------------------------------------------------------------------------

PURPOSE: south - Set south edge of bounds.
INPUTS: double south edge of bounds.
INTERFACE:
void Bounds::south( double south )
PRE( isLatitude( south ) )
POST( this->south() == south )

-------------------------------------------------------------------------------

PURPOSE: north - Set north edge of bounds.
INPUTS: double north edge of bounds.
INTERFACE:
void Bounds::north( double north )
PRE( isLatitude( north ) )
POST( this->north() == north )

-------------------------------------------------------------------------------

PURPOSE: west - West edge of bounds.
RETURNS: double west edge of bounds.
INTERFACE:
double Bounds::west() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: east - East edge of bounds.
RETURNS: double east edge of bounds.
INTERFACE:
double Bounds::east() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: south - South edge of bounds.
RETURNS: double south edge of bounds.
INTERFACE:
double Bounds::south() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: north - North edge of bounds.
RETURNS: double north edge of bounds.
INTERFACE:
double Bounds::north() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are bounds equal?
INPUTS:  const Bounds& other  Bounds to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Bounds::operator==( const Bounds& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are bounds unequal?
INPUTS:  const Bounds& other  Bounds to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Bounds::operator!=( const Bounds& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: overlaps - Do bounds overlap?
INPUTS:  const Bounds& other  Bounds to compare to.
RETURNS: bool true if they overlap, else false.
INTERFACE:
bool Bounds::overlaps( const Bounds& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Is object valid?
RETURNS: bool true if valid, else false and the code contains a defect.
INTERFACE:
bool Bounds::invariant() const



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Timestamp.h - Calendar UTC date-timestamps.

TYPES:

namespace emvl {

class Timestamp {
public:

  // Types:

  enum { UTC_STRING_LENGTH = 24 }; // YYYY-MM-DDTHH:MM:SS-HHMM.
  typedef char UTCString[ UTC_STRING_LENGTH + 1 ];

  // Commands:

  ~Timestamp();
  Timestamp(); // Current time UTC.
  Timestamp( const Timestamp& other );
  Timestamp( const int yyyymmdd, const int hhmmss );
  Timestamp( const UTCString value );
  Timestamp& operator=( const Timestamp& other );
  void fromScanStartTime( const double value );
  void fromUTCString( const UTCString value );
  void yyyydddhhmmss( const int yyyyddd, const int hhmmss );
  void yyyymmddhhmmss( const int yyyymmdd, const int hhmmss );
  void offsetHours( const int hours );

  // Queries:

  static bool isUTCString( const UTCString value );
  static bool isYYYYDDD( const int yyyyddd );
  static bool isYYYYMMDD( const int yyyymmdd );
  static bool isHHMMSS( const int hhmmss );
  static int fileDateUTC( const char* fileName );
  static int timeZoneOffset( const char* timezoneName );
  void toUTCString( UTCString result ) const;
  long long seconds() const;
  int yyyyddd() const;
  int yyyymmdd() const;
  int hhmmss() const;
  Timestamp startOfHour() const;
  Timestamp endOfHour() const;
  Timestamp startOfDay() const;
  Timestamp endOfDay() const;
  int hoursUntil( const Timestamp& other ) const;
  bool operator==( const Timestamp& other ) const;
  bool operator!=( const Timestamp& other ) const;
  bool operator<=( const Timestamp& other ) const;
  bool operator>=( const Timestamp& other ) const;
  bool operator<( const Timestamp& other ) const;
  bool operator>( const Timestamp& other ) const;
  bool sameHour( const Timestamp& other ) const;
  bool sameDay( const Timestamp& other ) const;
  bool sameMonth( const Timestamp& other ) const;
  bool sameYear( const Timestamp& other ) const;
  bool invariant() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Timestamp - Destructor.
INTERFACE:
Timestamp::~Timestamp()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Timestamp - Contruct with current UTC date-time.
INTERFACE:
Timestamp::Timestamp()
POST( true )

-------------------------------------------------------------------------------

PURPOSE: yyyymmddhhmmss - Construct with yyyymmdd and hhmmss.
INPUTS:  const int yyyymmdd  Date.
         const int hhmmss    Time.
INTERFACE:
Timestamp::Timestamp( const int yyyymmdd, const int hhmmss )
PRE02( isYYYYMMDD( yyyymmdd ), isHHMMSS( hhmmss ) )
POST2( this->yyyymmdd() == yyyymmdd, this->hhmmss() == hhmmss )

-------------------------------------------------------------------------------

PURPOSE: Timestamp - Construct a timestamp from a UTCString.
INPUTS:  const UTCString value  Timestamp to initialize to.
INTERFACE:
Timestamp::Timestamp( const UTCString value )
PRE0( isUTCString( value ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: Timestamp - Copy construct a timestamp.
INPUTS:  const Timestamp& other  Object to copy.
INTERFACE:
Timestamp::Timestamp( const Timestamp& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Copy a timestamp.
INPUTS:  const Timestamp& other  Object to copy.
INTERFACE:
Timestamp& Timestamp::operator=( const Timestamp& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: fromScanStartTime - Contruct from a NASA MODIS/CALIPSO scan start time
         TAI seconds since 1993-01-01T00:00:00Z).
INPUTS:  const double value  Scan start time value.
INTERFACE:
void Timestamp::fromScanStartTime( const double value )
PRE2( ! isNan( value ), IN_RANGE( value, 0.0, LLONG_MAX ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: fromUTCString - Contruct from a UTC string.
INPUTS:  const UTCString value  UTC string value.
INTERFACE:
void Timestamp::fromUTCString( const UTCString value )
PRE( isUTCString( value ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: yyyydddhhmmss - Set date to year and day of year plus time.
INPUTS:  const int yyyyddd  Year and day of year.
         const int hhmmss   Time.
INTERFACE:
void Timestamp::yyyydddhhmmss( const int yyyyddd, const int hhmmss )
PRE2( isYYYYDDD( yyyyddd ), isHHMMSS( hhmmss ) )
POST2( this->yyyyddd() == yyyyddd, this->hhmmss() == hhmmss )

-------------------------------------------------------------------------------

PURPOSE: yyyymmddhhmmss - Set to date and time.
INPUTS:  const int yyyymmdd  Date.
         const int hhmmss    Time.
INTERFACE:
void Timestamp::yyyymmddhhmmss(const int yyyymmdd, const int hhmmss)
PRE2( isYYYYMMDD( yyyymmdd ), isHHMMSS( hhmmss ) )
POST2( this->yyyymmdd() == yyyymmdd, this->hhmmss() == hhmmss )

-------------------------------------------------------------------------------

PURPOSE: offsetHours - Offset by hours.
INPUTS:  const int hours  Hours to offset.
INTERFACE:
void Timestamp::offsetHours( const int hours )
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: isUTCString - Is value a valid UTC string?
INPUTS:  const UTCString value  E.g., "2006-07-31T23:59:59-0000".
RETURNS: bool true if valid, else false.
INTERFACE:
bool Timestamp::isUTCString( const UTCString value )

-------------------------------------------------------------------------------

PURPOSE: isYYYYDDD - Is argument a valid year and day of year?
INPUTS:  const int yyyyddd  Value to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool Timestamp::isYYYYDDD( const int yyyyddd )

-------------------------------------------------------------------------------

PURPOSE: isYYYYMMDD - Is argument a valid year, month and day?
INPUTS:  const int yyyymmdd  Value to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool Timestamp::isYYYYMMDD( const int yyyymmdd )

-------------------------------------------------------------------------------

PURPOSE: isHHMMSS - Is argument a valid hour minute second?
INPUTS:  const int hhmmss  Value to check.
RETURNS: bool true if valid, else false.
INTERFACE:
bool Timestamp::isHHMMSS( const int hhmmss )

-------------------------------------------------------------------------------

PURPOSE: fileDateUTC - UTC date of a file.
INPUTS:  const char* fileName  File to check.
RETURNS: int yyyymmdd of file.
INTERFACE:
int Timestamp::fileDateUTC( const char* fileName )
PRE02( fileName, *fileName )
POST0( isYYYYMMDD( result ) )

-------------------------------------------------------------------------------

PURPOSE: timeZoneOffset - Hour offset from GMT.
INPUTS:  const char* timeZoneName  E.g., "EST".
RETURNS: int offset from GMT (e.g., -4).
NOTES:   Only implemented for US time zones.
INTERFACE:
int Timestamp::timeZoneOffset( const char* timeZoneName )
PRE02( timeZoneName, *timeZoneName )
POST0( IN_RANGE( result, -10, 0 ) )

-------------------------------------------------------------------------------

PURPOSE: toUTCString - Convert to UTCString.
OUTPUTS: UTCString result  UTC string value.
INTERFACE:
void Timestamp::toUTCString( UTCString result ) const
PRE0( result )
POST0( isUTCString( result ) )

-------------------------------------------------------------------------------

PURPOSE: seconds - Seconds since 1970-01-01T00:00:00Z.
RETURNS: long long seconds since 1970-01-01T00:00:00Z.
INTERFACE:
long long Timestamp::seconds() const
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: yyyyddd - Year and day of year.
RETURNS: int year and day of year.
INTERFACE:
int Timestamp::yyyyddd() const
PRE( true )
POST( isYYYYDDD( result ) )

-------------------------------------------------------------------------------

PURPOSE: yyyymmdd - Year, month and day.
RETURNS: int year, month and day.
INTERFACE:
int Timestamp::yyyymmdd() const
PRE( true )
POST( isYYYYMMDD( result ) )

-------------------------------------------------------------------------------

PURPOSE: hhmmss - Hour, minute and second.
RETURNS: int hour, minute and second.
INTERFACE:
int Timestamp::hhmmss() const
PRE( true )
POST( isHHMMSS( result ) )

-------------------------------------------------------------------------------

PURPOSE: startOfHour - Start of hour.
RETURNS: Timestamp at start of hour.
INTERFACE:
Timestamp Timestamp::startOfHour() const
PRE( true )
POST2( result.sameHour( *this ), result.hhmmss() % 10000 == 0 )

-------------------------------------------------------------------------------

PURPOSE: endOfHour - End of hour.
RETURNS: Timestamp at end of hour.
INTERFACE:
Timestamp Timestamp::endOfHour() const
PRE( true )
POST3( result.sameHour( *this ),
       result.hhmmss() / 100 % 100 == 59,
       result.hhmmss() % 100 == 59 )

-------------------------------------------------------------------------------

PURPOSE: startOfDay - Start of day.
RETURNS: Timestamp at start of day.
INTERFACE:
Timestamp Timestamp::startOfDay() const
PRE( true )
POST2( result.sameDay( *this ), result.hhmmss() == 0 )

-------------------------------------------------------------------------------

PURPOSE: endOfDay - End of day.
RETURNS: Timestamp at end of day.
INTERFACE:
Timestamp Timestamp::endOfDay() const
PRE( true )
POST2( result.sameDay( *this ), result.hhmmss() == 235959 )

-------------------------------------------------------------------------------

PURPOSE: hoursUntil - Hours until sameHour( other ).
INPUTS:  const Timestamp& other  Other timestamp.
RETURNS: int hours.
INTERFACE:
int Timestamp::hoursUntil( const Timestamp& other ) const
PRE2( other.invariant(), *this <= other )
POST( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Timestamp::operator==( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool Timestamp::operator!=( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Is this <= other?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if <=, else false.
INTERFACE:
bool Timestamp::operator<=( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Is this >= other?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if <=, else false.
INTERFACE:
bool Timestamp::operator>=( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Is this < other?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if <, else false.
INTERFACE:
bool Timestamp::operator<( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Is this > other?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if <, else false.
INTERFACE:
bool Timestamp::operator>( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: sameHour - Are objects the same date and within the same hour?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if same date and within same hour, else false.
INTERFACE:
bool Timestamp::sameHour( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: sameDay - Are objects the same date?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if same date and within same hour, else false.
INTERFACE:
bool Timestamp::sameDay( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: sameMonth - Are objects the same year and month?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if same year and month, else false.
INTERFACE:
bool Timestamp::sameMonth( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: sameYear - Are objects the same year?
INPUTS:  const Timestamp& other  Object to compare to.
RETURNS: bool true if same same year, else false.
INTERFACE:
bool Timestamp::sameYear( const Timestamp& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true.
INTERFACE:
bool Timestamp::invariant() const



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: MapProjection.h - Declare map projection ADT ABC.

MACROS:

#define PI_OVER_2 1.57079632679489661923
#define PI_OVER_4 0.78539816339744830962
#define SQUARE(x) ((x)*(x))

TYPES:

namespace emvl {

class MapProjection {
protected:

  double majorSemiaxis_; // Equitorial radius spheroid approximation of planet.
  double minorSemiaxis_; // Polar radius of spheroid approximation of planet.

public:

  // Constants:

  static const double MAP_PROJECTION_TOLERANCE;
  static const double MAP_PROJECTION_CONVERGENCE_TOLERANCE;
  static const int MAP_PROJECTION_CONVERGENCE_MAXIMUM_ITERATIONS;

  static const double AIRY_1830_MAJOR_SEMIAXIS;
  static const double AIRY_1830_MINOR_SEMIAXIS;
  static const double MODIFIED_AIRY_MAJOR_SEMIAXIS;
  static const double MODIFIED_AIRY_MINOR_SEMIAXIS;
  static const double ANDRAE_1876_MAJOR_SEMIAXIS;
  static const double ANDRAE_1876_MINOR_SEMIAXIS;
  static const double APPLIED_PHYSICS_1965_MAJOR_SEMIAXIS;
  static const double APPLIED_PHYSICS_1965_MINOR_SEMIAXIS;
  static const double AUSTRALIAN_NATL_SA_1969_MAJOR_SEMIAXIS;
  static const double AUSTRALIAN_NATL_SA_1969_MINOR_SEMIAXIS;
  static const double BESSEL_1841_MAJOR_SEMIAXIS;
  static const double BESSEL_1841_MINOR_SEMIAXIS;
  static const double BESSEL_NAMIBIA_1841_MAJOR_SEMIAXIS;
  static const double BESSEL_NAMIBIA_1841_MINOR_SEMIAXIS;
  static const double CLARKE_1866_MAJOR_SEMIAXIS;
  static const double CLARKE_1866_MINOR_SEMIAXIS;
  static const double CLARKE_1880_MAJOR_SEMIAXIS;
  static const double CLARKE_1880_MINOR_SEMIAXIS;
  static const double COMM_DES_POIDS_ET_MESURES_1799_MAJOR_SEMIAXIS;
  static const double COMM_DES_POIDS_ET_MESURES_1799_MINOR_SEMIAXIS;
  static const double DELAMBRE_1810_BELGIUM_MAJOR_SEMIAXIS;
  static const double DELAMBRE_1810_BELGIUM_MINOR_SEMIAXIS;
  static const double ENGELIS_1985_MAJOR_SEMIAXIS;
  static const double ENGELIS_1985_MINOR_SEMIAXIS;
  static const double EVEREST_1830_MAJOR_SEMIAXIS;
  static const double EVEREST_1830_MINOR_SEMIAXIS;
  static const double EVEREST_1948_MAJOR_SEMIAXIS;
  static const double EVEREST_1948_MINOR_SEMIAXIS;
  static const double EVEREST_1956_MAJOR_SEMIAXIS;
  static const double EVEREST_1956_MINOR_SEMIAXIS;
  static const double EVEREST_1969_MAJOR_SEMIAXIS;
  static const double EVEREST_1969_MINOR_SEMIAXIS;
  static const double EVEREST_SABAH_SARAWAK_MAJOR_SEMIAXIS;
  static const double EVEREST_SABAH_SARAWAK_MINOR_SEMIAXIS;
  static const double FISCHER_MERCURY_DATUM_1960_MAJOR_SEMIAXIS;
  static const double FISCHER_MERCURY_DATUM_1960_MINOR_SEMIAXIS;
  static const double MODIFIED_FISCHER_1960_MAJOR_SEMIAXIS;
  static const double MODIFIED_FISCHER_1960_MINOR_SEMIAXIS;
  static const double FISCHER_1968_MAJOR_SEMIAXIS;
  static const double FISCHER_1968_MINOR_SEMIAXIS;
  static const double GRS_IUGG_1967_MAJOR_SEMIAXIS;
  static const double GRS_IUGG_1967_MINOR_SEMIAXIS;
  static const double GRS_IUGG_1980_MAJOR_SEMIAXIS;
  static const double GRS_IUGG_1980_MINOR_SEMIAXIS;
  static const double HELMERT_1906_MAJOR_SEMIAXIS;
  static const double HELMERT_1906_MINOR_SEMIAXIS;
  static const double HOUGH_MAJOR_SEMIAXIS;
  static const double HOUGH_MINOR_SEMIAXIS;
  static const double IAU_1976_MAJOR_SEMIAXIS;
  static const double IAU_1976_MINOR_SEMIAXIS;
  static const double INTL_HAYFORD_1909_MAJOR_SEMIAXIS;
  static const double INTL_HAYFORD_1909_MINOR_SEMIAXIS;
  static const double KRASSOVSKY_1942_MAJOR_SEMIAXIS;
  static const double KRASSOVSKY_1942_MINOR_SEMIAXIS;
  static const double KAULA_1961_MAJOR_SEMIAXIS;
  static const double KAULA_1961_MINOR_SEMIAXIS;
  static const double LERCH_1979_MAJOR_SEMIAXIS;
  static const double LERCH_1979_MINOR_SEMIAXIS;
  static const double MAUPERTIUS_1738_MAJOR_SEMIAXIS;
  static const double MAUPERTIUS_1738_MINOR_SEMIAXIS;
  static const double MERIT_1983_MAJOR_SEMIAXIS;
  static const double MERIT_1983_MINOR_SEMIAXIS;
  static const double NAVAL_WEAPONS_LAB_1965_MAJOR_SEMIAXIS;
  static const double NAVAL_WEAPONS_LAB_1965_MINOR_SEMIAXIS;
  static const double NEW_INTERNATIONAL_1967_MAJOR_SEMIAXIS;
  static const double NEW_INTERNATIONAL_1967_MINOR_SEMIAXIS;
  static const double PLESSIS_1817_MAJOR_SEMIAXIS;
  static const double PLESSIS_1817_MINOR_SEMIAXIS;
  static const double SGS_1985_MAJOR_SEMIAXIS;
  static const double SGS_1985_MINOR_SEMIAXIS;
  static const double SOUTHEAST_ASIA_MAJOR_SEMIAXIS;
  static const double SOUTHEAST_ASIA_MINOR_SEMIAXIS;
  static const double WALBECK_MAJOR_SEMIAXIS;
  static const double WALBECK_MINOR_SEMIAXIS;
  static const double WGS_1960_MAJOR_SEMIAXIS;
  static const double WGS_1960_MINOR_SEMIAXIS;
  static const double WGS_1966_MAJOR_SEMIAXIS;
  static const double WGS_1966_MINOR_SEMIAXIS;
  static const double WGS_1972_MAJOR_SEMIAXIS;
  static const double WGS_1972_MINOR_SEMIAXIS;
  static const double WGS_1984_MAJOR_SEMIAXIS;
  static const double WGS_1984_MINOR_SEMIAXIS;
  static const double MM5_RADIUS;
  static const double CMAQ_RADIUS;
  static const double MCIDAS_RADIUS;
  static const double MOON_RADIUS;
  static const double MARS_MAJOR_SEMIAXIS;
  static const double MARS_MINOR_SEMIAXIS;
  static const double VENUS_RADIUS;

  // Commands:

  virtual ~MapProjection() = 0; // Non-instantiable Abstract Base Class.

  // Queries:

  static bool isSpheroid( double majorSemiaxis, double minorSemiaxis );
  static double lambdaDifference( double lambda, double lambda0 );
  static void toLambdaPhi( double longitude, double latitude,
                           double& lambda, double& phi );
  static void toLongitudeLatitude( double lambda, double phi,
                                   double& longitude, double& latitude );
  static double latitudeWGS84( double latitudeSphere );
  static double latitudeSphere( double latitudeWGS84 );

  static double ssfn( double phi, double sinePhi, double eccentricity );
  static double tsfn( double phi, double sinePhi, double eccentricity );
  static double msfn( double sinePhi, double cosinePhi,
                      double eccentricitySquared );
  static double qsfn( double sinePhi, double eccentricity,
                      double oneMinusEccentricitySquared );
  static double phi2Iterate( double ts, double eccentricity );

  virtual MapProjection* newCopy() const = 0;
  virtual bool invariant() const;
  virtual const char* name() const = 0;
  double majorSemiaxis() const;
  double minorSemiaxis() const;
  virtual double centralLongitude() const = 0;
  virtual double centralLatitude() const = 0;
  virtual void project( double longitude, double latitude,
                        double& x, double& y ) const = 0;
  virtual void unproject( double x, double y,
                          double& longitude, double& latitude ) const = 0;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~MapProjection - Destruct a MapProjection.
INTERFACE:
MapProjection::~MapProjection()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: isSpheroid  - Do the arguments define a valid spheroid planet shape?
INPUTS:  double majorSemiaxis Mean equitorial radius of planet approximation.
         double minorSemiaxis Mean polar      radius of planet approximation.
RETURNS: bool true if valid, else false.
INTERFACE:
bool MapProjection::isSpheroid( double majorSemiaxis, double minorSemiaxis )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: lambdaDifference - Tolerance-adjusted difference lambda - lambda0.
INPUTS:  double lambda   Angle (in radians) of longitude of point to project.
         double lambda0  Central longitude in radians.
RETURNS: double angle (in radians) of lambda - lambda0.
INTERFACE:
double MapProjection::lambdaDifference( double lambda, double lambda0 )
PRE02( IN_RANGE( lambda,  -M_PI + MAP_PROJECTION_TOLERANCE,
                           M_PI - MAP_PROJECTION_TOLERANCE ),
       IN_RANGE( lambda0, -M_PI, M_PI ) )
POST0( IN_RANGE( result, -M_PI, M_PI ) )

-------------------------------------------------------------------------------

PURPOSE: toLambdaPhi - Convert (longitude, latitude) to point on
         sphere/spheroid in radians.
OUTPUTS: double longitude  Longitude in degrees.
         double latitude   Latitude  in degrees.
INPUTS:  double& lambda    Longitude in radians.
         double& phi       Latitude  in radians.
INTERFACE:
void MapProjection::toLambdaPhi( double longitude, double latitude,
                                 double& lambda, double& phi )
PRE02( isLongitude( longitude ), isLatitude( latitude ) )
POST02( IN_RANGE( lambda, -M_PI + MAP_PROJECTION_TOLERANCE,
                           M_PI - MAP_PROJECTION_TOLERANCE ),
        IN_RANGE( phi, -PI_OVER_2 + MAP_PROJECTION_TOLERANCE,
                        PI_OVER_2 - MAP_PROJECTION_TOLERANCE ) )

-------------------------------------------------------------------------------

PURPOSE: toLongitudeLatitude - Convert point on sphere/spheroid to
         (longitude, latitude).
INPUTS:  double lambda      Longitude in radians.
         double phi         Latitude  in radians.
OUTPUTS: double& longitude  Longitude in degrees.
         double& latitude   Latitude  in degrees.
INTERFACE:
void MapProjection::toLongitudeLatitude( double lambda, double phi,
                                         double& longitude, double& latitude)
PRE04( ! isNan( lambda ), isFinite( lambda ),
       ! isNan( phi ), isFinite( phi ) )
POST02( isLongitude( longitude ), isLatitude( latitude ) )

-------------------------------------------------------------------------------

PURPOSE: latitudeWGS84 - Convert latitude on a sphere to latitude on a
         WGS84/GRS80/NAD83 spheroid.
INPUTS:  double latitudeSphere   Latitude on a sphere.
RETURNS: double equivalent latitude on a WGS84 spheroid.
NOTES:   http://en.wikipedia.org/wiki/Latitude#Geocentric_latitude.
INTERFACE:
double MapProjection::latitudeWGS84( double latitudeSphere )
PRE0( isLatitude( latitudeSphere ) )
POST02( isLatitude( result ),
        IMPLIES_ELSE( OR3( aboutEqual( latitudeSphere, 0.0 ),
                           aboutEqual( latitudeSphere, -90.0 ),
                           aboutEqual( latitudeSphere, 90.0 ) ),
                      aboutEqual( result, latitudeSphere ),
                      fabs( result - latitudeSphere ) < 0.1925 ) )

-------------------------------------------------------------------------------

PURPOSE: latitudeSphere - Convert latitude on a  WGS84/GRS80/NAD83 spheroid to
         a latitude on a sphere.
INPUTS:  double latitudeSphere   Latitude on a sphere.
RETURNS: double equivalent latitude on a WGS84 spheroid.
NOTES:   http://en.wikipedia.org/wiki/Latitude#Geocentric_latitude.
INTERFACE:
double MapProjection::latitudeSphere( double latitudeWGS84 )
PRE0( isLatitude( latitudeWGS84 ) )
POST02( isLatitude( result ),
        IMPLIES_ELSE( OR3( aboutEqual( latitudeWGS84, 0.0 ),
                           aboutEqual( latitudeWGS84, -90.0 ),
                           aboutEqual( latitudeWGS84, 90.0 ) ),
                      aboutEqual( result, latitudeWGS84 ),
                      fabs( result - latitudeWGS84 ) < 0.1925 ) )

-------------------------------------------------------------------------------

PURPOSE: ssfn - See USGS PROJ Library.
INPUTS:  double phi           Angle in radians.
         double sinePhi       Sine of phi.
         double eccentricity  Of planet approximation.
RETURNS: double See USGS PROJ Library.
INTERFACE:
double MapProjection::ssfn( double phi, double sinePhi, double eccentricity )
PRE07( ! isNan( phi ),
       ! isNan( sinePhi ),
       ! isNan( eccentricity ),
       sinePhi > -1.0,
       sinePhi < 1.0,
       aboutEqual( sinePhi, sin( phi ), MAP_PROJECTION_TOLERANCE ),
       IN_RANGE( eccentricity, 0.0, 0.7 ) )
POST0( ! isNan( result ) )

-------------------------------------------------------------------------------

PURPOSE: tsfn - See USGS PROJ Library.
INPUTS:  double phi      Angle in radians.
         double sinePhi  Sine of phi.
         double eccentricity  Of planet approximation.
RETURNS: double See USGS PROJ Library.
INTERFACE:
double MapProjection::tsfn( double phi, double sinePhi, double eccentricity )
PRE010( ! isNan( phi ),
        ! isNan( sinePhi ),
        ! isNan( eccentricity ),
        sinePhi > -1.0,
        sinePhi < 1.0,
        aboutEqual( sinePhi, sin( phi ), MAP_PROJECTION_TOLERANCE ),
        IN_RANGE( eccentricity, 0.0, 0.7 ),
        tan( ( PI_OVER_2 - phi ) * 0.5 ) != 0.0,
        fabs( eccentricity * sinePhi ) != 1.0,
        ( 1.0 + eccentricity * sinePhi ) != 0.0 )
POST02( ! isNan( result ), result != 0.0 )

-------------------------------------------------------------------------------

PURPOSE: msfn - See USGS PROJ Library.
INPUTS:  double sinePhi    Sine of phi.
         double cosinePhi  Cosine of phi.
         double eccentricitySquared  Of planet approximation.
RETURNS: double See USGS PROJ Library.
INTERFACE:
double MapProjection::msfn( double sinePhi, double cosinePhi,
                            double eccentricitySquared )
PRE012( ! isNan( sinePhi ),
        ! isNan( cosinePhi ),
        ! isNan( eccentricitySquared ),
        sinePhi   > -1.0,
        sinePhi   < 1.0,
        cosinePhi > -1.0,
        cosinePhi < 1.0,
        cosinePhi != 0.0,
        aboutEqual( fabs( sinePhi ), sqrt( 1.0 - SQUARE( cosinePhi ) ),
                    MAP_PROJECTION_TOLERANCE ),
        IN_RANGE( eccentricitySquared, 0.0, 0.5 ),
        eccentricitySquared * SQUARE( sinePhi ) < 1.0,
        sqrt( 1.0 - eccentricitySquared * SQUARE( sinePhi ) ) != 0.0 )
POST02( ! isNan( result ), result != 0.0 )

-------------------------------------------------------------------------------

PURPOSE: qsfn - See USGS PROJ Library.
INPUTS:  double sinePhi                Sine of phi.
         double eccentricity           Of planet approximation.
         double oneMinusEccentricitySquared 1 - eccentricity^2.
RETURNS: double See USGS PROJ Library.
INTERFACE:
double MapProjection::qsfn( double sinePhi, double eccentricity,
                            double oneMinusEccentricitySquared )
PRE08( ! isNan( sinePhi ),
       ! isNan( eccentricity ),
       ! isNan( oneMinusEccentricitySquared ),
       sinePhi > -1.0,
       sinePhi < 1.0,
       IN_RANGE( eccentricity, 0.0, 0.7 ),
       IN_RANGE( oneMinusEccentricitySquared, 0.0, 1.0 ),
       aboutEqual( oneMinusEccentricitySquared,
                   1.0 - SQUARE( eccentricity ),
                   MAP_PROJECTION_TOLERANCE ) )
POST0( ! isNan( result ) )

-------------------------------------------------------------------------------

PURPOSE: phi2Iterate - Iterate on unprojected y coordinate.
INPUTS:  double ts            See USGS PROJ Library.
         double eccentricity  Eccentrity of spheroid.
RETURNS: double converged phi.
INTERFACE:
double MapProjection::phi2Iterate( double ts, double eccentricity )
PRE0( IN_RANGE( eccentricity, 0.0, 0.7 ) )
POST0( ! isNan( result ) )

-------------------------------------------------------------------------------

PURPOSE: invariant - Is object valid?
RETURNS: bool true if valid, else false and the code contains a defect.
INTERFACE:
bool MapProjection::invariant() const

-------------------------------------------------------------------------------

PURPOSE: majorSemiaxis - Mean equitorial radius of spheroid.
RETURNS: double mean equitorial radius of spheroid.
INTERFACE:
double MapProjection::majorSemiaxis() const
PRE( true )
POST3( ! isNan( result ),
       IN_RANGE( result, 4.0 / 3.0, 1e15 ),
       result >= minorSemiaxis_ )

-------------------------------------------------------------------------------

PURPOSE: minorSemiaxis - Mean polar radius of spheroid.
RETURNS: double mean polar radius of spheroid.
INTERFACE:
double MapProjection::minorSemiaxis() const
PRE( true )
POST3( ! isNan( result ),
       IN_RANGE( result, 1.0, 1e15 ),
       result <= majorSemiaxis_ )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Albers.h - Declare Albers MapProjection ADT.

TYPES:

namespace emvl {
  
class Albers : public MapProjection {
public:

  // Commands:

  virtual ~Albers();
  Albers( double majorSemiaxis, double minorSemiaxis,
           double centralLongitude, double centralLatitude,
           double lowerLatitude, double upperLatitude );
  Albers( const Albers& other );
  Albers& operator=( const Albers& other );

  // Queries:

  virtual MapProjection* newCopy() const;
  virtual bool invariant() const;
  virtual const char* name() const;
  bool operator==( const Albers& other ) const;
  bool operator!=( const Albers& other ) const;
  virtual double centralLongitude() const;
  virtual double centralLatitude() const;
  virtual void project( double longitude, double latitude,
                        double& x, double& y ) const;
  virtual void unproject( double x, double y,
                          double& longitude, double& latitude ) const;
  double lowerLatitude() const;
  double upperLatitude() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Albers - Destruct a Albers.
INTERFACE:
Albers::~Albers()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Albers - Construct a Albers.
INPUTS:  double majorSemiaxis    Mean equitorial radius of spheroid in meters.
         double minorSemiaxis    Mean polar      radius of spheroid in meters.
         double centralLongitude Longitude that projects to 0.
         double centralLatitude  Latitude that projects to 0.
         double lowerLatitude    Latitude of lower secant.
         double upperLatitude    latitude of upper secant.
INTERFACE:
Albers::Albers( double majorSemiaxis, double minorSemiaxis,
                double lowerLatitude, double upperLatitude )
PRE010( isSpheroid( majorSemiaxis, minorSemiaxis ),
        isLongitude( centralLongitude ),
        isLatitude( centralLatitude ),
        IN_RANGE( centralLatitude, -89.0, 89.0 ),
        isLatitude( lowerLatitude ),
        isLatitude( upperLatitude ),
        lowerLatitude <= upperLatitude,
        SIGN( lowerLatitude ) == SIGN( upperLatitude ),
        IMPLIES_ELSE( lowerLatitude >= 0.0,
                      IN_RANGE( lowerLatitude, 1.0, 89.0 ),
                      IN_RANGE( lowerLatitude, -89.0, -1.0 ) ),
        IMPLIES_ELSE( upperLatitude >= 0.0,
                      IN_RANGE( upperLatitude, 1.0, 89.0 ),
                      IN_RANGE( upperLatitude, -89.0, -1.0 ) ) )
POST7( ! strcmp( this->name(), "Albers" ),
       this->majorSemiaxis() == majorSemiaxis,
       this->minorSemiaxis() == minorSemiaxis,
       this->centralLongitude() == centralLongitude,
       this->centralLatitude() == centralLatitude,
       this->lowerLatitude() == lowerLatitude,
       this->upperLatitude() == upperLatitude )

-------------------------------------------------------------------------------

PURPOSE: Albers - Copy construct a Albers.
INPUTS:  const Albers& other  Other object to copy.
INTERFACE:
Albers::Albers( const Albers& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a Albers.
INPUTS:  const Albers& other  Other object to copy.
RETURNS: Albers& *this.
INTERFACE:
Albers& Albers::operator=( const Albers& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: newCopy - Allocate, copy and return this.
NOTES:   Caller must delete returned result when no longer needed.
INTERFACE:
MapProjection* Albers::newCopy() const
PRE( true )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool Albers::invariant() const
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: name - Name of projection.
RETURNS: const char* "Albers".
INTERFACE:
const char* Albers::name() const
POST0( ! strcmp( result, "Albers" ) )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const Albers& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Albers::operator==( const Albers& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const Albers& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool Albers::operator!=( const Albers& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: centralLongitude - Longitude that projects to 0.
RETURNS: double longitude that projects to 0.
INTERFACE:
double Albers::centralLongitude() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: centralLatitude - Latitude that projects to 0.
RETURNS: double latitude that projects to 0.
INTERFACE:
double Albers::centralLatitude() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: project - Project a point from longitude-latitude space to x-y space.
INPUTS:  double longitude  Longitude of point to project.
         double latitude   Latitude  of point to project.
OUTPUTS: double& x         X coordinate of projected longitude.
         double& y         Y coordinate of projected latitude.
INTERFACE:
void Albers::project( double longitude, double latitude,
                      double& x, double& y ) const
PRE2( isLongitude( longitude ), isLatitude( latitude ) )
POST2( ! isNan( x ), ! isNan( y ) )

-------------------------------------------------------------------------------

PURPOSE: unproject - Unproject a point from x-y space to longitude-latitude.
INPUTS:  double x           X-coordinate of point to unproject.
         double y           X-coordinate of point to unproject.
OUTPUTS: double* longitude  Longitude of unprojected point X.
         double* latitude   Latitude  of unprojected point Y.
INTERFACE:
void Albers::unproject( double x, double y,
                        double& longitude, double& latitude ) const
PRE2( IN_RANGE( x, -4.0 * majorSemiaxis(),
                    4.0 * majorSemiaxis() ),
      IN_RANGE( y, -4.0 * M_PI * majorSemiaxis(),
                    4.0 * M_PI * majorSemiaxis() ) )
POST2( isLongitude( longitude ), isLatitude( latitude ) )

-------------------------------------------------------------------------------

PURPOSE: lowerLatitude - Lower latitude of secant plane.
RETURNS: double result lower latitude of secant plane.
INTERFACE:
double Albers::lowerLatitude() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: upperLatitude - Upper latitude of secant plane.
RETURNS: double result upper latitude of secant plane.
INTERFACE:
double Albers::upperLatitude() const
PRE( true )
POST2( isLatitude( result ), result >= lowerLatitude() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Lambert.h - Declare Lambert Conformal Conic MapProjection ADT.

TYPES:

namespace emvl {
  
class Lambert : public MapProjection {
public:

  // Commands:

  virtual ~Lambert();
  Lambert( double majorSemiaxis, double minorSemiaxis,
           double centralLongitude, double centralLatitude,
           double lowerLatitude, double upperLatitude );
  Lambert( const Lambert& other );
  Lambert& operator=( const Lambert& other );

  // Queries:

  virtual MapProjection* newCopy() const;
  virtual bool invariant() const;
  virtual const char* name() const;
  bool operator==( const Lambert& other ) const;
  bool operator!=( const Lambert& other ) const;
  virtual double centralLongitude() const;
  virtual double centralLatitude() const;
  virtual void project( double longitude, double latitude,
                        double& x, double& y ) const;
  virtual void unproject( double x, double y,
                          double& longitude, double& latitude ) const;
  double lowerLatitude() const;
  double upperLatitude() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Lambert - Destruct a Lambert.
INTERFACE:
Lambert::~Lambert()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Lambert - Construct a Lambert.
INPUTS:  double majorSemiaxis    Mean equitorial radius of spheroid in meters.
         double minorSemiaxis    Mean polar      radius of spheroid in meters.
         double centralLongitude Longitude that projects to 0.
         double centralLatitude  Latitude that projects to 0.
         double lowerLatitude    Latitude of lower secant.
         double upperLatitude    latitude of upper secant.
INTERFACE:
Lambert::Lambert( double majorSemiaxis, double minorSemiaxis,
                  double lowerLatitude, double upperLatitude )
PRE010( isSpheroid( majorSemiaxis, minorSemiaxis ),
        isLongitude( centralLongitude ),
        isLatitude( centralLatitude ),
        IN_RANGE( centralLatitude, -89.0, 89.0 ),
        isLatitude( lowerLatitude ),
        isLatitude( upperLatitude ),
        lowerLatitude <= upperLatitude,
        SIGN( lowerLatitude ) == SIGN( upperLatitude ),
        IMPLIES_ELSE( lowerLatitude >= 0.0,
                      IN_RANGE( lowerLatitude, 1.0, 89.0 ),
                      IN_RANGE( lowerLatitude, -89.0, -1.0 ) ),
        IMPLIES_ELSE( upperLatitude >= 0.0,
                      IN_RANGE( upperLatitude, 1.0, 89.0 ),
                      IN_RANGE( upperLatitude, -89.0, -1.0 ) ) )
POST7( ! strcmp( this->name(), "Lambert" ),
       this->majorSemiaxis() == majorSemiaxis,
       this->minorSemiaxis() == minorSemiaxis,
       this->centralLongitude() == centralLongitude,
       this->centralLatitude() == centralLatitude,
       this->lowerLatitude() == lowerLatitude,
       this->upperLatitude() == upperLatitude )

-------------------------------------------------------------------------------

PURPOSE: Lambert - Copy construct a Lambert.
INPUTS:  const Lambert& other  Other object to copy.
INTERFACE:
Lambert::Lambert( const Lambert& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a Lambert.
INPUTS:  const Lambert& other  Other object to copy.
RETURNS: Lambert& *this.
INTERFACE:
Lambert& Lambert::operator=( const Lambert& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: newCopy - Allocate, copy and return this.
NOTES:   Caller must delete returned result when no longer needed.
INTERFACE:
MapProjection* Lambert::newCopy() const
PRE( true )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool Lambert::invariant() const

-------------------------------------------------------------------------------

PURPOSE: name - Name of projection.
RETURNS: const char* "Lambert".
INTERFACE:
const char* Lambert::name() const
POST0( ! strcmp( result, "Lambert" ) )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const Lambert& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Lambert::operator==( const Lambert& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const Lambert& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool Lambert::operator!=( const Lambert& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: centralLongitude - Longitude that projects to 0.
RETURNS: double longitude that projects to 0.
INTERFACE:
double Lambert::centralLongitude() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: centralLatitude - Latitude that projects to 0.
RETURNS: double latitude that projects to 0.
INTERFACE:
double Lambert::centralLatitude() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: project - Project a point from longitude-latitude space to x-y space.
INPUTS:  double longitude  Longitude of point to project.
         double latitude   Latitude  of point to project.
OUTPUTS: double& x         X coordinate of projected longitude.
         double& y         Y coordinate of projected latitude.
INTERFACE:
void Lambert::project( double longitude, double latitude,
                       double& x, double& y ) const
PRE2( isLongitude( longitude ), isLatitude( latitude ) )
POST2( ! isNan( x ), ! isNan( y ) )

-------------------------------------------------------------------------------

PURPOSE: unproject - Unproject a point from x-y space to longitude-latitude.
INPUTS:  double x           X-coordinate of point to unproject.
         double y           X-coordinate of point to unproject.
OUTPUTS: double* longitude  Longitude of unprojected point X.
         double* latitude   Latitude  of unprojected point Y.
INTERFACE:
void Lambert::unproject( double x, double y,
                         double& longitude, double& latitude ) const
PRE2( isFinite( x ), isFinite( y ) )
POST2( isLongitude( longitude ), isLatitude( latitude ) )

-------------------------------------------------------------------------------

PURPOSE: lowerLatitude - Lower latitude of secant plane.
RETURNS: double result lower latitude of secant plane.
INTERFACE:
double Lambert::lowerLatitude() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: upperLatitude - Upper latitude of secant plane.
RETURNS: double result upper latitude of secant plane.
INTERFACE:
double Lambert::upperLatitude() const
PRE( true )
POST2( isLatitude( result ), result >= lowerLatitude() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Mercator.h - Declare Mercator MapProjection ADT.

TYPES:

namespace emvl {
  
class Mercator : public MapProjection {
public:

  // Commands:

  virtual ~Mercator();
  Mercator( double majorSemiaxis, double minorSemiaxis,
            double centralLongitude );
  Mercator( const Mercator& other );
  Mercator& operator=( const Mercator& other );

  // Queries:

  virtual MapProjection* newCopy() const;
  virtual bool invariant() const;
  virtual const char* name() const;
  bool operator==( const Mercator& other ) const;
  bool operator!=( const Mercator& other ) const;
  virtual double centralLongitude() const;
  virtual double centralLatitude() const;
  virtual void project( double longitude, double latitude,
                        double& x, double& y ) const;
  virtual void unproject( double x, double y,
                          double& longitude, double& latitude ) const;
  double lowerLatitude() const;
  double upperLatitude() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Mercator - Destruct a Mercator.
INTERFACE:
Mercator::~Mercator()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Mercator - Construct a Mercator.
INPUTS:  double majorSemiaxis    Mean equitorial radius of spheroid in meters.
         double minorSemiaxis    Mean polar      radius of spheroid in meters.
         double centralLongitude Longitude that projects to 0.
INTERFACE:
Mercator::Mercator( double majorSemiaxis, double minorSemiaxis,
                    double centralLongitude )
PRE02( isSpheroid( majorSemiaxis, minorSemiaxis ),
       isLongitude( centralLongitude ) )
POST5( ! strcmp( this->name(), "Mercator" ),
       this->majorSemiaxis() == majorSemiaxis,
       this->minorSemiaxis() == minorSemiaxis,
       this->centralLongitude() == centralLongitude,
       this->centralLatitude() == 0.0 )

-------------------------------------------------------------------------------

PURPOSE: Mercator - Copy construct a Mercator.
INPUTS:  const Mercator& other  Other object to copy.
INTERFACE:
Mercator::Mercator( const Mercator& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a Mercator.
INPUTS:  const Mercator& other  Other object to copy.
RETURNS: Mercator& *this.
INTERFACE:
Mercator& Mercator::operator=( const Mercator& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: newCopy - Allocate, copy and return this.
NOTES:   Caller must delete returned result when no longer needed.
INTERFACE:
MapProjection* Mercator::newCopy() const
PRE( true )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool Mercator::invariant() const

-------------------------------------------------------------------------------

PURPOSE: name - Name of projection.
RETURNS: const char* "Mercator".
INTERFACE:
const char* Mercator::name() const
POST0( ! strcmp( result, "Mercator" ) )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const Mercator& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Mercator::operator==( const Mercator& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const Mercator& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool Mercator::operator!=( const Mercator& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: centralLongitude - Longitude that projects to 0.
RETURNS: double longitude that projects to 0.
INTERFACE:
double Mercator::centralLongitude() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: centralLatitude - Latitude that projects to 0.
RETURNS: double 0.0.
INTERFACE:
double Mercator::centralLatitude() const
PRE( true )
POST( result == 0.0 )

-------------------------------------------------------------------------------

PURPOSE: project - Project a point from longitude-latitude space to x-y space.
INPUTS:  double longitude  Longitude of point to project.
         double latitude   Latitude  of point to project.
OUTPUTS: double& x         X coordinate of projected longitude.
         double& y         Y coordinate of projected latitude.
INTERFACE:
void Mercator::project( double longitude, double latitude,
                        double& x, double& y ) const
PRE2( isLongitude( longitude ), isLatitude( latitude ) )
POST2( IN_RANGE( x, -M_PI * majorSemiaxis(), M_PI * majorSemiaxis() ),
       IN_RANGE( y, -6.0 * M_PI * majorSemiaxis(),
                     6.0 * M_PI * majorSemiaxis() ) )

-------------------------------------------------------------------------------

PURPOSE: unproject - Unproject a point from x-y space to longitude-latitude.
INPUTS:  double x           X-coordinate of point to unproject.
         double y           X-coordinate of point to unproject.
OUTPUTS: double* longitude  Longitude of unprojected point X.
         double* latitude   Latitude  of unprojected point Y.
INTERFACE:
void Mercator::unproject( double x, double y,
                          double& longitude, double& latitude ) const
PRE2( IN_RANGE( x, -M_PI * majorSemiaxis(),
                    M_PI * majorSemiaxis() ),
      IN_RANGE( y, -6.0 * M_PI * majorSemiaxis(),
                    6.0 * M_PI * majorSemiaxis() ) )
POST2( isLongitude( longitude ), isLatitude( latitude ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Stereographic.h - Declare Stereographic MapProjection ADT.

TYPES:

namespace emvl {
  
class Stereographic : public MapProjection {
public:

  // Commands:

  virtual ~Stereographic();
  Stereographic( double majorSemiaxis, double minorSemiaxis,
                 double centralLongitude, double centralLatitude,
                 double secantLatitude );
  Stereographic( const Stereographic& other );
  Stereographic& operator=( const Stereographic& other );

  // Queries:

  virtual MapProjection* newCopy() const;
  virtual bool invariant() const;
  virtual const char* name() const;
  bool operator==( const Stereographic& other ) const;
  bool operator!=( const Stereographic& other ) const;
  virtual double centralLongitude() const;
  virtual double centralLatitude() const;
  virtual void project( double longitude, double latitude,
                        double& x, double& y ) const;
  virtual void unproject( double x, double y,
                          double& longitude, double& latitude ) const;
  double secantLatitude() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~Stereographic - Destruct a Stereographic.
INTERFACE:
Stereographic::~Stereographic()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: Stereographic - Construct a Stereographic.
INPUTS:  double majorSemiaxis    Mean equitorial radius of spheroid in meters.
         double minorSemiaxis    Mean polar      radius of spheroid in meters.
         double centralLongitude Longitude that projects to 0.
         double centralLatitude  Latitude that projects to 0.
         double secantLatitude   Latitude where plane intersects the spheroid.
INTERFACE:
Stereographic::Stereographic( double majorSemiaxis, double minorSemiaxis,
                              double secantLatitude )
PRE04( isSpheroid( majorSemiaxis, minorSemiaxis ),
       isLongitude( centralLongitude ),
       isLatitude( centralLatitude ),
       isLatitude( secantLatitude ) )
POST6( ! strcmp( this->name(), "Stereographic" ),
       this->majorSemiaxis() == majorSemiaxis,
       this->minorSemiaxis() == minorSemiaxis,
       this->centralLongitude() == centralLongitude,
       this->centralLatitude() == centralLatitude,
       this->secantLatitude() == secantLatitude )

-------------------------------------------------------------------------------

PURPOSE: Stereographic - Copy construct a Stereographic.
INPUTS:  const Stereographic& other  Other object to copy.
INTERFACE:
Stereographic::Stereographic( const Stereographic& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a Stereographic.
INPUTS:  const Stereographic& other  Other object to copy.
RETURNS: Stereographic& *this.
INTERFACE:
Stereographic& Stereographic::operator=( const Stereographic& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: newCopy - Allocate, copy and return this.
NOTES:   Caller must delete returned result when no longer needed.
INTERFACE:
MapProjection* Stereographic::newCopy() const
PRE( true )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool Stereographic::invariant() const

-------------------------------------------------------------------------------

PURPOSE: name - Name of projection.
RETURNS: const char* "Stereographic".
INTERFACE:
const char* Stereographic::name() const
POST0( ! strcmp( result, "Stereographic" ) )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const Stereographic& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool Stereographic::operator==( const Stereographic& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const Stereographic& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool Stereographic::operator!=( const Stereographic& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: centralLongitude - Longitude that projects to 0.
RETURNS: double longitude that projects to 0.
INTERFACE:
double Stereographic::centralLongitude() const
PRE( true )
POST( isLongitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: centralLatitude - Latitude that projects to 0.
RETURNS: double latitude that projects to 0.
INTERFACE:
double Stereographic::centralLatitude() const
PRE( true )
POST( isLatitude( result ) )

-------------------------------------------------------------------------------

PURPOSE: project - Project a point from longitude-latitude space to x-y space.
INPUTS:  double longitude  Longitude of point to project.
         double latitude   Latitude  of point to project.
OUTPUTS: double& x         X coordinate of projected longitude.
         double& y         Y coordinate of projected latitude.
INTERFACE:
void Stereographic::project( double longitude, double latitude,
                             double& x, double& y ) const
PRE2( isLongitude( longitude ), isLatitude( latitude ) )
POST2( ! isNan( x ), ! isNan( y ) )

-------------------------------------------------------------------------------

PURPOSE: unproject - Unproject a point from x-y space to longitude-latitude.
INPUTS:  double x           X-coordinate of point to unproject.
         double y           X-coordinate of point to unproject.
OUTPUTS: double* longitude  Longitude of unprojected point X.
         double* latitude   Latitude  of unprojected point Y.
INTERFACE:
void Stereographic::unproject( double x, double y,
                               double& longitude, double& latitude ) const
PRE2( isFinite( x ), isFinite( y ) )
POST2( isLongitude( longitude ), isLatitude( latitude ) )

-------------------------------------------------------------------------------

PURPOSE: secantLatitude - Lower latitude of secant plane.
RETURNS: double result lower latitude of secant plane.
INTERFACE:
double Stereographic::secantLatitude() const
PRE( true )
POST( isLatitude( result ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: DataFilterParameters.h - Remote web service query parameters used to
         filter data when constructing Datasets.

TYPES:

namespace emvl {

class DataFilterParameters {

public:

  // Commands:

  ~DataFilterParameters();
  DataFilterParameters();
  DataFilterParameters( const double CALIPSOMinimumAcceptedCADScore,
                        const double CALIPSOMaximumAcceptedUncertainty,
                        const double GASPAODMinimum,
                        const double GASPAODMaximum,
                        const double GASPSTDMinimum,
                        const double GASPSTDMaximum,
                        const double GASPCLSMinimum,
                        const double GASPCLSMaximum,
                        const double GASPCH1Minimum,
                        const double GASPCH1Maximum,
                        const double GASPSIGMinimum,
                        const double GASPSIGMaximum,
                        const double GASPSFCMinimum,
                        const double GASPSFCMaximum,
                        const double GASPMOSMinimum,
                        const double GASPMOSMaximum,
                        const double GASPSCAMinimum,
                        const double GASPSCAMaximum,
                        const int TROPOMIMinimumAcceptedQuality );
  DataFilterParameters( const DataFilterParameters& other );
  DataFilterParameters& operator=( const DataFilterParameters& other );
  void CALIPSOMinimumAcceptedCADScore( double value );
  void CALIPSOMaximumAcceptedUncertainty( const double value );
  void GASPAODRange( const double minimum, const double maximum );
  void GASPSTDRange( const double minimum, const double maximum );
  void GASPCLSRange( const double minimum, const double maximum );
  void GASPCH1Range( const double minimum, const double maximum );
  void GASPSIGRange( const double minimum, const double maximum );
  void GASPSFCRange( const double minimum, const double maximum );
  void GASPMOSRange( const double minimum, const double maximum );
  void GASPSCARange( const double minimum, const double maximum );
  void TROPOMIMinimumAcceptedQuality( const int value );

  // Queries:

  bool operator==( const DataFilterParameters& other ) const;
  bool operator!=( const DataFilterParameters& other ) const;
  bool invariant() const;
  double CALIPSOMinimumAcceptedCADScore() const;
  double CALIPSOMaximumAcceptedUncertainty() const;
  double GASPAODMinimum() const;
  double GASPAODMaximum() const;
  double GASPSTDMinimum() const;
  double GASPSTDMaximum() const;
  double GASPCLSMinimum() const;
  double GASPCLSMaximum() const;
  double GASPCH1Minimum() const;
  double GASPCH1Maximum() const;
  double GASPSIGMinimum() const;
  double GASPSIGMaximum() const;
  double GASPSFCMinimum() const;
  double GASPSFCMaximum() const;
  double GASPMOSMinimum() const;
  double GASPMOSMaximum() const;
  double GASPSCAMinimum() const;
  double GASPSCAMaximum() const;
  int TROPOMIMinimumAcceptedQuality() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~DataFilterParameters - Destructor.
INTERFACE:
DataFilterParameters::~DataFilterParameters()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: DataFilterParameters - Default contructor.
INTERFACE:
DataFilterParameters::DataFilterParameters()
POST19( CALIPSOMinimumAcceptedCADScore() == 20.0,
        CALIPSOMaximumAcceptedUncertainty() == 99.0,
        GASPAODMinimum() == -0.5,
        GASPAODMaximum() == 2.05,
        GASPSTDMinimum() == 0.0,
        GASPSTDMaximum() == 2.55,
        GASPCLSMinimum() == 0.0,
        GASPCLSMaximum() == 25.0,
        GASPCH1Minimum() == 0.0,
        GASPCH1Maximum() == 0.425,
        GASPSIGMinimum() == -0.5,
        GASPSIGMaximum() == 0.52,
        GASPSFCMinimum() == -0.1,
        GASPSFCMaximum() == 0.41,
        GASPMOSMinimum() == 0.0,
        GASPMOSMaximum() == 0.425,
        GASPSCAMinimum() == 0.0,
        GASPSCAMaximum() == 255.0,
        TROPOMIMinimumAcceptedQuality() == 100 )

-------------------------------------------------------------------------------

PURPOSE: DataFilterParameters - Contructor.
INPUTS:  const double CALIPSOMinimumAcceptedCADScore  [20, 100].
         const double CALIPSOMaximumAcceptedUncertainty  [0, 100].
         const double GASPAODMinimum -0.5
         const double GASPAODMaximum 2.05
         const double GASPSTDMinimum 0
         const double GASPSTDMaximum 2.55
         const double GASPCLSMinimum 0
         const double GASPCLSMaximum 25
         const double GASPCH1Minimum 0
         const double GASPCH1Maximum 0.425
         const double GASPSIGMinimum -0.5
         const double GASPSIGMaximum 0.52
         const double GASPSFCMinimum -0.1
         const double GASPSFCMaximum 0.41
         const double GASPMOSMinimum 0
         const double GASPMOSMaximum 0.425
         const double GASPSCAMinimum 0
         const double GASPSCAMaximum 255
         const int TROPOMIMinimumAcceptedQuality [50, 100].
INTERFACE:
DataFilterParameters::DataFilterParameters(
  const int TROPOMIMinimumAcceptedQuality )
PRE019( IN_RANGE( CALIPSOMinimumAcceptedCADScore, 20.0, 100.0 ),
        IN_RANGE( CALIPSOMaximumAcceptedUncertainty, 0.0, 100.0 ),
        IN_RANGE( GASPAODMinimum, -0.5, 2.05 ),
        IN_RANGE( GASPAODMaximum, GASPAODMinimum, 2.05 ),
        IN_RANGE( GASPSTDMinimum, 0.0, 2.55 ),
        IN_RANGE( GASPSTDMaximum, GASPSTDMinimum, 2.55 ),
        IN_RANGE( GASPCLSMinimum, 0.0, 25.0 ),
        IN_RANGE( GASPCLSMaximum, GASPCLSMinimum, 25.0 ),
        IN_RANGE( GASPCH1Minimum, 0.0, 0.425 ),
        IN_RANGE( GASPCH1Maximum, GASPCH1Minimum, 0.425 ),
        IN_RANGE( GASPSIGMinimum, -0.5, 0.52 ),
        IN_RANGE( GASPSIGMaximum, GASPSIGMinimum, 0.52 ),
        IN_RANGE( GASPSFCMinimum, -0.1, 0.41 ),
        IN_RANGE( GASPSFCMaximum, GASPSFCMinimum, 0.41 ),
        IN_RANGE( GASPMOSMinimum, 0.0, 0.425 ),
        IN_RANGE( GASPMOSMaximum, GASPMOSMinimum, 0.425 ),
        IN_RANGE( GASPMOSMinimum, 0.0, 255.0 ),
        IN_RANGE( GASPMOSMaximum, GASPMOSMinimum, 255.0 ),
        IN_RANGE( TROPOMIMinimumAcceptedQuality, 50, 100 ) )
POST19( this->CALIPSOMinimumAcceptedCADScore() ==
         CALIPSOMinimumAcceptedCADScore,
        this->CALIPSOMaximumAcceptedUncertainty() ==
           CALIPSOMaximumAcceptedUncertainty,
        this->GASPAODMinimum() == GASPAODMinimum,
        this->GASPAODMaximum() == GASPAODMaximum,
        this->GASPSTDMinimum() == GASPSTDMinimum,
        this->GASPSTDMaximum() == GASPSTDMaximum,
        this->GASPCLSMinimum() == GASPCLSMinimum,
        this->GASPCLSMaximum() == GASPCLSMaximum,
        this->GASPCH1Minimum() == GASPCH1Minimum,
        this->GASPCH1Maximum() == GASPCH1Maximum,
        this->GASPSIGMinimum() == GASPSIGMinimum,
        this->GASPSIGMaximum() == GASPSIGMaximum,
        this->GASPSFCMinimum() == GASPSFCMinimum,
        this->GASPSFCMaximum() == GASPSFCMaximum,
        this->GASPMOSMinimum() == GASPMOSMinimum,
        this->GASPMOSMaximum() == GASPMOSMaximum,
        this->GASPSCAMinimum() == GASPSCAMinimum,
        this->GASPSCAMaximum() == GASPSCAMaximum,
        this->TROPOMIMinimumAcceptedQuality_ ==
          TROPOMIMinimumAcceptedQuality )

-------------------------------------------------------------------------------

PURPOSE: DataFilterParameters - Copy construct a timestamp.
INPUTS:  const DataFilterParameters& other  Object to copy.
INTERFACE:
DataFilterParameters::DataFilterParameters(const DataFilterParameters& other)
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Copy a timestamp.
INPUTS:  const DataFilterParameters& other  Object to copy.
INTERFACE:
DataFilterParameters& DataFilterParameters::operator=(
  const DataFilterParameters& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: CALIPSOMinimumAcceptedCADScore - Set named attribute to value.
INPUTS:  const double value  Value to set named attribute to.
INTERFACE:
void DataFilterParameters::CALIPSOMinimumAcceptedCADScore(const double value)
PRE( IN_RANGE( value, 20.0, 100.0 ) )
POST( CALIPSOMinimumAcceptedCADScore() == value )

-------------------------------------------------------------------------------

PURPOSE: CALIPSOMaximumAcceptedUncertainty - Set named attribute to value.
INPUTS:  const double value  Value to set named attribute to.
INTERFACE:
void DataFilterParameters::CALIPSOMaximumAcceptedUncertainty(
  const double value )
PRE( IN_RANGE( value, 0.0, 100.0 ) )
POST( CALIPSOMaximumAcceptedUncertainty() == value )

-------------------------------------------------------------------------------

PURPOSE: GASPAODRange - Set minimum and maximum AOD values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPAODRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, -0.5, 2.05 ),
      IN_RANGE( maximum, minimum, 2.05 ) )
POST2( GASPAODMinimum() == minimum, GASPAODMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPSTDRange - Set minimum and maximum STD values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPSTDRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, 0.0, 2.55 ),
      IN_RANGE( maximum, minimum, 2.55 ) )
POST2( GASPSTDMinimum() == minimum, GASPSTDMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPCLSRange - Set minimum and maximum CLS values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPCLSRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, 0.0, 25.0 ),
      IN_RANGE( maximum, minimum, 25.0 ) )
POST2( GASPCLSMinimum() == minimum, GASPCLSMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPCH1Range - Set minimum and maximum CH1 values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPCH1Range( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, 0.0, 0.425 ),
      IN_RANGE( maximum, minimum, 0.425 ) )
POST2( GASPCH1Minimum() == minimum, GASPCH1Maximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPSIGRange - Set minimum and maximum SIG values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPSIGRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, -0.5, 0.52 ),
      IN_RANGE( maximum, minimum, 0.52 ) )
POST2( GASPSIGMinimum() == minimum, GASPSIGMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPSFCRange - Set minimum and maximum SFC values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPSFCRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, -0.1, 0.41 ),
      IN_RANGE( maximum, minimum, 0.41 ) )
POST2( GASPSFCMinimum() == minimum, GASPSFCMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPMOSRange - Set minimum and maximum MOS values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPMOSRange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, 0.0, 0.425 ),
      IN_RANGE( maximum, minimum, 0.425 ) )
POST2( GASPMOSMinimum() == minimum, GASPMOSMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: GASPSCARange - Set minimum and maximum SCA values.
INPUTS:  const double minimum  Minimum value.
INPUTS:  const double maximum  Maximum value.
INTERFACE:
void DataFilterParameters::GASPSCARange( const double minimum,
                                         const double maximum )
PRE2( IN_RANGE( minimum, 0.0, 255.0 ),
      IN_RANGE( maximum, minimum, 255.0 ) )
POST2( GASPSCAMinimum() == minimum, GASPSCAMaximum() == maximum )

-------------------------------------------------------------------------------

PURPOSE: TROPOMIMinimumAcceptedQuality - Set named attribute to value.
INPUTS:  const int value  Value to set named attribute to.
INTERFACE:
void DataFilterParameters::TROPOMIMinimumAcceptedQuality( const int value )
PRE( IN_RANGE( value, 50, 100 ) )
POST( TROPOMIMinimumAcceptedQuality() == value )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const DataFilterParameters& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool DataFilterParameters::operator==( const DataFilterParameters& other )
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const DataFilterParameters& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool DataFilterParameters::operator!=( const DataFilterParameters& other )
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true otherwise the code is defective.
INTERFACE:
bool DataFilterParameters::invariant() const

-------------------------------------------------------------------------------

PURPOSE: CALIPSOMinimumAcceptedCADScore - Returns value of named attribute.
RETURNS: double CALIPSOMinimumAcceptedCADScore.
INTERFACE:
double DataFilterParameters::CALIPSOMinimumAcceptedCADScore() const
PRE( true )
POST( IN_RANGE( result, 20.0, 100.0 ) )

-------------------------------------------------------------------------------

PURPOSE: CALIPSOMaximumAcceptedUncertainty - Returns value of named attribute.
RETURNS: double CALIPSOMaximumAcceptedUncertainty.
INTERFACE:
double DataFilterParameters::CALIPSOMaximumAcceptedUncertainty() const
PRE( true )
POST( IN_RANGE( result, 0.0, 100.0 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPAODMinimum - Returns value of named attribute.
RETURNS: double GASPAODMinimum.
INTERFACE:
double DataFilterParameters::GASPAODMinimum() const
PRE( true )
POST( IN_RANGE( result, -0.5, 2.05 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPAODMaximum - Returns value of named attribute.
RETURNS: double GASPAODMaximum.
INTERFACE:
double DataFilterParameters::GASPAODMaximum() const
PRE( true )
POST( IN_RANGE( result, -0.5, 2.05 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSTDMinimum - Returns value of named attribute.
RETURNS: double GASPSTDMinimum.
INTERFACE:
double DataFilterParameters::GASPSTDMinimum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 2.55 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSTDMaximum - Returns value of named attribute.
RETURNS: double GASPSTDMaximum.
INTERFACE:
double DataFilterParameters::GASPSTDMaximum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 2.55 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPCLSMinimum - Returns value of named attribute.
RETURNS: double GASPCLSMinimum.
INTERFACE:
double DataFilterParameters::GASPCLSMinimum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 25.0 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPCLSMaximum - Returns value of named attribute.
RETURNS: double GASPCLSMaximum.
INTERFACE:
double DataFilterParameters::GASPCLSMaximum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 25.0 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPCH1Minimum - Returns value of named attribute.
RETURNS: double GASPCH1Minimum.
INTERFACE:
double DataFilterParameters::GASPCH1Minimum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 0.425 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPCH1Maximum - Returns value of named attribute.
RETURNS: double GASPCH1Maximum.
INTERFACE:
double DataFilterParameters::GASPCH1Maximum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 0.425 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSIGMinimum - Returns value of named attribute.
RETURNS: double GASPSIGMinimum.
INTERFACE:
double DataFilterParameters::GASPSIGMinimum() const
PRE( true )
POST( IN_RANGE( result, -0.5, 0.52 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSIGMaximum - Returns value of named attribute.
RETURNS: double GASPSIGMaximum.
INTERFACE:
double DataFilterParameters::GASPSIGMaximum() const
PRE( true )
POST( IN_RANGE( result, -0.5, 0.52 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSFCMinimum - Returns value of named attribute.
RETURNS: double GASPSFCMinimum.
INTERFACE:
double DataFilterParameters::GASPSFCMinimum() const
PRE( true )
POST( IN_RANGE( result, -0.1, 0.41 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSFCMaximum - Returns value of named attribute.
RETURNS: double GASPSFCMaximum.
INTERFACE:
double DataFilterParameters::GASPSFCMaximum() const
PRE( true )
POST( IN_RANGE( result, -0.1, 0.41 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPMOSMinimum - Returns value of named attribute.
RETURNS: double GASPMOSMinimum.
INTERFACE:
double DataFilterParameters::GASPMOSMinimum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 0.425 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPMOSMaximum - Returns value of named attribute.
RETURNS: double GASPMOSMaximum.
INTERFACE:
double DataFilterParameters::GASPMOSMaximum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 0.425 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSCAMinimum - Returns value of named attribute.
RETURNS: double GASPSCAMinimum.
INTERFACE:
double DataFilterParameters::GASPSCAMinimum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 255.0 ) )

-------------------------------------------------------------------------------

PURPOSE: GASPSCAMaximum - Returns value of named attribute.
RETURNS: double GASPSCAMaximum.
INTERFACE:
double DataFilterParameters::GASPSCAMaximum() const
PRE( true )
POST( IN_RANGE( result, 0.0, 255.0 ) )

-------------------------------------------------------------------------------

PURPOSE: TROPOMIMinimumAcceptedQuality - Returns value of named attribute.
RETURNS: int TROPOMIMinimumAcceptedQuality.
INTERFACE:
int DataFilterParameters::TROPOMIMinimumAcceptedQuality() const
PRE( true )
POST( IN_RANGE( result, 50, 100 ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: CMAQGridParameters.h - CMAQ grid parameters used for regridding.

TYPES:

namespace emvl {

class CMAQGridParameters {
public:

  // Types:

  // GDTYP:

  enum { LATGRD3 = 1, LAMGRD3 = 2, POLGRD3 = 6, EQMGRD3 = 7, ALBGRD3 = 9 };
  
  enum { MXLAYS3 = 100 }; // NLAYS.
  
  // Vertical grid types:

  enum {
    IMISS3  = -9999, // None (becomes a single layer at 0.0).
    VGSGPH3 = 1,     // Hydrostatic sigma-P
    VGSGPN3,         // Non-h sigma-P
    VGSIGZ3,         // Sigma-Z
    VGPRES3,         // Pressure (pascals)
    VGZVAL3,         // Z (m) (above sea level)
    VGHVAL3,         // Z (m) (above terrain)
    VGWRFEM          // Sigma-P WRF.
  };

public:

  static bool isValidParameters(
    const int ncols,
    const int nrows,
    const int nlays,
    const int gdtyp,
    const double sphereRadius,
    const double p_alp,
    const double p_bet,
    const double p_gam,
    const double xcent,
    const double ycent,
    const double xorig,
    const double yorig,
    const double xcell,
    const double ycell,
    const int vgtyp, 
    const double vgtop,
    const double vglvls[],
    const double g,
    const double R,
    const double A,
    const double T0,
    const double P0
  );

  // Commands:

  ~CMAQGridParameters();
  CMAQGridParameters();
  CMAQGridParameters(
    const int ncols,
    const int nrows,
    const int nlays,
    const int gdtyp,
    const double sphereRadius,
    const double p_alp,
    const double p_bet,
    const double p_gam,
    const double xcent,
    const double ycent,
    const double xorig,
    const double yorig,
    const double xcell,
    const double ycell,
    const int vgtyp, 
    const double vgtop,
    const double vglvls[],
    const double g,
    const double R,
    const double A,
    const double T0,
    const double P0
  );
  CMAQGridParameters( const char* const fileName ); //x
  CMAQGridParameters( const CMAQGridParameters& other );
  CMAQGridParameters& operator=( const CMAQGridParameters& other );

  // Queries:

  bool operator==( const CMAQGridParameters& other ) const;
  bool operator!=( const CMAQGridParameters& other ) const;
  bool invariant() const;
  int ncols() const;
  int nrows() const;
  int nlays() const;
  int gdtyp() const;
  double sphereRadius() const;
  double p_alp() const;
  double p_bet() const;
  double p_gam() const;
  double xcent() const;
  double ycent() const;
  double xorig() const;
  double yorig() const;
  double xcell() const;
  double ycell() const;
  int vgtyp() const; 
  double vgtop() const;
  const double* vglvls() const;
  double g() const;
  double R() const;
  double A() const;
  double T0() const;
  double P0() const;

  double layerThickness( const int layer ) const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~CMAQGridParameters - Destructor.
INTERFACE:
CMAQGridParameters::~CMAQGridParameters()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: CMAQGridParameters - Default constructor.
INTERFACE:
CMAQGridParameters::CMAQGridParameters()
POST21( ncols() == 459,
        nrows() == 299,
        nlays() == 34,
        gdtyp() == 2,
        sphereRadius() == 6370000.0,
        p_alp() == 33.0,
        p_bet() == 45.0,
        p_gam() == -97.0,
        xcent() == -97.0,
        ycent() == 40.0,
        xorig() == -2556000.0,
        yorig() == -1728000.0,
        xcell() == 12000.0,
        ycell() == 12000.0,
        vgtop() == 5000.0,
        vgtyp() == VGSGPN3,
        g() == 9.81,
        R() == 287.04,
        A() == 50.0,
        T0() == 275.0,
        P0() == 100000.0 )

-------------------------------------------------------------------------------

PURPOSE: CMAQGridParameters - Contructor.
INPUTS: const int ncols     Number of CMAQ grid columns.
        const int nrows     Number of CMAQ grid rows.
        const int nlays     Number of CMAQ grid layers.
        const int gdtyp     Projection type (LATGRD3, LAMGRD3, etc.)
        const double sphereRadius  Radius (m) of Earth e.g., 6,370,000.
        const double p_alp  gdtyp-specific parameters.
        const double p_bet
        const double p_gam
        const double xcent  Longitude of center of projection.
        const double ycent  Latitude of center of projection.
        const double xorig  X-coordinate of south-west corner of grid.
        const double yorig  Y-coordinate of south-west corner of grid.
        const double xcell  West-East width of grid cell (m or deg iff LATGRD3)
        const double ycell  South-North height of a grid cell (m) (deg iff ").
        const double vgtop  Pressure (Pa) at top of model.
        const int vgtyp     Vertical grid type: VGSGPN3, etc.
        const double vglvls[ MXLAYS3 + 1 ]  Sigma-pressures at layer faces.
        const double g      Gravitational constant m/s2.
        const double R      J/kg/K.
        const double A      K.
        const double T0     K.
        const double P0    Pa.

INTERFACE:
CMAQGridParameters::CMAQGridParameters(
  const double P0 )
PRE0( isValidParameters( ncols, nrows, nlays,
                         gdtyp, sphereRadius,
                         p_alp, p_bet, p_gam,
                         xcent, ycent,
                         xorig, yorig,
                         xcell, ycell,
                         vgtyp, vgtop, vglvls,
                         g, R, A, T0, P0 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CMAQGridParameters - Construct from a file.
INPUTS:  const char* const fileName  Name of CMAQ file to read.
NOTES:   throws std::runtime_error if failed to read valid CMAQ file.
INTERFACE:
CMAQGridParameters::CMAQGridParameters( const char* const fileName )
PRE02( fileName, *fileName )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CMAQGridParameters - Copy construct a timestamp.
INPUTS:  const CMAQGridParameters& other  Object to copy.
INTERFACE:
CMAQGridParameters::CMAQGridParameters( const CMAQGridParameters& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Copy a timestamp.
INPUTS:  const CMAQGridParameters& other  Object to copy.
INTERFACE:
CMAQGridParameters& CMAQGridParameters::operator=(
  const CMAQGridParameters& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const CMAQGridParameters& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool CMAQGridParameters::operator==( const CMAQGridParameters& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const CMAQGridParameters& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool CMAQGridParameters::operator!=( const CMAQGridParameters& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true otherwise the code is defective.
INTERFACE:
bool CMAQGridParameters::invariant() const

-------------------------------------------------------------------------------

PURPOSE: ncols - Returns number of columns of grid cells.
RETURNS: int number of columns of grid cells.
INTERFACE:
int CMAQGridParameters::ncols() const
PRE( true )
POST( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: nrows - Returns number of rows of grid cells.
RETURNS: int number of rows of grid cells.
INTERFACE:
int CMAQGridParameters::nrows() const
PRE( true )
POST( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: nlays - Returns number of layers of grid cells.
RETURNS: int number of layers of grid cells.
INTERFACE:
int CMAQGridParameters::nlays() const
PRE( true )
POST( IN_RANGE( result, 0, MXLAYS3 ) )

-------------------------------------------------------------------------------

PURPOSE: gdtyp - Returns projection of grid.
RETURNS: int projection of grid.
INTERFACE:
int CMAQGridParameters::gdtyp() const
PRE( true )
POST( IN6( result, LATGRD3, LAMGRD3, POLGRD3, EQMGRD3, ALBGRD3 ) )

-------------------------------------------------------------------------------

PURPOSE: sphereRadius - Returns mean radius of Earth approximation, in meters.
RETURNS: double mean radius of Earth approximation, in meters.
INTERFACE:
double CMAQGridParameters::sphereRadius() const
PRE( true )
POST( IN_RANGE( result, 1.0, 1e8 ) )

-------------------------------------------------------------------------------

PURPOSE: p_alp - Returns p_alp projection parameter.
RETURNS: double p_alp projection parameter.
INTERFACE:
double CMAQGridParameters::p_alp() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3, result == 0.0,
                    isLatitude( result ) ) )

-------------------------------------------------------------------------------

PURPOSE: p_bet - Returns p_bet projection parameter.
RETURNS: double p_bet projection parameter.
INTERFACE:
double CMAQGridParameters::p_bet() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3, result == 0.0,
                    isLatitude( result ) ) )

-------------------------------------------------------------------------------

PURPOSE: p_gam - Returns p_gam projection parameter.
RETURNS: double p_gam projection parameter.
INTERFACE:
double CMAQGridParameters::p_gam() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3, result == 0.0,
                    isLongitude( result ) ) )

-------------------------------------------------------------------------------

PURPOSE: xcent - Returns xcent projection parameter.
RETURNS: double X-coordinate of projection origin.
INTERFACE:
double CMAQGridParameters::xcent() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3, result == 0.0, isLongitude(result)))

-------------------------------------------------------------------------------

PURPOSE: ycent - Returns ycent projection parameter.
RETURNS: double Y-coordinate of projection origin.
INTERFACE:
double CMAQGridParameters::ycent() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3, result == 0.0, isLatitude( result)))

-------------------------------------------------------------------------------

PURPOSE: xorig - Returns xorig projection parameter.
RETURNS: double X-coordinate of lower-left corner of grid.
INTERFACE:
double CMAQGridParameters::xorig() const
PRE( true )
POST( IN_RANGE( result, -1e15, 1e15 ) )

-------------------------------------------------------------------------------

PURPOSE: yorig - Returns yorig projection parameter.
RETURNS: double Y-coordinate of lower-left corner of grid.
INTERFACE:
double CMAQGridParameters::yorig() const
PRE( true )
POST( IN_RANGE( result, -1e15, 1e15 ) )

-------------------------------------------------------------------------------

PURPOSE: xcell - Returns grid cell width.
RETURNS: double grid cell width in meters or degrees iff gdtyp() is LATGRD3.
INTERFACE:
double CMAQGridParameters::xcell() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3,
                    IN_RANGE( result, 0.01, 10.0 ),
                    IN_RANGE( result, 1.0, 1e6 ) ) )

-------------------------------------------------------------------------------

PURPOSE: ycell - Returns grid cell height.
RETURNS: double grid cell height in meters or degrees iff gdtyp() is LATGRD3.
INTERFACE:
double CMAQGridParameters::ycell() const
PRE( true )
POST( IMPLIES_ELSE( gdtyp() == LATGRD3,
                    IN_RANGE( result, 0.01, 10.0 ),
                    IN_RANGE( result, 1.0, 1e6 ) ) )

-------------------------------------------------------------------------------

PURPOSE: vgtyp - Returns grid cell height.
RETURNS: int grid cell height in meters or degrees iff gdtyp() is LATGRD3.
INTERFACE:
int CMAQGridParameters::vgtyp() const
PRE( true )
POST( IN9( result,
           IMISS3,
           VGSGPH3, VGSGPN3, VGSIGZ3, VGPRES3, VGZVAL3, VGHVAL3, VGWRFEM ) )

-------------------------------------------------------------------------------

PURPOSE: vgtop - Returns pressure (Pa) at top of model.
RETURNS: double pressure (Pa) at top of model.
INTERFACE:
double CMAQGridParameters::vgtop() const
PRE( true )
POST( IN_RANGE( result, 1.0, 1e5 ) )

-------------------------------------------------------------------------------

PURPOSE: vglvls - Returns vertical level coordinates.
RETURNS: const double* vertical level coordinates (nlays + 1 of them).
INTERFACE:
const double* CMAQGridParameters::vglvls() const
PRE( true )
POST( isNanFree( result, nlays() + 1 ) )

-------------------------------------------------------------------------------

PURPOSE: g - Returns gravitational constant.
RETURNS: double g (m/s2).
INTERFACE:
double CMAQGridParameters::g() const
PRE( true )
POST( IN_RANGE( result, 1.0, 100.0 ) )

-------------------------------------------------------------------------------

PURPOSE: R - Returns R constant.
RETURNS: double (J/kg/K).
INTERFACE:
double CMAQGridParameters::R() const
PRE( true )
POST( IN_RANGE( result, 200.0, 400.0 ) )

-------------------------------------------------------------------------------

PURPOSE: A - Returns A constant.
RETURNS: double (K).
INTERFACE:
double CMAQGridParameters::A() const
PRE( true )
POST( IN_RANGE( result, 10.0, 100.0 ) )

-------------------------------------------------------------------------------

PURPOSE: T0 - Returns T0 constant.
RETURNS: double (K).
INTERFACE:
double CMAQGridParameters::T0() const
PRE( true )
POST( IN_RANGE( result, 250.0, 350.0 ) )

-------------------------------------------------------------------------------

PURPOSE: P0 - Returns P0 constant.
RETURNS: double (Pa).
INTERFACE:
double CMAQGridParameters::P0() const
PRE( true )
POST( IN_RANGE( result, 1000.0, 1e6 ) )

-------------------------------------------------------------------------------

PURPOSE: layerThickness - Returns thickness in meters of a given layer.
INPUTS:  const int layer  0-based index of layer.
RETURNS: double meters.
INTERFACE:
double CMAQGridParameters::layerThickness( const int layer ) const
PRE( IN_RANGE( layer, 0, nlays_ - 1 ) )
POST( IN_RANGE( result, 0.0, 1e5 ) )

-------------------------------------------------------------------------------

PURPOSE: isValidParameters - Are the parameters valid?
INPUTS: const int ncols     Number of CMAQ grid columns.
        const int nrows     Number of CMAQ grid rows.
        const int nlays     Number of CMAQ grid layers.
        const int gdtyp     Projection type (LATGRD3, LAMGRD3, etc.)
        const double sphereRadius  Radius (m) of Earth e.g., 6,370,000.
        const double p_alp  gdtyp-specific parameters.
        const double p_bet
        const double p_gam
        const double xcent  Longitude of center of projection.
        const double ycent  Latitude of center of projection.
        const double xorig  X-coordinate of south-west corner of grid.
        const double yorig  Y-coordinate of south-west corner of grid.
        const double xcell  West-East width of grid cell (m or deg iff LATGRD3)
        const double ycell  South-North height of a grid cell (m) (deg iff ").
        const double vgtop  Pressure (Pa) at top of model.
        const int vgtyp     Vertical grid type: VGSGPN3, etc.
        const double vglvls[ MXLAYS3 + 1 ]  Sigma-pressures at layer faces.
        const double g      Gravitational constant m/s2.
        const double R      J/kg/K.
        const double A      K.
        const double T0     K.
        const double P0     Pa.
RETURNS: bool true if valid, else false.
INTERFACE:
bool CMAQGridParameters::isValidParameters(
  const double P0 )

-------------------------------------------------------------------------------

PURPOSE: computeThicknesses - Compute thickness in meters of each layer.
INTERFACE:
void CMAQGridParameters::computeThicknesses()



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: QueryParameters.h - Remote web service query parameters used to
         construct Datasets.

TYPES:

namespace emvl {

bool isElevation( const double elevation );

class QueryParameters {

public:

  // Constants:

  static const double MINIMUM_ELEVATION;
  static const double MAXIMUM_ELEVATION;

  enum { XDR, ASCII, NETCDF_COARDS, NETCDF_IOAPI, SHAPEFILE, KML, FILE_FORMATS};

  enum {
    REGRID_NONE, REGRID_NEAREST, REGRID_MEAN, REGRID_WEIGHTED, REGRID_METHODS
  };

  enum {
    AGGREGATE_NONE, AGGREGATE_DAILY_MEAN, AGGREGATE_DAILY_MAX,
    AGGREGATE_DAILY_MAX8, AGGREGATE_METHODS
  };

  static const char* const fileFormatNames[ FILE_FORMATS ];
  static const char* const fileFormatExtensions[ FILE_FORMATS ];
  static const char* const aggregateMethodNames[ AGGREGATE_METHODS ];
  static const char* const regridMethodNames[ REGRID_METHODS ];

  // Commands:

  ~QueryParameters();
  QueryParameters();

  QueryParameters( const Timestamp startingTimestamp,
                   const Timestamp endingTimestamp,
                   const Bounds& bounds,
                   const double boundsZ[ 2 ],
                   const std::string& variables,
                   const int format,
                   const std::string& directory,
                   const bool compress,
                   const bool integrateCMAQLayers,
                   const DataFilterParameters& dataFilterParameters,
                   const int aggregateMethod,
                   const int regridMethod,
                   const CMAQGridParameters& cmaqGridParameters );

  QueryParameters( const QueryParameters& other );
  QueryParameters& operator=( const QueryParameters& other );

  void timestamps( const Timestamp startingTimestamp,
                   const Timestamp endingTimestamp );

  void bounds( const Bounds& bounds );
  void boundsZ( const double boundsZ[ 2 ] );
  void variables( const std::string& variables );
  void format( const int format );
  void directory( const std::string& directory );
  void compress( const bool compress );
  void integrateCMAQLayers( const bool integrate );
  void dataFilterParameters( const DataFilterParameters& dataFilterParameters);
  void aggregateMethod( const int aggregateMethod );
  void regridMethod( const int regridMethod );
  void cmaqGridParameters( const CMAQGridParameters& cmaqGridParameters );

  // Queries:

  bool operator==( const QueryParameters& other ) const;
  bool operator!=( const QueryParameters& other ) const;
  bool invariant() const;
  Timestamp startingTimestamp() const;
  Timestamp endingTimestamp() const;
  const Bounds& bounds() const;
  double boundsZMinimum() const;
  double boundsZMaximum() const;
  const std::string& variables() const;
  int format() const;
  const std::string& directory() const;
  bool compress() const;
  bool integrateCMAQLayers() const;
  const DataFilterParameters& dataFilterParameters() const;
  int aggregateMethod() const;
  int regridMethod() const;
  const CMAQGridParameters& cmaqGridParameters() const;
  std::string pathedFileName() const;
};


} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~QueryParameters - Destructor.
INTERFACE:
QueryParameters::~QueryParameters()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: QueryParameters - Default constructor.
INTERFACE:
QueryParameters::QueryParameters()
POST17( startingTimestamp().yyyymmdd() == 20060703,
        startingTimestamp().hhmmss() == 0,
        endingTimestamp().yyyymmdd() == 20060703,
        endingTimestamp().hhmmss() == 10000,
        bounds().west() == -180.0,
        bounds().east() ==  180.0,
        bounds().south() == -90.0,
        bounds().north() ==   90.0,
        boundsZMinimum() == 0.0,
        boundsZMaximum() == 0.0,
        variables() == "aqs.pm25",
        format() == XDR,
        directory() == ".",
        compress() == false,
        integrateCMAQLayers() == false,
        aggregateMethod() == AGGREGATE_NONE,
        regridMethod() == REGRID_NONE )

-------------------------------------------------------------------------------

PURPOSE: QueryParameters - Contructor.
INTERFACE:
QueryParameters::QueryParameters(
  const CMAQGridParameters& cmaqGridParameters )
PRE015( startingTimestamp.invariant(),
        endingTimestamp.invariant(),
        startingTimestamp <= endingTimestamp,
        bounds.invariant(),
        boundsZ,
        OR2( AND2( boundsZ[ MINIMUM ] == MISSING,
                   boundsZ[ MAXIMUM ] == MISSING ),
             AND2( IN_RANGE( boundsZ[ MINIMUM ],
                             MINIMUM_ELEVATION, MAXIMUM_ELEVATION ),
                   IN_RANGE( boundsZ[ MAXIMUM ],
                             boundsZ[ MINIMUM ], MAXIMUM_ELEVATION ) ) ),
        variables.length() >= 3,
        IN_RANGE( format, 0, FILE_FORMATS - 1 ),
        directory.length() > 0,
        directory[ directory.length() - 1 ] != '/',
        isDirectory( directory.c_str() ),
        dataFilterParameters.invariant(),
        IN_RANGE( aggregateMethod, 0, AGGREGATE_METHODS - 1 ),
        IN_RANGE( regridMethod, 0, REGRID_METHODS - 1 ),
        cmaqGridParameters.invariant() )
POST14( this->startingTimestamp() == startingTimestamp,
        this->endingTimestamp() == endingTimestamp,
        this->bounds() == bounds,
        this->boundsZMinimum() == boundsZ[ MINIMUM ],
        this->boundsZMaximum() == boundsZ[ MAXIMUM ],
        this->variables() == variables,
        this->format() == format,
        this->directory() == directory,
        this->compress() == compress,
        this->integrateCMAQLayers() == integrateCMAQLayers,
        this->dataFilterParameters() == dataFilterParameters,
        this->aggregateMethod() == aggregateMethod,
        this->regridMethod() == regridMethod,
        this->cmaqGridParameters() == cmaqGridParameters )

-------------------------------------------------------------------------------

PURPOSE: QueryParameters - Copy constructor.
INPUTS:  const QueryParameters& other  Object to copy.
INTERFACE:
QueryParameters::QueryParameters( const QueryParameters& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Copy object.
INPUTS:  const QueryParameters& other  Object to copy.
INTERFACE:
QueryParameters& QueryParameters::operator=( const QueryParameters& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: timestamps - Set starting and ending timestamps.
INPUTS:  const Timestamp startingTimestamp  Starting timestamp to copy.
         const Timestamp endingTimestamp    Ending   timestamp to copy.
INTERFACE:
void QueryParameters::timestamps( const Timestamp startingTimestamp,
                                  const Timestamp endingTimestamp )
PRE3( startingTimestamp.invariant(),
      endingTimestamp.invariant(),
      startingTimestamp <= endingTimestamp )
POST2( this->startingTimestamp() == startingTimestamp,
       this->endingTimestamp() == endingTimestamp )

-------------------------------------------------------------------------------

PURPOSE: bounds - Set bounds.
INPUTS:  const Bounds& bounds  Bounds to copy.
INTERFACE:
void QueryParameters::bounds( const Bounds& bounds )
PRE( bounds.invariant() )
POST( this->bounds() == bounds )

-------------------------------------------------------------------------------

PURPOSE: boundsZ - Set boundsZ.
INPUTS:  const double boundsZ[ 2 ]  BoundsZ to copy.
INTERFACE:
void QueryParameters::boundsZ( const double boundsZ[ 2 ] )
PRE2( boundsZ,
      OR2( AND2( boundsZ[ 0 ] == MISSING,
                 boundsZ[ 1 ] == MISSING ),
           AND2( IN_RANGE( boundsZ[ 0 ],
                           MINIMUM_ELEVATION, MAXIMUM_ELEVATION ),
                 IN_RANGE( boundsZ[ 1 ],
                           boundsZ[ 0 ], MAXIMUM_ELEVATION ) ) ) )
POST2( boundsZMinimum() == boundsZ[ 0 ],
       boundsZMaximum() == boundsZ[ 1 ] )

-------------------------------------------------------------------------------

PURPOSE: variables - Set variables.
INPUTS:  const std::string& variables  Variables to copy.
INTERFACE:
void QueryParameters::variables( const std::string& variables )
PRE( variables.length() >= 3 )
POST( this->variables() == variables )

-------------------------------------------------------------------------------

PURPOSE: format - Set format.
INPUTS:  const int format  Variables to copy.
INTERFACE:
void QueryParameters::format( const int format )
PRE( IN_RANGE( format, 0, FILE_FORMATS - 1 ) )
POST( this->format() == format )

-------------------------------------------------------------------------------

PURPOSE: directory - Set directory.
INPUTS:  const std::string& directory  Directory to copy.
INTERFACE:
void QueryParameters::directory( const std::string& directory )
PRE( true )
POST( this->directory() == directory )

-------------------------------------------------------------------------------

PURPOSE: compress - Set compress.
INPUTS:  const bool compress  Compress flag to copy.
INTERFACE:
void QueryParameters::compress( const bool compress )
PRE( true )
POST( this->compress() == compress )

-------------------------------------------------------------------------------

PURPOSE: integrateCMAQLayers - Set integrate.
INPUTS:  const bool integrate  Integrate flag to copy.
INTERFACE:
void QueryParameters::integrateCMAQLayers( const bool integrate )
PRE( true )
POST( this->integrateCMAQLayers() == integrate )

-------------------------------------------------------------------------------

PURPOSE: dataFilterParameters - Set dataFilterParameters.
INPUTS:  const DataFilterParameters& dataFilterParameters  Argument to copy.
INTERFACE:
void QueryParameters::dataFilterParameters( const DataFilterParameters&
                                              dataFilterParameters )
PRE( dataFilterParameters.invariant() )
POST( this->dataFilterParameters() == dataFilterParameters )

-------------------------------------------------------------------------------

PURPOSE: aggregateMethod - Set aggregateMethod.
INPUTS:  const int aggregateMethod  aggregateMethod to copy.
INTERFACE:
void QueryParameters::aggregateMethod( const int aggregateMethod )
PRE( IN_RANGE( aggregateMethod, 0, AGGREGATE_METHODS - 1 ) )
POST( this->aggregateMethod() == aggregateMethod )

-------------------------------------------------------------------------------

PURPOSE: regridMethod - Set regridMethod.
INPUTS:  const int regridMethod  regridMethod to copy.
INTERFACE:
void QueryParameters::regridMethod( const int regridMethod )
PRE( IN_RANGE( regridMethod, 0, REGRID_METHODS - 1 ) )
POST( this->regridMethod() == regridMethod )

-------------------------------------------------------------------------------

PURPOSE: cmaqGridParameters - Set cmaqGridParameters.
INPUTS:  const CMAQGridParameters& cmaqGridParameters  Argument to copy.
INTERFACE:
void QueryParameters::cmaqGridParameters( const CMAQGridParameters&
                                            cmaqGridParameters )
PRE( cmaqGridParameters.invariant() )
POST( this->cmaqGridParameters() == cmaqGridParameters )

-------------------------------------------------------------------------------

PURPOSE: operator== - Are objects equal?
INPUTS:  const QueryParameters& other  Object to compare to.
RETURNS: bool true if equal, else false.
INTERFACE:
bool QueryParameters::operator==( const QueryParameters& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are objects unequal?
INPUTS:  const QueryParameters& other  Object to compare to.
RETURNS: bool true if unequal, else false.
INTERFACE:
bool QueryParameters::operator!=( const QueryParameters& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true or else there is a bug.
INTERFACE:
bool QueryParameters::invariant() const

-------------------------------------------------------------------------------

PURPOSE: startingTimestamp - Starting timestamp.
RETURNS: Timestamp starting timestamp.
INTERFACE:
Timestamp QueryParameters::startingTimestamp() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: endingTimestamp - Ending timestamp.
RETURNS: Timestamp ending timestamp.
INTERFACE:
Timestamp QueryParameters::endingTimestamp() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: bounds - Bounds.
RETURNS: const Bounds& bounds.
INTERFACE:
const Bounds& QueryParameters::bounds() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: boundsZMinimum - BoundsZ Minimum.
RETURNS: double boundsZ Minimum.
INTERFACE:
double QueryParameters::boundsZMinimum() const
PRE( true )
POST( OR2( result == MISSING,
           IN_RANGE( result, MINIMUM_ELEVATION, MAXIMUM_ELEVATION ) ) )

-------------------------------------------------------------------------------

PURPOSE: boundsZMaximum - BoundsZ Maximum.
RETURNS: double boundsZ Maximum.
INTERFACE:
double QueryParameters::boundsZMaximum() const
PRE( true )
POST( OR2( result == MISSING,
           IN_RANGE( result, MINIMUM_ELEVATION, MAXIMUM_ELEVATION ) ) )

-------------------------------------------------------------------------------

PURPOSE: variables - Variables.
RETURNS: const std::string& variables.
INTERFACE:
const std::string& QueryParameters::variables() const
PRE( true )
POST( result.length() >= 3 )

-------------------------------------------------------------------------------

PURPOSE: format - Format.
RETURNS: int format.
INTERFACE:
int QueryParameters::format() const
PRE( true )
POST( IN_RANGE( result, 0, FILE_FORMATS - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: directory - Directory to write files.
RETURNS: const std::string& directory.
INTERFACE:
const std::string& QueryParameters::directory() const
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: compress - Compress data over the network?
RETURNS: bool compress.
INTERFACE:
bool QueryParameters::compress() const
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: integrateCMAQLayers - Integrate CMAQ data over layers?
RETURNS: bool integrate.
INTERFACE:
bool QueryParameters::integrateCMAQLayers() const
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: dataFilterParameters - DataFilterParameters.
RETURNS: const DataFilterParameters&  dataFilterParameters.
INTERFACE:
const DataFilterParameters& QueryParameters::dataFilterParameters() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: aggregateMethod - Aggregate method.
RETURNS: int aggregate method.
INTERFACE:
int QueryParameters::aggregateMethod() const
PRE( true )
POST( IN_RANGE( result, 0, AGGREGATE_METHODS - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: regridMethod - Regrid method.
RETURNS: int regrid method.
INTERFACE:
int QueryParameters::regridMethod() const
PRE( true )
POST( IN_RANGE( result, 0, REGRID_METHODS - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: cmaqGridParameters - CMAQGridParameters.
RETURNS: const CMAQGridParameters&  cmaqGridParameters.
INTERFACE:
const CMAQGridParameters& QueryParameters::cmaqGridParameters() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: pathedFileName - Create pathed file name used for saving data.
RETURNS: std::string result  Pathed file name.
NOTES:   Throws an exception if there is not enough memory for result.
INTERFACE:
std::string QueryParameters::pathedFileName() const
PRE( directory().length() >= 1 )
POST( result.length() >= 18 )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedDataset.h - RegriddedDataset non-instantiable mixin.

TYPES:

namespace emvl {

class RegriddedDataset : public Dataset {
protected:
  std::vector<size_t> pointsPerTimestep_; // pointsPerTimestep_[ timesteps_ ].
  size_t totalPoints_;                    // Sum of pointsPerTimestep_.
  CMAQGridParameters gridParameters_;     // Of regridding.
  MapProjection* mapProjection_;          // Or 0 if lon-lat grid.

  RegriddedDataset(); //x

  virtual double vprobe( const Timestamp timestamp,
                         const double longitude,
                         const double latitude,
                         const double,
                         const int variable ) const;

  virtual std::vector<SubsetPointers> vsubset( const Timestamp beginTimestamp,
                                               const Timestamp endTimestamp,
                                               const int variable ) const;

  /*
   * Above vsubset() calls the below virtual subsetNotes().
   * The default implementation returns 0.
   * Derived classes may implement subsetNotes() to return notes pointers.
   */

  virtual const std::string* subsetNotes( const size_t skipPoints ) const;

  void copy( const RegriddedDataset& other ); //x
  bool equal( const RegriddedDataset& other ) const;
  void computeCMAQCellCoordinates( const size_t layersPerPoint,
                                   const double centerElevations[] );
  void computeCMAQGridElevations( std::vector<float>& elevations ) const; //x
  void writeIOAPICoordinates( const int file ) const; //x
  void writeIOAPIVariable( const int file ) const; //x
  void writeIOAPI( const std::string& fileName ) const; //x
  std::vector<Timestamp> timestampsPerDataPoint() const; //x
  virtual void writeASCII( FILE* stream ) const; //x
  virtual void writeCOARDS( const std::string& fileName ) const; //x
  virtual void writeKML() const; //x
public:
  virtual ~RegriddedDataset();
  virtual bool invariant() const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedDataset - Destruct a RegriddedDataset.
INTERFACE:
RegriddedDataset::~RegriddedDataset()

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: RegriddedDataset - Construct a RegriddedDataset.
NOTES:   throws std::runtime_error if unable to create mapProjection_ matching
         the default gridParameters_.
INTERFACE:
RegriddedDataset::RegriddedDataset()

-------------------------------------------------------------------------------

PURPOSE: copy - Copy other's attributes.
INPUTS:  const RegriddedDataset& other  Other object to copy.
NOTES:   throws std::runtime_error if unable to allocate memory to copy.
         Also calls Dataset::copy() to copy inherited attributes.
INTERFACE:
void RegriddedDataset::copy( const RegriddedDataset& other )
PRE0( other.invariant() )
POST0( RegriddedDataset::invariant() )

-------------------------------------------------------------------------------

PURPOSE: equal - Compare to other's attributes.
INPUTS:  const RegriddedDataset& other  Other object to compare to.
RETURNS: bool true if equal, else false.
         Also calls Dataset::equal() to compare inherited attributes.
INTERFACE:
bool RegriddedDataset::equal( const RegriddedDataset& other ) const
PRE( other.invariant() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: vprobe - Return nearest data point to time-space location.
INPUTS:  const Timestamp& timestamp  Timestamp of probe.
         const double longitude      Longitude of probe.
         const double latitude       Latitude of probe.
         const double elevation      Elevation of probe.
         const int variable          Index of variable.
RETURNS: double Data value nearest probe or MISSING if not near any data.
NOTES:   Called by base class member function probe().
         Template Method Design Pattern.
INTERFACE:
double RegriddedDataset::vprobe( const Timestamp timestamp,
                                 const int variable ) const
PRE5( timestamp.invariant(),
      isLongitude( longitude ),
      isLatitude( latitude ),
      OR2( elevation == MISSING, isElevation( elevation ) ),
      OR2( variable == IMISSING, IN_RANGE( variable, 0, variables() - 1 ) ) )
POST( OR2( result == MISSING,
           IN_RANGE( result, minimum( variable ), maximum( variable ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: vsubset - Extract a reference to the subset of data for the given
         time-range for data with time-varying coordinates.
INPUTS:  const Timestamp& beginTimestamp  Beginning timestamp of subset.
         const Timestamp& endTimestamp    End timestamp of subset.
         const int variable               Index of data variable.
RETURNS: std::vector<Dataset::SubsetPointers>  Pointers to subset coordinates
                                               and data.
NOTES:   Called by public member function subset().
         Template Method Design Pattern.
INTERFACE:
RegriddedDataset::vsubset( const Timestamp beginTimestamp,
                           const int variable ) const
PRE4( beginTimestamp.invariant(),
      endTimestamp.invariant(),
      beginTimestamp <= endTimestamp,
      OR2( variable  == IMISSING, IN_RANGE( variable, 0, variables() - 1 )))
POST( IMPLIES( result.size(),
               AND10( IMPLIES_ELSE( isVector(),
                                    AND2( result.size() > 1,
                                          result.size() % 2 == 0 ),
                                    result.size() == 1 ),
                      result[ 0 ].dataCount,
                      result[ 0 ].coordinatesCount ==
                        result[ 0 ].dataCount * cellVertexCount(),
                      result[ 0 ].coordinates,
                      result[ 0 ].data,
                      isPoint( result[ 0 ].coordinates[ 0 ] ),
                      isPoint( result[ 0 ].coordinates[
                               result[ 0 ].coordinatesCount - 1 ] ),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::minimum( result[ 0 ].data,
                                                    result[ 0 ].dataCount )
                                       > MISSING ),
                                IN_RANGE( emvl::minimum( result[ 0 ].data,
                                                         result[0].dataCount),
                                          minimum( variable ),
                                          maximum( variable ) ) ),
                      IMPLIES( AND2( variable != IMISSING,
                                     emvl::maximum( result[ 0 ].data,
                                                    result[ 0 ].dataCount )
                                       > MISSING ),
                               IN_RANGE( emvl::maximum( result[ 0 ].data,
                                                        result[ 0].dataCount),
                                         minimum( variable ),
                                         maximum( variable ) ) ),
                      IMPLIES( AND2( isVector(), variable == IMISSING ),
                                     result.size() >= 2 ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: subsetNotes - Called by vsubset() with the number of subset points to
         allow derived classes with notes to include pointers to the
         corresponding subset.
INPUTS:  const size_t skipPoints  Number of points skipped in vsubset().
RETURNS: const std::string*  Pointer to notes, if any.
NOTES:   This default implementation returns 0.
INTERFACE:
const std::string* RegriddedDataset::subsetNotes( const size_t ) const

-------------------------------------------------------------------------------

PURPOSE: computeCMAQCellCoordinates - Compute coordinates_ from data_ columns,
         rows, gridParameters_, mapProjection_.
INPUTS:  const size_t layersPerPoint  Number of layers per point.
         const double centerElevations[ totalPoints_ ] 0 or cell centers.
INTERFACE:
void RegriddedDataset::computeCMAQCellCoordinates( const size_t layersPerPoint,
                                            const double centerElevations[] )
PRE09( coordinates_.size() ==
         totalPoints_ * ( layersPerPoint > 1 ? layersPerPoint : 1 )
         * cellVertexCount(),
       isValidData(),
       variables_ >= 3,
       ! strcmp( variableNames_[ 0 ].c_str(), "column" ),
       ! strcmp( variableNames_[ 1 ].c_str(), "row" ),
       IMPLIES( centerElevations,
                ! strcmp( variableNames_[ 2 ].c_str(), "layer" ) ),
       gridParameters_.invariant(),
       IMPLIES( mapProjection_, mapProjection_->invariant() ),
       IMPLIES_ELSE( ! mapProjection_,
                     gridParameters_.gdtyp() == CMAQGridParameters::LATGRD3,
                    gridParameters_.gdtyp() != CMAQGridParameters::LATGRD3))
POST010( coordinates_.size() ==
           totalPoints_ * ( layersPerPoint > 1 ? layersPerPoint : 1 )
           * cellVertexCount(),
         isValidData(),
         variables_ >= 3,
         ! strcmp( variableNames_[ 0 ].c_str(), "column" ),
         ! strcmp( variableNames_[ 1 ].c_str(), "row" ),
         IMPLIES( centerElevations,
                 ! strcmp( variableNames_[ 2 ].c_str(), "layer" ) ),
         gridParameters_.invariant(),
         IMPLIES( mapProjection_, mapProjection_->invariant() ),
         IMPLIES_ELSE( ! mapProjection_,
                      gridParameters_.gdtyp() == CMAQGridParameters::LATGRD3,
                     gridParameters_.gdtyp() != CMAQGridParameters::LATGRD3),
         isValidCoordinates() )

-------------------------------------------------------------------------------

PURPOSE: computeCMAQGridElevations - Compute grid cell center elevations from
         gridParameters_.
OUTPUTS: std::vector<float> elevations  Cell center elevations.
         elevations[ hasElevation() ? gridParameters_.nlays() : 1 ]
                   [ gridParameters_.nrows() ][ gridParameters_.ncols() ]
NOTES:   Throws exception upon failure to allocate elevations.
         Computes elevations from sigma-P values assuming surface_elevation = 0
INTERFACE:
void RegriddedDataset::computeCMAQGridElevations(
                                      std::vector<float>& elevations ) const
PRE( gridParameters_.invariant() )
POST3( (int) elevations.size() ==
         ( hasElevation() ? gridParameters_.nlays() : 1 ) *
         gridParameters_.nrows() * gridParameters_.ncols(),
       isElevation( emvl::minimum( &elevations[ 0 ], elevations.size() ) ),
       isElevation( emvl::maximum( &elevations[ 0 ], elevations.size() ) ) )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPICoordinates - Write IOAPI-format longitude
         latitude and optionally elevation data to file.
INPUTS:  const int file  NetCDF file to write to.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeIOAPICoordinates( const int file ) const
PRE( file > 0 )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPIVariable - Write IOAPI-format variable data to file.
INPUTS:  const int file  NetCDF file to write to.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeIOAPIVariable( const int file ) const
PRE( file > 0 )

-------------------------------------------------------------------------------

PURPOSE: writeIOAPI - Write IOAPI-format file.
INPUTS:  const std::string& fileName  File name to create.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeIOAPI( const std::string& fileName ) const
PRE( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: timestampsPerDataPoint - Create and return a copy of timestamps per
         data point.
NOTES:   Throws exception upon failure to allocate result.
INTERFACE:
std::vector<Timestamp> RegriddedDataset::timestampsPerDataPoint() const
PRE( true )
POST( result.size() == totalPoints_ * ( layers() > 0 ? layers() : 1 ) )

-------------------------------------------------------------------------------

PURPOSE: writeASCII - Write ASCII format to a stream.
INPUTS:  FILE* stream  Stream to write to.
OUTPUTS: FILE* stream  Updated stream.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeASCII( FILE* stream ) const
PRE( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: writeCOARDS - Write COARDS-format data.
INPUTS:  const std::string& fileName  File name to create.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeCOARDS( const std::string& fileName) const
PRE( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: writeKML - Write KML-format data.
NOTES:   Throws exception upon failure.
INTERFACE:
void RegriddedDataset::writeKML() const
PRE( outputKMLFile_ )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: indexOfString - Index of string in strings or -1 if not present.
INPUTS:  const char* const string                 String to search for.
         const std::vector<std::string>& strings  Strings to search.
RETURNS: size_t index of string in strings, else strings.size() if not present.
INTERFACE:
size_t indexOfString( const char* const string,
                             const std::vector<std::string>& strings )
PRE03( string, *string, strings.size() )
POST0( OR2( result == strings.size(),
            AND2( result < strings.size(),
                  ! strcmp( string, strings[ result ].c_str() ) ) ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: PointDataset.h - Dataset of 2D/3D point data.

TYPES:

namespace emvl {

class PointDataset : public Dataset {
public:

  // Commands:

  virtual ~PointDataset();
  PointDataset( FILE* file ); //x
  PointDataset( const std::string& fileName ); //x
  PointDataset( const PointDataset& other ); //x
  PointDataset& operator=( const PointDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const PointDataset& other ) const;
  bool operator!=( const PointDataset& other ) const;
  size_t notes() const;
  const std::string& note( const size_t point ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~PointDataset - Destruct a PointDataset.
INTERFACE:
PointDataset::~PointDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: PointDataset - Construct a PointDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid point data.
INTERFACE:
PointDataset::PointDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: PointDataset - Construct a PointDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid point data.
INTERFACE:
PointDataset::PointDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: PointDataset - Copy-construct a PointDataset.
INPUTS:  const PointDataset& other  Object to copy.
INTERFACE:
PointDataset::PointDataset( const PointDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a PointDataset.
INPUTS:  const PointDataset& other  Object to copy.
RETURNS: PointDataset& *this.
INTERFACE:
PointDataset& PointDataset::operator=( const PointDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* PointDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* PointDataset::regrid( const int regridMethod,
                                cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void PointDataset::write( const std::string& directory,
                          const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool PointDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool PointDataset::operator==( const PointDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool PointDataset::operator!=( const PointDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: notes - Number of notes.
RETURNS: size_t number of notes or 0 if none.
INTERFACE:
size_t PointDataset::notes() const
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: note - Note of a data point.
INPUTS:  const size_t point  Index of data point.
RETURNS: const std::string& note of a data point.
INTERFACE:
const std::string& PointDataset::note( const size_t point ) const
PRE( point < notes() - 1 )
POST( result.length() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedPointDataset.h - Dataset of regridded 2D/3D point data.

TYPES:

namespace emvl {

class RegriddedPointDataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedPointDataset();
  RegriddedPointDataset( FILE* file ); //x
  RegriddedPointDataset( const std::string& fileName ); //x
  RegriddedPointDataset( const RegriddedPointDataset& other ); //x
  RegriddedPointDataset& operator=( const RegriddedPointDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const RegriddedPointDataset& other ) const;
  bool operator!=( const RegriddedPointDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedPointDataset - Destruct a RegriddedPointDataset.
INTERFACE:
RegriddedPointDataset::~RegriddedPointDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedPointDataset - Construct a RegriddedPointDataset from reading a
         stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid regridded point data
         from file.
INTERFACE:
RegriddedPointDataset::RegriddedPointDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedPointDataset - Construct a RegriddedPointDataset from reading a
         file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid regridded point data
         from file.
INTERFACE:
RegriddedPointDataset::RegriddedPointDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedPointDataset - Copy-construct a RegriddedPointDataset.
INPUTS:  const RegriddedPointDataset& other  Object to copy.
INTERFACE:
RegriddedPointDataset::RegriddedPointDataset(const RegriddedPointDataset& other)
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedPointDataset.
INPUTS:  const RegriddedPointDataset& other  Object to copy.
RETURNS: RegriddedPointDataset& *this.
INTERFACE:
RegriddedPointDataset& RegriddedPointDataset::operator=(
  const RegriddedPointDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedPointDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedPointDataset::regrid( const int regridMethod,
                                         cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedPointDataset::write( const std::string& directory,
                                  const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedPointDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedPointDataset::operator==( const RegriddedPointDataset& other )
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedPointDataset::operator!=( const RegriddedPointDataset& other )
  const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: SiteDataset.h - Dataset of site (ground station) data.

TYPES:

namespace emvl {

class SiteDataset : public Dataset {
public:

  // Commands:

  virtual ~SiteDataset();
  SiteDataset( FILE* file ); //x
  SiteDataset( const std::string& fileName ); //x
  SiteDataset( const SiteDataset& other ); //x
  SiteDataset& operator=( const SiteDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const SiteDataset& other ) const;
  bool operator!=( const SiteDataset& other ) const;
  size_t stations() const;
  const std::string& note( const size_t station ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~SiteDataset - Destruct a SiteDataset.
INTERFACE:
SiteDataset::~SiteDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: SiteDataset - Construct a SiteDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid site data.
INTERFACE:
SiteDataset::SiteDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: SiteDataset - Construct a SiteDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid site data.
INTERFACE:
SiteDataset::SiteDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: SiteDataset - Copy-construct a SiteDataset.
INPUTS:  const SiteDataset& other  Object to copy.
INTERFACE:
SiteDataset::SiteDataset( const SiteDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a SiteDataset.
INPUTS:  const SiteDataset& other  Object to copy.
RETURNS: SiteDataset& *this.
INTERFACE:
SiteDataset& SiteDataset::operator=( const SiteDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* SiteDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* SiteDataset::regrid( const int regridMethod,
                                cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void SiteDataset::write( const std::string& directory,
                         const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool SiteDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool SiteDataset::operator==( const SiteDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool SiteDataset::operator!=( const SiteDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: stations - Number of stations in dataset.
RETURNS: size_t number of stations in dataset.
INTERFACE:
size_t SiteDataset::stations() const
PRE( true )
POST( result )

-------------------------------------------------------------------------------

PURPOSE: note - Note of a profile.
INPUTS:  const size_t profile  Index of profile.
RETURNS: const std::string& note of a profile.
INTERFACE:
const std::string& SiteDataset::note( const size_t station ) const
PRE( IN_RANGE( station, 0, notes_.size() - 1 ) )
POST( result.length() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedSiteDataset.h - Dataset of regridded site (ground station)
         data.

TYPES:

namespace emvl {

class RegriddedSiteDataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedSiteDataset();
  RegriddedSiteDataset( FILE* file ); //x
  RegriddedSiteDataset( const std::string& fileName ); //x
  RegriddedSiteDataset( const RegriddedSiteDataset& other ); //x
  RegriddedSiteDataset& operator=( const RegriddedSiteDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const RegriddedSiteDataset& other ) const;
  bool operator!=( const RegriddedSiteDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedSiteDataset - Destruct a RegriddedSiteDataset.
INTERFACE:
RegriddedSiteDataset::~RegriddedSiteDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSiteDataset - Construct a RegriddedSiteDataset from reading a
         stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid regridded site data
         from file.
INTERFACE:
RegriddedSiteDataset::RegriddedSiteDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSiteDataset - Construct a RegriddedSiteDataset from reading a
         file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid regridded site data
         from file.
INTERFACE:
RegriddedSiteDataset::RegriddedSiteDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSiteDataset - Copy-construct a RegriddedSiteDataset.
INPUTS:  const RegriddedSiteDataset& other  Object to copy.
INTERFACE:
RegriddedSiteDataset::RegriddedSiteDataset(const RegriddedSiteDataset& other)
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedSiteDataset.
INPUTS:  const RegriddedSiteDataset& other  Object to copy.
RETURNS: RegriddedSiteDataset& *this.
INTERFACE:
RegriddedSiteDataset& RegriddedSiteDataset::operator=(
  const RegriddedSiteDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedSiteDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedSiteDataset::regrid( const int regridMethod,
                                         cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedSiteDataset::write( const std::string& directory,
                                  const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedSiteDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedSiteDataset::operator==( const RegriddedSiteDataset& other )
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedSiteDataset::operator!=( const RegriddedSiteDataset& other )
  const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: CMAQDataset.h - Dataset of CMAQ gridded model data.

TYPES:

namespace emvl {

class CMAQDataset : public Dataset {
public:

  typedef size_t SubsetIndices[4][2]; // [TIME,LAYER,ROW,COLUMN][FIRST,LAST].

public:

  // Commands:

  virtual ~CMAQDataset();
  CMAQDataset( FILE* file ); //x
  CMAQDataset( const std::string& fileName ); //x
  CMAQDataset( const CMAQDataset& other ); //x
  CMAQDataset& operator=( const CMAQDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const CMAQDataset& other ) const;
  bool operator!=( const CMAQDataset& other ) const;
  virtual bool isSurfaceData() const;
  virtual size_t layers() const;
  virtual size_t rows() const;
  virtual size_t columns() const;
  const std::string& gridName() const;
  const SubsetIndices& subsetIndices() const;
  const CMAQGridParameters& gridParameters() const;
  const MapProjection* mapProjection() const;
  virtual void cellVertices( const size_t cell, Point points[] ) const;
};



/******************************************************************************
PURPOSE: copyCellCenterCoordinates - Compute and store a copy of a coordinate
         for all grid cells.
INPUTS:  const int coordinate    LONGITUDE, LATITUDE or ELEVATION.
OUTPUTS: T output[]  output[ layers_ * rows_ * columns_ ]
******************************************************************************/

template <typename T>
void CMAQDataset::copyCellCenterCoordinates( const int coordinate,
                                             T output[] ) const {
  PRE2( IN4( coordinate, LONGITUDE, LATITUDE, ELEVATION ), output );

  const double* const coordinates =
    coordinate == LONGITUDE ? &longitudes_[ 0 ]
    : coordinate == LATITUDE ? &latitudes_[ 0 ]
    : 0;
  const size_t layerSize = rows_ * columns_;

  if ( IN3( coordinate, LONGITUDE, LATITUDE ) ) {
    const size_t rowSize = columns_ + 1;
    size_t outputIndex = 0;

    // Compute grid cell center coordinate by averaging 4 corner coordinates:

    for ( size_t row = 0; row < rows_; ++row ) {
      const size_t rowOffset = row * rowSize;

      for ( size_t column = 0; column < columns_; ++column, ++outputIndex ) {
        const size_t indexSW = rowOffset + column;
        const size_t indexSE = indexSW + 1;
        const size_t indexNW = indexSW + rowSize;
        const size_t indexNE = indexNW + 1;
        CHECK4( IN_RANGE( indexSW, 0, ( rows_ + 1 ) * ( columns_ + 1 ) - 2 ),
                IN_RANGE( indexSE, 1, ( rows_ + 1 ) * ( columns_ + 1 ) - 1 ),
                IN_RANGE( indexNW, 0, ( rows_ + 1 ) * ( columns_ + 1 ) - 2 ),
                IN_RANGE( indexNE, 1, ( rows_ + 1 ) * ( columns_ + 1 ) - 1 ) );
        const double coordinateSW = coordinates[ indexSW ];
        const double coordinateSE = coordinates[ indexSE ];
        const double coordinateNW = coordinates[ indexNW ];
        const double coordinateNE = coordinates[ indexNE ];
        CHECK( IMPLIES_ELSE( coordinate == LONGITUDE,
                             AND4( isLongitude( coordinateSW ),
                                   isLongitude( coordinateSE ),
                                   isLongitude( coordinateNW ),
                                   isLongitude( coordinateNE ) ),
                             AND4( isLatitude( coordinateSW ),
                                   isLatitude( coordinateSE ),
                                   isLatitude( coordinateNW ),
                                   isLatitude( coordinateNE ) ) ) );
        const double centerCoordinate =
          0.25 * ( coordinateSW + coordinateSE + coordinateNW + coordinateNE );
        CHECK( IN_RANGE( outputIndex, 0, rows_ * columns_ - 1 ) );
        output[ outputIndex ] = centerCoordinate;
        CHECK( IMPLIES_ELSE( coordinate == LONGITUDE,
                             isLongitude( output[ outputIndex ] ),
                             isLatitude( output[ outputIndex ] ) ) );
      }
    }

    // Replicate values to all layers:

    const size_t layerBytes = layerSize * sizeof output[ 0 ];

    for ( size_t layer = 1; layer < layers_; ++layer,
          outputIndex += layerSize ) {
      CHECK2( IN_RANGE( outputIndex, layerSize, layers_ * rows_ * columns_ -1),
              IN_RANGE( outputIndex + layerSize,
                        layerSize, layers_ * rows_ * columns_ ) );
      memcpy( &output[ outputIndex ], &output[ 0 ], layerBytes );
    }

  } else { // Copy elevations:

    if ( cellType_ == HEXAHEDRON ) { // Average cell top and bottom coordinate:
      CHECK( elevations_.size() == ( layers_ + 1 ) * rows_ * columns_ );

      for ( size_t layer = 0, outputIndex = 0; layer < layers_; ++layer ) {
        const size_t layerOffset = layer * layerSize;

        for ( size_t cell = 0; cell < layerSize; ++cell, ++outputIndex ) {
          const size_t index = layerOffset + cell;
          const size_t nextLayerIndex = index + layerSize;
          CHECK2( IN_RANGE( index, 0, layers_ * rows_ * columns_ - 1 ),
                  IN_RANGE( nextLayerIndex, 0,
                            ( layers_ + 1 ) * rows_ * columns_ - 1 ) );
          const double elevation = elevations_[ index ];
          const double nextLayerElevation = elevations_[ nextLayerIndex ];
          const double centerElevation =
            0.5 * ( elevation + nextLayerElevation );
          CHECK3( isElevation( elevation ),
                  isElevation( nextLayerElevation ),
                  IN_RANGE( outputIndex, 0, layers_ * rows_ * columns_ - 1 ) );
          output[ outputIndex ] = centerElevation;
          CHECK( isElevation( output[ outputIndex ] ) );
        }
      }
    } else { // Copy center elevations:
      CHECK3( cellType_ == QUADRILATERAL, layers_ == 1,
              elevations_.size() == layerSize );

      for ( size_t cell = 0; cell < layerSize; ++cell ) {
        output[ cell ] = elevations_[ cell ];
        CHECK( isElevation( output[ cell ] ) );
      }
    }
  }

  POST( OR3( AND3( coordinate == LONGITUDE,
                   isLongitude( emvl::minimum( &output[ 0 ],
                                               layers_ * rows_ * columns_ ) ),
                   isLongitude( emvl::maximum( &output[ 0 ],
                                               layers_ * rows_ * columns_ ) )),
             AND3( coordinate == LATITUDE,
                   isLatitude( emvl::minimum( &output[ 0 ],
                                              layers_ * rows_ * columns_ ) ),
                   isLatitude( emvl::maximum( &output[ 0 ],
                                              layers_ * rows_ * columns_ ) ) ),
             AND3( coordinate == ELEVATION,
                   isElevation( emvl::minimum( &output[ 0 ],
                                               layers_ * rows_ * columns_ ) ),
                   isElevation( emvl::maximum( &output[ 0 ],
                                               layers_ * rows_ * columns_)))));
}



} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~CMAQDataset - Destruct a CMAQDataset.
INTERFACE:
CMAQDataset::~CMAQDataset()

-------------------------------------------------------------------------------

PURPOSE: CMAQDataset - Construct a CMAQDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
CMAQDataset::CMAQDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CMAQDataset - Construct a CMAQDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
CMAQDataset::CMAQDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CMAQDataset - Copy-construct a CMAQDataset.
INPUTS:  const CMAQDataset& other  Object to copy.
INTERFACE:
CMAQDataset::CMAQDataset( const CMAQDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a CMAQDataset.
INPUTS:  const CMAQDataset& other  Object to copy.
RETURNS: CMAQDataset& *this.
INTERFACE:
CMAQDataset& CMAQDataset::operator=( const CMAQDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* CMAQDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* CMAQDataset::regrid( const int regridMethod,
                                cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void CMAQDataset::write( const std::string& directory,
                         const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool CMAQDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool CMAQDataset::operator==( const CMAQDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool CMAQDataset::operator!=( const CMAQDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool true if this is only layer-1 data.
INTERFACE:
bool CMAQDataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: layers - Number of grid layers.
RETURNS: size_t Number of grid layers.
INTERFACE:
size_t CMAQDataset::layers() const
POST0( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: rows - Number of grid rows.
RETURNS: size_t Number of grid rows.
INTERFACE:
size_t CMAQDataset::rows() const
POST0( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: columns - Number of grid columns.
RETURNS: size_t Number of grid columns.
INTERFACE:
size_t CMAQDataset::columns() const
POST0( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: cellVertices - Get a copy of a cell's vertices. This is needed when
         coordinates are not stored, but rather computed (by this routine) as
         indicated by subset() returning SubsetPointers.coordinates == 0.
INPUTS:  const size_t cell  Index of cell.
OUTPUTS: Point points[ cellVertexCount() ]  Cell's vertices.
INTERFACE:
void CMAQDataset::cellVertices( const size_t cell, Point points[] ) const
PRE02( points,
       IN_RANGE( cell, 0,
                 layers_ * rows_ * columns_ * cellVertexCount() - 1 ) )
POST02( isPoint( points[ 0 ] ), isPoint( points[ cellVertexCount() - 1 ] ) )

-------------------------------------------------------------------------------

PURPOSE: gridName - Name of grid.
RETURNS: const std::string&  Name of grid.
INTERFACE:
const std::string& CMAQDataset::gridName() const
PRE( true )
POST( result.length() )

-------------------------------------------------------------------------------

PURPOSE: subsetIndices - 0-based timestep and 1-based layer, row, column
         indices of subset of original grid.
RETURNS: const CMAQDataset::SubsetIndices& Name of grid.
INTERFACE:
const CMAQDataset::SubsetIndices& CMAQDataset::subsetIndices() const
PRE( true )
POST12( result[ TIME   ][ FIRST ] >= 0,
        result[ TIME   ][ LAST  ] >= result[ TIME  ][FIRST],
        result[ LAYER  ][ FIRST ] >= 1,
        result[ LAYER  ][ LAST  ] >= result[ LAYER ][FIRST],
        result[ ROW    ][ FIRST ] >= 1,
        result[ ROW    ][ LAST  ] >= result[ ROW   ][FIRST],
        result[ COLUMN ][ FIRST ] >= 1,
        result[ COLUMN ][ LAST  ] >= result[ COLUMN][FIRST],
        timesteps() == 1 + result[ TIME   ][ LAST ] - result[ TIME ][ FIRST],
        layers()    == 1 + result[ LAYER  ][ LAST ] - result[ LAYER][ FIRST],
        rows()      == 1 + result[ ROW    ][ LAST ] - result[ ROW  ][ FIRST],
        columns()   == 1 + result[ COLUMN ][ LAST ] - result[COLUMN][FIRST])

-------------------------------------------------------------------------------

PURPOSE: gridParameters - Parameters of grid.
RETURNS: const CMAQGridParameters&  Name of grid.
INTERFACE:
const CMAQGridParameters& CMAQDataset::gridParameters() const
PRE( true )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: mapProjection - MapProjection of grid.
RETURNS: const MapProjection*  MapProjection of grid or 0 if lonlat grid.
INTERFACE:
const MapProjection* CMAQDataset::mapProjection() const
PRE( true )
POST( IMPLIES( result, result->invariant() ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: SwathDataset.h - Dataset of swath satellite data.

TYPES:

namespace emvl {

class SwathDataset : public Dataset {

public:

  // Commands:

  virtual ~SwathDataset();
  SwathDataset( FILE* file ); //x
  SwathDataset( const std::string& fileName ); //x
  SwathDataset( const SwathDataset& other ); //x
  SwathDataset& operator=( const SwathDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const SwathDataset& other ) const;
  bool operator!=( const SwathDataset& other ) const;
  size_t scans() const;
  Timestamp timestamp( const size_t scan ) const;
  size_t points( const size_t scan ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~SwathDataset - Destruct a SwathDataset.
INTERFACE:
SwathDataset::~SwathDataset()

-------------------------------------------------------------------------------

PURPOSE: SwathDataset - Construct a SwathDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
SwathDataset::SwathDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: SwathDataset - Construct a SwathDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
SwathDataset::SwathDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: SwathDataset - Copy-construct a SwathDataset.
INPUTS:  const SwathDataset& other  Object to copy.
INTERFACE:
SwathDataset::SwathDataset( const SwathDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a SwathDataset.
INPUTS:  const SwathDataset& other  Object to copy.
RETURNS: SwathDataset& *this.
INTERFACE:
SwathDataset& SwathDataset::operator=( const SwathDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* SwathDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* SwathDataset::regrid( const int regridMethod,
                                cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void SwathDataset::write( const std::string& directory,
                         const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool SwathDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool SwathDataset::operator==( const SwathDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool SwathDataset::operator!=( const SwathDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: scans - Number of satellite scans.
RETURNS: size_t Number of satellite scans.
INTERFACE:
size_t SwathDataset::scans() const
PRE( true )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: timestamp - Timestamp of a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: Timestamp of a scan.
INTERFACE:
Timestamp SwathDataset::timestamp( const size_t scan ) const
PRE( IN_RANGE( scan, 0, timestamps_.size() - 1 ) )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: points - Points in a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: size_t number of points in a scan.
INTERFACE:
size_t SwathDataset::points( const size_t scan ) const
PRE( IN_RANGE( scan, 0, points_.size() - 1 ) )
POST( result >= 1 )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedSwathDataset.h - Dataset of regridded swath satellite data.

TYPES:

namespace emvl {

class RegriddedSwathDataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedSwathDataset();
  RegriddedSwathDataset( FILE* file ); //x
  RegriddedSwathDataset( const std::string& fileName ); //x
  RegriddedSwathDataset( const RegriddedSwathDataset& other ); //x
  RegriddedSwathDataset& operator=( const RegriddedSwathDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const RegriddedSwathDataset& other ) const;
  bool operator!=( const RegriddedSwathDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedSwathDataset - Destruct a RegriddedSwathDataset.
INTERFACE:
RegriddedSwathDataset::~RegriddedSwathDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSwathDataset - Construct a RegriddedSwathDataset from a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedSwathDataset::RegriddedSwathDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSwathDataset - Construct a RegriddedSwathDataset from a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedSwathDataset::RegriddedSwathDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedSwathDataset - Copy-construct a RegriddedSwathDataset.
INPUTS:  const RegriddedSwathDataset& other  Object to copy.
INTERFACE:
RegriddedSwathDataset::RegriddedSwathDataset(const RegriddedSwathDataset& other)
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedSwathDataset.
INPUTS:  const RegriddedSwathDataset& other  Object to copy.
RETURNS: RegriddedSwathDataset& *this.
INTERFACE:
RegriddedSwathDataset& RegriddedSwathDataset::operator=(
  const RegriddedSwathDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedSwathDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedSwathDataset::regrid( const int regridMethod,
                                         cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedSwathDataset::write( const std::string& directory,
                                   const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedSwathDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedSwathDataset::operator==( const RegriddedSwathDataset& other )
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedSwathDataset::operator!=( const RegriddedSwathDataset& other )
  const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: AircraftDataset.h - Dataset of Aircraft measured data.

TYPES:

namespace emvl {

class AircraftDataset : public Dataset {

public:

  // Commands:

  virtual ~AircraftDataset();
  AircraftDataset( FILE* file ); //x
  AircraftDataset( const std::string& fileName ); //x
  AircraftDataset( const AircraftDataset& other ); //x
  AircraftDataset& operator=( const AircraftDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual bool isSurfaceData() const; // Returns false.
  bool operator==( const AircraftDataset& other ) const;
  bool operator!=( const AircraftDataset& other ) const;
  size_t tracks() const;
  size_t points( const size_t track ) const;
  const std::string& note( const size_t track ) const;
  const Bounds& trackBounds( const size_t track ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~AircraftDataset - Destruct a AircraftDataset.
INTERFACE:
AircraftDataset::~AircraftDataset()

-------------------------------------------------------------------------------

PURPOSE: AircraftDataset - Construct a AircraftDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
AircraftDataset::AircraftDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: AircraftDataset - Construct a AircraftDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
AircraftDataset::AircraftDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: AircraftDataset - Copy-construct a AircraftDataset.
INPUTS:  const AircraftDataset& other  Object to copy.
INTERFACE:
AircraftDataset::AircraftDataset( const AircraftDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a AircraftDataset.
INPUTS:  const AircraftDataset& other  Object to copy.
RETURNS: AircraftDataset& *this.
INTERFACE:
AircraftDataset& AircraftDataset::operator=( const AircraftDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* AircraftDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* AircraftDataset::regrid( const int regridMethod,
                                ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void AircraftDataset::write( const std::string& directory,
                             const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool AircraftDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool false.
INTERFACE:
bool AircraftDataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool AircraftDataset::operator==( const AircraftDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool AircraftDataset::operator!=( const AircraftDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: tracks - Number of satellite tracks.
RETURNS: size_t Number of satellite tracks.
INTERFACE:
size_t AircraftDataset::tracks() const
PRE( true )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: points - Points in a satellite track.
INPUTS:  const size_t track  Index of track.
RETURNS: size_t number of points in a track.
INTERFACE:
size_t AircraftDataset::points( const size_t track ) const
PRE( IN_RANGE( track, 0, points_.size() - 1 ) )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: trackBounds - Bounds of a satellite track.
INPUTS:  const size_t track  Index of track.
RETURNS: const Bounds& Bounds of a track.
INTERFACE:
const Bounds& AircraftDataset::trackBounds( const size_t track ) const
PRE( IN_RANGE( track, 0, trackBounds_.size() - 1 ) )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: note - Note of a satellite track.
INPUTS:  const size_t track  Index of track.
RETURNS: const std::string& note of a track.
INTERFACE:
const std::string& AircraftDataset::note( const size_t track ) const
PRE( IN_RANGE( track, 0, notes_.size() - 1 ) )
POST( result.length() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedAircraftDataset.h - Dataset for Aircraft measured data.

TYPES:

namespace emvl {

class RegriddedAircraftDataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedAircraftDataset();
  RegriddedAircraftDataset( FILE* file ); //x
  RegriddedAircraftDataset( const std::string& fileName ); //x
  RegriddedAircraftDataset( const RegriddedAircraftDataset& other ); //x
  RegriddedAircraftDataset& operator=(
                                  const RegriddedAircraftDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual bool isSurfaceData() const; // Returns false.
  bool operator==( const RegriddedAircraftDataset& other ) const;
  bool operator!=( const RegriddedAircraftDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedAircraftDataset - Destruct a RegriddedAircraftDataset.
INTERFACE:
RegriddedAircraftDataset::~RegriddedAircraftDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedAircraftDataset - Construct a RegriddedAircraftDataset from
         a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedAircraftDataset::RegriddedAircraftDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedAircraftDataset - Construct a RegriddedAircraftDataset from
         a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedAircraftDataset::RegriddedAircraftDataset( const std::string&
                                                      fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedAircraftDataset - Copy-construct a RegriddedAircraftDataset.
INPUTS:  const RegriddedAircraftDataset& other  Object to copy.
INTERFACE:
RegriddedAircraftDataset::RegriddedAircraftDataset(
  const RegriddedAircraftDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedAircraftDataset.
INPUTS:  const RegriddedAircraftDataset& other  Object to copy.
RETURNS: RegriddedAircraftDataset& *this.
INTERFACE:
RegriddedAircraftDataset& RegriddedAircraftDataset::operator=(
  const RegriddedAircraftDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedAircraftDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedAircraftDataset::regrid( const int regridMethod,
                                             cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedAircraftDataset::write( const std::string& directory,
                                      const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedAircraftDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool false.
INTERFACE:
bool RegriddedAircraftDataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedAircraftDataset::operator==( const RegriddedAircraftDataset&
                                             other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedAircraftDataset::operator!=(
  const RegriddedAircraftDataset& other ) const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: ProfileDataset.h - Dataset of Profile (e.g., spectrophotometer)
         ground station data.

TYPES:

namespace emvl {

class ProfileDataset : public Dataset {

public:

  // Commands:

  virtual ~ProfileDataset();
  ProfileDataset( FILE* file ); //x
  ProfileDataset( const std::string& fileName ); //x
  ProfileDataset( const ProfileDataset& other ); //x
  ProfileDataset& operator=( const ProfileDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual bool isSurfaceData() const; // Returns false.
  bool operator==( const ProfileDataset& other ) const;
  bool operator!=( const ProfileDataset& other ) const;
  size_t profiles() const;
  Timestamp timestamp( const size_t point ) const;
  size_t points( const size_t profile ) const;
  const std::string& note( const size_t profile ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~ProfileDataset - Destruct a ProfileDataset.
INTERFACE:
ProfileDataset::~ProfileDataset()

-------------------------------------------------------------------------------

PURPOSE: ProfileDataset - Construct a ProfileDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
ProfileDataset::ProfileDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: ProfileDataset - Construct a ProfileDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
ProfileDataset::ProfileDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: ProfileDataset - Copy-construct a ProfileDataset.
INPUTS:  const ProfileDataset& other  Object to copy.
INTERFACE:
ProfileDataset::ProfileDataset( const ProfileDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a ProfileDataset.
INPUTS:  const ProfileDataset& other  Object to copy.
RETURNS: ProfileDataset& *this.
INTERFACE:
ProfileDataset& ProfileDataset::operator=( const ProfileDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* ProfileDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* ProfileDataset::regrid( const int regridMethod,
                                 cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void ProfileDataset::write( const std::string& directory,
                            const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool ProfileDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool false.
INTERFACE:
bool ProfileDataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool ProfileDataset::operator==( const ProfileDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool ProfileDataset::operator!=( const ProfileDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: profiles - Number of profiles.
RETURNS: size_t Number of profiles.
INTERFACE:
size_t ProfileDataset::profiles() const
PRE( true )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: timestamp - Timestamp of a point.
INPUTS:  const size_t point  Index of point.
RETURNS: Timestamp of a profile.
INTERFACE:
Timestamp ProfileDataset::timestamp( const size_t point ) const
PRE( IN_RANGE( point, 0, timestamps_.size() - 1 ) )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: points - Points in a profile.
INPUTS:  const size_t profile  Index of profile.
RETURNS: size_t number of points in a profile.
INTERFACE:
size_t ProfileDataset::points( const size_t profile ) const
PRE( IN_RANGE( profile, 0, points_.size() - 1 ) )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: note - Note of a profile.
INPUTS:  const size_t profile  Index of profile.
RETURNS: const std::string& note of a profile.
INTERFACE:
const std::string& ProfileDataset::note( const size_t profile ) const
PRE( IN_RANGE( profile, 0, notes_.size() - 1 ) )
POST( result.length() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedProfileDataset.h - Dataset of regridded Profile data.

TYPES:

namespace emvl {

class RegriddedProfileDataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedProfileDataset();
  RegriddedProfileDataset( FILE* file ); //x
  RegriddedProfileDataset( const std::string& fileName ); //x
  RegriddedProfileDataset( const RegriddedProfileDataset& other ); //x
  RegriddedProfileDataset& operator=( const RegriddedProfileDataset& other);//x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual bool isSurfaceData() const; // Returns false.
  bool operator==( const RegriddedProfileDataset& other ) const;
  bool operator!=( const RegriddedProfileDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedProfileDataset - Destruct a RegriddedProfileDataset.
INTERFACE:
RegriddedProfileDataset::~RegriddedProfileDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedProfileDataset - Construct a RegriddedProfileDataset from a
         stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedProfileDataset::RegriddedProfileDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedProfileDataset - Construct a RegriddedProfileDataset from a
         file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedProfileDataset::RegriddedProfileDataset(const std::string& fileName)
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedProfileDataset - Copy-construct a RegriddedProfileDataset.
INPUTS:  const RegriddedProfileDataset& other  Object to copy.
INTERFACE:
RegriddedProfileDataset::RegriddedProfileDataset(
  const RegriddedProfileDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedProfileDataset.
INPUTS:  const RegriddedProfileDataset& other  Object to copy.
RETURNS: RegriddedProfileDataset& *this.
INTERFACE:
RegriddedProfileDataset& RegriddedProfileDataset::operator=(
  const RegriddedProfileDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedProfileDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedProfileDataset::regrid( const int regridMethod,
                                          cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedProfileDataset::write( const std::string& directory,
                                     const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedProfileDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool false.
INTERFACE:
bool RegriddedProfileDataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedProfileDataset::operator==( const RegriddedProfileDataset& other)
  const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedProfileDataset::operator!=( const RegriddedProfileDataset& other)
  const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: CALIPSODataset.h - Dataset of CALIPSO satellite data.

TYPES:

namespace emvl {

class CALIPSODataset : public Dataset {

public:

  // Commands:

  virtual ~CALIPSODataset();
  CALIPSODataset( FILE* file ); //x
  CALIPSODataset( const std::string& fileName ); //x
  CALIPSODataset( const CALIPSODataset& other ); //x
  CALIPSODataset& operator=( const CALIPSODataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual bool isSurfaceData() const;
  bool operator==( const CALIPSODataset& other ) const;
  bool operator!=( const CALIPSODataset& other ) const;
  size_t scans() const;
  Timestamp timestamp( const size_t scan ) const;
  size_t scanGroundPoints( const size_t scan ) const;
  size_t scanVerticalPoints( const size_t scan ) const;
  const Bounds& scanBounds( const size_t scan ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~CALIPSODataset - Destruct a CALIPSODataset.
INTERFACE:
CALIPSODataset::~CALIPSODataset()

-------------------------------------------------------------------------------

PURPOSE: CALIPSODataset - Construct a CALIPSODataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
CALIPSODataset::CALIPSODataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CALIPSODataset - Construct a CALIPSODataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
CALIPSODataset::CALIPSODataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: CALIPSODataset - Copy-construct a CALIPSODataset.
INPUTS:  const CALIPSODataset& other  Object to copy.
INTERFACE:
CALIPSODataset::CALIPSODataset( const CALIPSODataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a CALIPSODataset.
INPUTS:  const CALIPSODataset& other  Object to copy.
RETURNS: CALIPSODataset& *this.
INTERFACE:
CALIPSODataset& CALIPSODataset::operator=( const CALIPSODataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* CALIPSODataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* CALIPSODataset::regrid( const int regridMethod,
                                 cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void CALIPSODataset::write( const std::string& directory,
                            const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool CALIPSODataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool true for data such as Column_Optical_Depth,
         false for Extinction_Coefficient_532.
INTERFACE:
bool CALIPSODataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool CALIPSODataset::operator==( const CALIPSODataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool CALIPSODataset::operator!=( const CALIPSODataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: scans - Number of satellite scans.
RETURNS: size_t Number of satellite scans.
INTERFACE:
size_t CALIPSODataset::scans() const
PRE( true )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: timestamp - Timestamp of a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: Timestamp of a scan.
INTERFACE:
Timestamp CALIPSODataset::timestamp( const size_t scan ) const
PRE( IN_RANGE( scan, 0, scans() - 1 ) )
POST( result.invariant() )

-------------------------------------------------------------------------------

PURPOSE: scanGroundPoints - Ground points in a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: size_t number of ground points in the scan.
INTERFACE:
size_t CALIPSODataset::scanGroundPoints( const size_t scan ) const
PRE( IN_RANGE( scan, 0, scans() - 1 ) )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: scanVerticalPoints - Vertical points in a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: size_t number of vertical points in the scan.
INTERFACE:
size_t CALIPSODataset::scanVerticalPoints( const size_t scan ) const
PRE( IN_RANGE( scan, 0, scans() - 1 ) )
POST( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: scanBounds - Bounds of a satellite scan.
INPUTS:  const size_t scan  Index of scan.
RETURNS: const Bounds& bounds of a scan.
INTERFACE:
const Bounds& CALIPSODataset::scanBounds( const size_t scan ) const
PRE( IN_RANGE( scan, 0, scans() - 1 ) )
POST( result.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: RegriddedCALIPSODataset.h - Dataset of regridded CALIPSO satellite
         data.

TYPES:

namespace emvl {

class RegriddedCALIPSODataset : public RegriddedDataset {
public:

  // Commands:

  virtual ~RegriddedCALIPSODataset();
  RegriddedCALIPSODataset( FILE* file ); //x
  RegriddedCALIPSODataset( const std::string& fileName ); //x
  RegriddedCALIPSODataset( const RegriddedCALIPSODataset& other ); //x
  RegriddedCALIPSODataset& operator=( const RegriddedCALIPSODataset& other);//x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  virtual size_t layers() const;      // Returns layers_.
  virtual bool isSurfaceData() const; // Returns layers_ == 1.
  bool operator==( const RegriddedCALIPSODataset& other ) const;
  bool operator!=( const RegriddedCALIPSODataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~RegriddedCALIPSODataset - Destruct a RegriddedCALIPSODataset.
INTERFACE:
RegriddedCALIPSODataset::~RegriddedCALIPSODataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedCALIPSODataset - Construct a RegriddedCALIPSODataset from a
         stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedCALIPSODataset::RegriddedCALIPSODataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedCALIPSODataset - Construct a RegriddedCALIPSODataset from a
         file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid data.
INTERFACE:
RegriddedCALIPSODataset::RegriddedCALIPSODataset(const std::string& fileName)
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: RegriddedCALIPSODataset - Copy-construct a RegriddedCALIPSODataset.
INPUTS:  const RegriddedCALIPSODataset& other  Object to copy.
INTERFACE:
RegriddedCALIPSODataset::RegriddedCALIPSODataset(
                                        const RegriddedCALIPSODataset& other)
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a RegriddedCALIPSODataset.
INPUTS:  const RegriddedCALIPSODataset& other  Object to copy.
RETURNS: RegriddedCALIPSODataset& *this.
INTERFACE:
RegriddedCALIPSODataset& RegriddedCALIPSODataset::operator=(
  const RegriddedCALIPSODataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedCALIPSODataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset.
         Throws exception upon failure.
INTERFACE:
Dataset* RegriddedCALIPSODataset::regrid( const int regridMethod,
                                          cmaqGridParameters ) const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
INTERFACE:
void RegriddedCALIPSODataset::write( const std::string& directory,
                                     const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool RegriddedCALIPSODataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: layers - Number of layers.
RETURNS: size_t Number of layers.
INTERFACE:
size_t RegriddedCALIPSODataset::layers() const
POST0( result >= 1 )

-------------------------------------------------------------------------------

PURPOSE: isSurfaceData - Is this dataset only on the Earth surface?
RETURNS: bool layers_ == 1.
INTERFACE:
bool RegriddedCALIPSODataset::isSurfaceData() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedCALIPSODataset::operator==(
  const RegriddedCALIPSODataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool RegriddedCALIPSODataset::operator!=( const RegriddedCALIPSODataset& other)
  const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: PolygonDataset.h - Dataset of 2D polygon data.

TYPES:


namespace emvl {

class PolygonDataset : public Dataset {
public:

  // Commands:

  virtual ~PolygonDataset();
  PolygonDataset( FILE* file ); //x
  PolygonDataset( const std::string& fileName ); //x
  PolygonDataset( const PolygonDataset& other ); //x
  PolygonDataset& operator=( const PolygonDataset& other ); //x
  virtual Dataset* sample( const Dataset& other ) const; //x

  virtual Dataset* regrid( const int regridMethod,
                           const CMAQGridParameters&
                             cmaqGridParameters ) const; //x

  virtual void write( const std::string& directory,
                      const int format ) const; //x

  // Queries:

  virtual bool invariant() const;
  bool operator==( const PolygonDataset& other ) const;
  bool operator!=( const PolygonDataset& other ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: ~PolygonDataset - Destruct a PolygonDataset.
INTERFACE:
PolygonDataset::~PolygonDataset()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: PolygonDataset - Construct a PolygonDataset from reading a stream.
INPUTS:  const FILE* stream  Stream to read from.
NOTES:   Throws exception upon failure to read/store valid point data.
INTERFACE:
PolygonDataset::PolygonDataset( FILE* stream )
PRE0( stream )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: PolygonDataset - Construct a PolygonDataset from reading a file.
INPUTS:  const std::string& fileName  Name of file to read from.
NOTES:   Throws exception upon failure to read/store valid point data.
INTERFACE:
PolygonDataset::PolygonDataset( const std::string& fileName )
PRE0( fileName.length() )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: PolygonDataset - Copy-construct a PolygonDataset.
INPUTS:  const PolygonDataset& other  Object to copy.
INTERFACE:
PolygonDataset::PolygonDataset( const PolygonDataset& other )
PRE0( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: operator= - Assign a PolygonDataset.
INPUTS:  const PolygonDataset& other  Object to copy.
RETURNS: PolygonDataset& *this.
INTERFACE:
PolygonDataset& PolygonDataset::operator=( const PolygonDataset& other )
PRE( other.invariant() )
POST( *this == other )

-------------------------------------------------------------------------------

PURPOSE: sample - Sample other dataset at this dataset's coordinates.
INPUTS:  const Dataset& other  Dataset to sample.
RETURNS: Dataset* sampled dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* PolygonDataset::sample( const Dataset& other ) const
PRE( other.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: regrid - Regrid this dataset's data onto given grid.
INPUTS:  const int regridMethod  REGRID_NEAREST...REGRID_WEIGHTED.
         const CMAQGridParameters& cmaqGridParameters  Grid parameters.
RETURNS: Dataset* regridded dataset. Deallocate when no longer needed.
NOTES:   Throws exception upon failure.
INTERFACE:
Dataset* PolygonDataset::regrid( const int regridMethod,
  const
PRE3( IN_RANGE( regridMethod, 0, QueryParameters::REGRID_METHODS - 1 ),
      regridMethod != QueryParameters::REGRID_NONE,
      cmaqGridParameters.invariant() )
POST( IMPLIES( result, result->invariant() ) )

-------------------------------------------------------------------------------

PURPOSE: write - Write dataset to a directory file in the specified format.
INPUTS:  const std::string& directory  Name of directory to write to
                                       or, if KML format, name of KML file to
                                       append to.
         const int format              Format of file to write.
NOTES:   The name of the file is determined by the dataset name, variable, etc.
         Throws exception upon failure.
INTERFACE:
void PolygonDataset::write( const std::string& directory,
                            const int format ) const
PRE2( directory.length(),
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ) )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool PolygonDataset::invariant() const

-------------------------------------------------------------------------------

PURPOSE: operator== - Are object equal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool PolygonDataset::operator==( const PolygonDataset& other ) const
PRE( other.invariant() )

-------------------------------------------------------------------------------

PURPOSE: operator!= - Are object unequal?
RETURNS: bool true if equal, else false.
INTERFACE:
bool PolygonDataset::operator!=( const PolygonDataset& other ) const
PRE( other.invariant() )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: DatasetManager.h - Creates and owns a collection of Datasets.

TYPES:

namespace emvl {

class DatasetManager {
public:

  // Commands:

  static const char* DOSPath( const char* const path ); // DOS-form of path.
  static void checkAndSetServerHost( const char* const path );
  ~DatasetManager();
  DatasetManager( const char* const path,
                  const bool printURL,
                  void (*urlCallback)( const char* const url ) );
  Dataset* retrieveDataset( const QueryParameters& queryParameters,
                            const int timeoutSeconds = 3600 ) const; //x
  Dataset* readDataset( const std::string& fileName ) const; //x
  void retrieveFile( const std::string& remoteFileName,
                     const std::string& localFileName,
                     const int timeoutSeconds = 3600 ) const; //x
  void retrieveDatasetToFile( const QueryParameters& queryParameters,
                              const int timeoutSeconds = 3600 ) const; //x
  void appendRetrievedDataset( const QueryParameters& queryParameters,
                               const int timeoutSeconds = 3600 ); //x
  void appendDatasetFromFile( const std::string& fileName ); //x
  void append( Dataset* dataset ); //x
  void remove( const size_t index );
  void removeAll();
  void writeAll( const std::string& directory, const int format ) const; //x

  // Queries:

  static std::string webservice();
  static std::string serverHost();
  static int remoteVersion();
  bool invariant() const;
  size_t count() const;
  Dataset& operator[]( const size_t index ) const;
};

} // namespace emvl.

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: DOSPath - Get short DOS-encoded path name (without space) as required
         to invoke programs using popen() in a DOS shell.
INPUTS:  const char* const path  Path to convert to short/space-free format.
                        E.g., "C:\Documents and Settings\Todd Plessel\RSIG3D".
RETURNS: const char* DOS form. E.g., "C:\DOCUME~1\TODDPL~1\RSIG3D".
NOTES: Returned result is a pointer to static storage. Don't free.
       Not thread-safe.
       This routine calls custom DOS batch file DOSPATH.BAT in the current
       directory.
INTERFACE:
const char* DatasetManager::DOSPath( const char* const path )

-------------------------------------------------------------------------------

PURPOSE: checkAndSetServerHost - Tries to query the (faster) internal host
         used for data retrieval and if successful, it uses it for all
         subsequent data retrievals,
         otherwise it uses the (slower) external host.
INPUTS:  const char* const path  Path to command, if used.
INTERFACE:
void DatasetManager::checkAndSetServerHost( const char* const path )
PRE0( IMPLIES( command, AND3( *command, path, *path ) ) )
POST02( *server, OR2( remoteYYYYMMDD == 0, remoteYYYYMMDD > 20100101 ) )

-------------------------------------------------------------------------------

PURPOSE: webservice - URL of webservice that serves data.
RETURNS: std::string URL of computer that serves data.
NOTES:   E.g., "http://rtpmeta.epa.gov/cgi-bin/rsigserver?"
INTERFACE:
std::string DatasetManager::webservice()
PRE0( true )
POST0( ! result.empty() )

-------------------------------------------------------------------------------

PURPOSE: serverHost - Name of computer that serves data.
RETURNS: std::string Name of computer that serves data.
NOTES:   E.g., If server is "http://rtpmeta.epa.gov/cgi-bin/rsigserver?"
         then this routine returns "rtpmeta".
INTERFACE:
std::string DatasetManager::serverHost()
PRE0( true )
POST0( ! result.empty() )

-------------------------------------------------------------------------------

PURPOSE: remoteVersion - Version number of latest remote deployed RSIG3D.
RETURNS: int YYYYMMDD Date of last deployed remote version.
NOTES:   Set during constructor.
INTERFACE:
int DatasetManager::remoteVersion()
PRE0( true )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: ~DatasetManager - Destruct a DatasetManager.
INTERFACE:
DatasetManager::~DatasetManager()
PRE( true )

-------------------------------------------------------------------------------

PURPOSE: DatasetManager - Default constructor.
INPUTS:  const char* const path  Path to command, if used.
         const bool printURL  Print URL string to stdout during retrievals?
         void (*urlCallback)( const char* const url ) Optional function called
                                                      with generated WCS URL
                                                      before retrieval.
INTERFACE:
DatasetManager::DatasetManager( const char* const path,
                                void (*urlCallback)( const char* const url ) )
                               : printURL( printURL ),
                               urlCallback( urlCallback )
POST2( HTTPConnection::isInitialized(), count() == 0 )

-------------------------------------------------------------------------------

PURPOSE: retrieveFile - Retrieve a remote file from a web service and write it
         to a local file.
INPUTS:  const std::string& remoteFileName  E.g., download/RSIG_Darwin.zip.
         const std::string& localFileName   E.g., /Users/plessel/RSIG.zip.
         const int timeoutSeconds  Seconds to wait for response before
                                   giving-up in failure.
                                   Default is 3600 (1 hour). 0 is 'forever'.
NOTES:   Throws an exception upon failure.
INTERFACE:
void DatasetManager::retrieveFile( const std::string& remoteFileName,
                                   const int timeoutSeconds ) const
PRE3( remoteFileName.length(), localFileName.length(),
      timeoutSeconds >= 0 )
POST( fileSize( localFileName.c_str() ) )

-------------------------------------------------------------------------------

PURPOSE: retrieveDatasetToFile - Retrieve a Dataset from a web service using
         QueryParameters and write it to a (generated-named) file in directory
         queryParameters.directory().
INPUTS:  const QueryParameters& queryParameters  Parameters for retrieving.
         const int timeoutSeconds  Seconds to wait for response before
                                   giving-up in failure.
                                   Default is 3600 (1 hour). 0 is 'forever'.
NOTES:   Throws an exception upon failure.
INTERFACE:
void DatasetManager::retrieveDatasetToFile( const QueryParameters&
                                            const int timeoutSeconds ) const
PRE3( queryParameters.invariant(),
      queryParameters.directory().length() >= 2,
      timeoutSeconds >= 0 )
POST( fileSize( pathedFileName.c_str() ) )

-------------------------------------------------------------------------------

PURPOSE: appendRetrievedDataset - Retrieve a Dataset from a web service using
         QueryParameters and append it to the collection.
INPUTS:  const QueryParameters& queryParameters  Parameters for creating.
         const int timeoutSeconds  Seconds to wait for response before
                                   giving-up in failure.
                                   Default is 3600 (1 hour). 0 is 'forever'.
NOTES:   Throws an exception upon failure.
INTERFACE:
void DatasetManager::appendRetrievedDataset( const QueryParameters&
                                             const int timeoutSeconds )
PRE3( queryParameters.invariant(),
      queryParameters.format() == QueryParameters::XDR,
      timeoutSeconds >= 0 )
POST( count() == OLD( count ) + 1 )

-------------------------------------------------------------------------------

PURPOSE: appendDatasetFromFile - Read a Dataset from a file and append it.
INPUTS:  const std::string& fileName  File to read.
NOTES:   Throws an exception upon failure.
INTERFACE:
void DatasetManager::appendDatasetFromFile( const std::string& fileName )
PRE( fileName.length() )
POST( count() == OLD( count ) + 1 )

-------------------------------------------------------------------------------

PURPOSE: retrieveDataset - Retrieve a Dataset from a web service using
         QueryParameters.
INPUTS:  const QueryParameters& queryParameters  Parameters for web service.
         const int timeoutSeconds  Seconds to wait for response before
                                   giving-up in failure.
                                   Default is 3600 (1 hour). 0 is 'forever'.
RETURNS: Dataset* Dataset.
NOTES:   Throws an exception upon failure.
         Caller must deallocate returned result when no longer needed
         or else pass it to append() to pass ownership (and deallocation).
         Abstract Factory Pattern.
INTERFACE:
Dataset* DatasetManager::retrieveDataset( const QueryParameters&
                                          const int timeoutSeconds ) const
PRE2( queryParameters.invariant(), timeoutSeconds >= 0 )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: readDataset - Read a Dataset from a file.
INPUTS:  const std::string& fileName  Name of file to read.
RETURNS: Dataset* Dataset.
NOTES:   Throws an exception upon failure.
         Caller must deallocate returned result when no longer needed
         or else pass it to append() to pass ownership (and deallocation).
         Abstract Factory Pattern.
INTERFACE:
Dataset* DatasetManager::readDataset( const std::string& fileName ) const
PRE( fileName.length() )
POST2( result, result->invariant() )

-------------------------------------------------------------------------------

PURPOSE: append - Append a Dataset to the collection, passing ownership and
         eventual deallocation responsibility to this DatasetManager.
INPUTS:  Dataset* dataset  Dataset to append.
NOTES:   Throws an exception upon failure.
         Caller should zero argument after the call to avoid a dangling
         reference.
INTERFACE:
void DatasetManager::append( Dataset* dataset )
PRE2( dataset, dataset->invariant() )
POST2( count() == OLD( count ) + 1, dataset == 0 )

-------------------------------------------------------------------------------

PURPOSE: remove - Remove a Dataset from the collection and deallocate it.
INPUTS:  const size_t index  Index of Dataset to remove.
INTERFACE:
void DatasetManager::remove( const size_t index )
PRE( index < count() )
POST( count() == OLD( count ) - 1 )

-------------------------------------------------------------------------------

PURPOSE: removeAll - Remove and deallocate all Datasets in the collection.
INTERFACE:
void DatasetManager::removeAll()
PRE( true )
POST( count() == 0 )

-------------------------------------------------------------------------------

PURPOSE: writeAll - Write all Datasets to files.
INPUTS:  const std::string& directory  Directory to write files to.
         const int format              File format to write.
NOTES:   Throws an exception upon failure.
INTERFACE:
void DatasetManager::writeAll( const std::string& directory,
                               const int format ) const
PRE3( directory.length() >= 2,
      IN_RANGE( format, 0, QueryParameters::FILE_FORMATS - 1 ),
      format != QueryParameters::NETCDF_IOAPI )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: invariant - Class invariant.
RETURNS: bool true if valid, else false and the code is defective.
INTERFACE:
bool DatasetManager::invariant() const

-------------------------------------------------------------------------------

PURPOSE: count - Number of datasets.
RETURNS: size_t Number of datasets.
INTERFACE:
size_t DatasetManager::count() const
PRE( true )
POST( true )

-------------------------------------------------------------------------------

PURPOSE: operator[] - Access a dataset.
INPUTS:  const size_t index  Index of dataset to access.
RETURNS: Dataset& Dataset at index.
INTERFACE:
Dataset& DatasetManager::operator[]( const size_t index ) const
PRE( index < count() )
POST( result.invariant() )

