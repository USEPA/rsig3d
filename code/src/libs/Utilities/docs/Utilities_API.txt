 
LIBRARY NAME: Utilities
PRODUCTS:     Assertions.h Utilities.h DateTime.h PNGFile.h MapFile.h ImageFile.h NetCDFUtilities.h Shapefile.h KMLFile.h libUtilities.debug.a libUtilities.a
USES LIBS:    -lnetcdf -lshp -lGPC -lPNG -lz -lm -L../../../lib/Darwin 
 
-------------------------------------------------------------------------------

PURPOSE: Utilities.h - Declare utility routines.

MACROS:

/* Value clamped to range [low, high]. */

#define CLAMPED_TO_RANGE( value, low, high ) \
((value) < (low) ? (low) : (value) > (high) ? (high) : (value))

/* Allocate then zero-out the memory: */

#define NEW( type, count ) ( (type*) newMemory( (count), sizeof (type) ) )
extern void* newMemory( size_t count, size_t bytesEach );

/* Deallocate the memory and zero the pointer: */

#define FREE( p ) ( ( (p) ? free(p) : (void) 0 ), (p) = 0 )

TYPES:

enum { MINIMUM, MAXIMUM };
enum { LONGITUDE, LATITUDE };

enum { BYTE_TYPE, UINT16_TYPE, FLOAT_TYPE, DOUBLE_TYPE, GRID_DATA_TYPES };

#define IS_VALID_GRID_DATA_TYPE(type) ((type) >= 0 && (type) < GRID_DATA_TYPES)

enum { HOURLY, DAILY, MONTHLY, YEARLY }; /* Timestep of data. */

#define IS_VALID_TIMESTEP_TYPE(type) IN5((type), HOURLY, DAILY, MONTHLY,YEARLY)

typedef double Bounds[ 2 ][ 2 ]; /* [ LONGITUDE LATITUDE ][MINIMUM MAXIMUM].*/

typedef struct { float r, g, b; } Color;

typedef Color (*DataColor)( double, double, double ); /* Color function. */
typedef Color (*TextColor)( const char* );

#ifdef RGB
#undef RGB
#endif

typedef struct { unsigned char r, g, b; const char* s; } RGB;

typedef char LongName[ 63 + 1 ];
typedef char Name[  31 + 1 ];
typedef char Units[ 15 + 1 ];

typedef void (*ForEachFileCallback)( const char* const fileName, void* data );

FUNCTIONS:

/* Numeric routines: */

extern int isNan( const double value );

extern int isNanFreeF( const float data[], const size_t count );

extern int isNanFree( const double data[], const size_t count );


/* Geographic geometry routines: */

extern int isValidLongitudeLatitude( const double longitude,
                                     const double latitude );

extern int isValidBounds( const Bounds bounds );

extern int boundsOverlap( const Bounds a, const Bounds b );

extern double degreesPerPixel( const Bounds bounds, int width, int height );

extern double widthInMeters( const Bounds bounds );

extern void computeArrowVectorCoordinates( const double longitude,
                                           const double latitude,
                                           const double x,
                                           const double y,
                                           const double degreesPerPixel,
                                           const double pixelsPerUnitLength,
                                           double* const point0X,
                                           double* const point0Y,
                                           double* const point1X,
                                           double* const point1Y,
                                           double* const point2X,
                                           double* const point2Y,
                                           double* const point3X,
                                           double* const point3Y );

/* Color routines: */

extern int isValidColor( Color color );

extern RGB makeRGB( unsigned char r, unsigned char g, unsigned char b,
                    const char* s );

extern Color dataColor( double value, double minimum, double maximum );
extern Color lexicographicTextColor( const char* text );


/* String routines: */

extern int wordCount( const char* string );
extern void lowercase( char string[] );
extern int matchesWord( const char* word, const char* const words );

extern int indexOfString( const char* string, const char* const strings[],
                          int count );

extern void copyPaddedString( char* output, const char* input,
                              const int length, const int uppercase );


/* File routines: */

extern int fileExists( const char* fileName );
extern size_t fileSize( const char* fileName );
extern char* readFile( const char* name, size_t* length, size_t* lines );
extern size_t controlMToSpace( char* string );
extern int copyFile( const char* inputFileName, const char* outputFileName );

extern int copyFileBytes( FILE* inputFile, const char* outputFileName,
                          size_t bytes );

extern int streamBytesToFile( FILE* stream, const char* outputFileName );

extern int streamFile( const char* fileName );

extern int directoryExists( const char* name );

extern void removeAllFiles( const char* name );

extern void removeMatchedFiles( const char* const directoryName,
                                const char* const startsWith,
                                const char* const endsWith );

extern void copyFiles( const char* const fromDirectory,
                       const char* const toDirectory,
                       const char* const startsWith,
                       const char* const endsWith );

extern void forEachFile( const char* const directory,
                         const char* const startsWith,
                         const char* const endsWith,
                         ForEachFileCallback callback,
                         void* callbackData );

extern void directoryListing( const char* directory, const char* extensions,
                              int size, char buffer[] );

extern const char* homeDirectory( void );

#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: newMemory - Allocate memory (called by NEW() macro).
INPUTS:  size_t count          Number of items.
         size_t bytesEach      Number of bytes per item.
RETURNS: void* block of memory of size count * sizeEach or 0 if failed and
         a failure message is printed to stderr.
INTERFACE:
void* newMemory( size_t count, size_t bytesEach  )
PRE02( bytesEach > 0, count > 0 )

-------------------------------------------------------------------------------

PURPOSE: isNan - Is value Not a Number?
INPUTS:  const double value  Value to check.
RETURNS: int 1 if NaN, else 0.
INTERFACE:
int isNan( const double value )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isNanFreeF - Does array of floats contain no NaNs?
INPUTS:  const float data[ count ]  Values to check.
         const size_t count         Number of values in array.
RETURNS: int 1 if NaN, else 0.
INTERFACE:
int isNanFreeF( const float data[], const size_t count )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isNanFree - Does array of doubles contain no NaNs?
INPUTS:  const double data[ count ]  Values to check.
         const size_t count          Number of values in array.
RETURNS: int 1 if NaN, else 0.
INTERFACE:
int isNanFree( const double data[], const size_t count )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidLongitudeLatitude - Is longitude, latitude a valid point?
INPUTS:  const double longitude  Longitude to check.
         const double latitude   Latitude  to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidLongitudeLatitude( const double longitude,
                              const double latitude )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidBounds - Is bounds a valid lon-lat rectangle?
INPUTS:  const Bounds bounds  Bounds to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidBounds( const Bounds bounds )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: boundsOverlap - Do bounds overlap?
INPUTS:  const Bounds a  a[ LONGITUDE, LATITUDE ][ MINIMUM, MAXIMUM ].
         const Bounds b  b[ LONGITUDE, LATITUDE ][ MINIMUM, MAXIMUM ].
RETURNS: int 1 if they overlap, else 0.
INTERFACE:
int boundsOverlap( const Bounds a, const Bounds b )
PRE02( isValidBounds( a ), isValidBounds( b ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: degreesPerPixel - Degrees lon-lat per screen pixel.
INPUTS:  const Bounds bounds  Bounds of lon-lat window.
         int width            Width  of window in screen pixels.
         int height           Height of window in screen pixels.
RETURNS double degrees of lon-lat per screen pixel (maximum of lon/lat).
INTERFACE:
double degreesPerPixel( const Bounds bounds, int width, int height )
PRE03( isValidBounds( bounds ), width > 0, height > 0)
POST0( result > 0.0 )
POST0( IN_RANGE( result, MINIMUM_DEGREES_PER_PIXEL, 360.0 ) )

-------------------------------------------------------------------------------

PURPOSE: widthInMeters - Width of lon-lat window in meters.
INPUTS:  const Bounds bounds  Lon-lat bounds of window.
RETURNS: double width of (center line of) window in meters.
INTERFACE:
double widthInMeters( const Bounds bounds )
PRE0( isValidBounds( bounds ) )
POST0( result > 0.0 )

-------------------------------------------------------------------------------

PURPOSE: computeArrowVectorCoordinates - Compute coordinates of arrow vector.
INPUTS:  const double longitude           Longitude of base of arrow.
         const double latitude            Latitude of base of arrow.
         const double x                   X-component of arrow.
         const double y                   Y-component of arrow.
         const double degreesPerPixel     Degrees longitude per viewport pixel.
         const double pixelsPerUnitLength Viewport pixels per unit vector.
OUTPUTS: double* const point0X            X-coordinate of arrow base vertex.
         double* const point0Y            Y-coordinate of arrow base vertex.
         double* const point1X            X-coordinate of arrow tip vertex.
         double* const point1Y            Y-coordinate of arrow tip vertex.
         double* const point2X            X-coordinate of arrow head top vertex
         double* const point2Y            Y-coordinate of arrow head top vertex
         double* const point3X            X-coordinate of arrow head bot vertex
         double* const point3Y            Y-coordinate of arrow head bot vertex
INTERFACE:
void computeArrowVectorCoordinates( const double longitude,
                                    double* const point3Y )
PRE013( isValidLongitudeLatitude( longitude, latitude ),
        ! isNan( x ),
        ! isNan( y ),
        IN_RANGE( degreesPerPixel, 1e-8, 1.0 ),
        IN_RANGE( pixelsPerUnitLength, 1.0, 100.0 ),
        point0X, point0Y, point1X, point1Y, point2X, point2Y,
        point3X, point3Y )
POST05( *point0X == longitude, *point0Y == latitude,
        isValidLongitudeLatitude( *point1X, *point1Y ),
        isValidLongitudeLatitude( *point2X, *point2Y ),
        isValidLongitudeLatitude( *point3X, *point3Y ) )

-------------------------------------------------------------------------------

PURPOSE: isValidColor - Is Color in the unit RGB cube?
INPUTS:  Color color  Color to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidColor( Color color )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: makeRGB - Initialize and return an RGB.
INPUTS:  unsigned char r  Red component.
         unsigned char g  Green component.
         unsigned char b  Blue component.
         const char* s    Name component.
RETURNS: RGB initialized to the given components.
INTERFACE:
RGB makeRGB(unsigned char r, unsigned char g, unsigned char b, const char* s)

-------------------------------------------------------------------------------

PURPOSE: dataColor - Map value in range [minimum, maximum] to
         RGB color cube range: blue-cyan-green-yellow-red.
INPUTS:  double value    Data value to map.
         double minimum  Minimum value for data.
         double maximum  Maximum value for data.
RETURNS: Color mapped value.
INTERFACE:
Color dataColor( double value, double minimum, double maximum )
PRE03( ! isNan( value ), ! isNan( minimum ), ! isNan( maximum ) )
POST0( isValidColor( result ) )

-------------------------------------------------------------------------------

PURPOSE: lexicographicTextColor - Map text to Color based on first letter
         compared to 'a'..'z' or '0'..'9'.
INPUTS:  const char* text  Text to map.
RETURNS: Color mapped value.
INTERFACE:
Color lexicographicTextColor( const char* text )
PRE0( text )
POST0( isValidColor( result ) )

-------------------------------------------------------------------------------

PURPOSE: wordCount - Count number of whitespace-separated printable words
         in a string.
INPUTS:  const char* string  String to count.
RETURNS: int number of words in string.
INTERFACE:
int wordCount( const char* string )
PRE0( string )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: lowercase - Convert a string to lowercase.
INPUTS:  char string[]  String to convert.
OUTPUTS: char string[]  Lowercase string.
INTERFACE:
void lowercase( char string[] )
PRE0( string )

-------------------------------------------------------------------------------

PURPOSE: matchesWord - Does word appear in space-delimited words?
INPUTS:  const char* word   String to search for.
         const char* words  String of space-delimited words to search.
RETURNS: int 1 if found, else 0.
INTERFACE:
int matchesWord( const char* word, const char* const words )
PRE06( word, *word, ! strchr( word, ' ' ),
       words, *words, strchr( words, ' ' ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: indexOfString - Index of string in strings[] or -1 if not present.
INPUTS:  const char* string           String to search for.
         const char* const strings[]  Strings to search.
         int count                    Size of strings[].
RETURNS: int index of string in strings[], else -1 if not present.
INTERFACE:
int indexOfString(const char* string, const char* const strings[], int count)
PRE08( string, *string, strings, strings[ 0 ], *strings[ 0 ],
       count > 0, strings[ count - 1 ], *strings[ count - 1 ] )
POST0( OR2( result == -1,
            AND2( result >= 0,
                  strcmp( string, strings[ result ] ) == 0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: copyPaddedString - Copy length-characters of input to output, then
         pad end with spaces
INPUTS:  const char* string   String  to check, e.g., "WN_85_%"".
         const char* pattern  Pattern to match, e.g., "WN_%02d_%%".
RETURNS: int 1 if matched, else 0.
INTERFACE:
void copyPaddedString( char* output, const char* input,
                       const int length, const int uppercase )
PRE05( output, input, *input, length > 0, IS_BOOL( uppercase ) )
POST0( (int) ( strlen( output ) ) == length )

-------------------------------------------------------------------------------

PURPOSE: copyFile - Copy a file.
INPUTS:  const char* inputFileName   Pathed name of file to copy.
         const char* outputFileName  Created file.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int copyFile( const char* inputFileName, const char* outputFileName )
PRE03( inputFileName, outputFileName, *outputFileName )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: copyFileBytes - Copy a file's bytes to another file.
INPUTS:  FILE* inputFile             File to copy.
         const char* outputFileName  Created file.
         size_t bytes                Bytes to read and write.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int copyFileBytes( FILE* inputFile, const char* outputFileName, size_t bytes)
PRE04( inputFile, outputFileName, *outputFileName, bytes > 0 )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: streamBytesToFile - Copy all of a stream's bytes to a file.
INPUTS:  FILE* stream                Stream to read.
         const char* outputFileName  Created file.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int streamBytesToFile( FILE* stream, const char* outputFileName )
PRE03( stream, outputFileName, *outputFileName )

-------------------------------------------------------------------------------

PURPOSE: streamFile - Stream bytes of a file to stdout.
INPUTS:  const char* fileName  Name of file to stream.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int streamFile( const char* fileName )
PRE02( fileName, *fileName )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: fileExists - Does the named file exist?
INPUTS:  const char* name  Name of file to examine.
RETURNS: int 1 if the file exists, else 0.
INTERFACE:
int fileExists( const char* name )
PRE02( name, *name )

-------------------------------------------------------------------------------

PURPOSE: fileSize - Determine size of named file.
INPUTS:  const char* name  Name of file to examine.
RETURNS: size_t Size, in bytes, of named file, else 0 if failed.
INTERFACE:
size_t fileSize( const char* name )
PRE02( name, *name )

-------------------------------------------------------------------------------

PURPOSE: readFile - Read named file into memory and return it as an allocated
         string.
INPUTS:  const char* name  Name of file to examine.
OUTPUTS: size_t* length    Length of string.
         size_t* lines     Number of lines (\n) in string.
RETURNS: char* string contents of file
         (with any '\r' characters converted to ' '),
         else 0 if failed and a message is printed to stderr.
INTERFACE:
char* readFile( const char* name, size_t* length, size_t* lines )
PRE03( name, length, lines )
POST0( IMPLIES_ELSE( result,
                     AND2( *length > 0, *lines > 0 ),
                     AND2( *length == 0, *lines == 0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: controlMToSpace - Convert any '\r' characters to ' '.
INPUTS:  char* string  String to filter.
OUTPUTS: char* string  Filtered string.
RETURNS: size_t number of lines (\n) in string.
INTERFACE:
size_t controlMToSpace( char* string )
PRE0( string )
POST0( ! strchr( string, '\r' ) )

-------------------------------------------------------------------------------

PURPOSE: removeAllFiles - Remove all files in a directory.
INPUTS:  const char* name  Name of directory to remove files from.
INTERFACE:
void removeAllFiles( const char* name )
PRE02( name, *name )

-------------------------------------------------------------------------------

PURPOSE: removeMatchedFiles - Remove matched files in a directory.
INPUTS:  const char* const directoryName Name of directory to remove files from
         const char* const startsWith Optional matching file name start.
         const char* const endsWith   Optional matching file name end.
INTERFACE:
void removeMatchedFiles( const char* const directoryName,
                         const char* const endsWith )
PRE04( directoryName,
       *directoryName,
       IMPLIES( startsWith, *startsWith ),
       IMPLIES( endsWith, *endsWith ) )

-------------------------------------------------------------------------------

PURPOSE: copyFiles - Copies matched files in a directory to another directory.
INPUTS:  const char* const fromDirectory  Name of directory to copy files from.
         const char* const toDirectory    Name of directory to copy files to.
         const char* const startsWith     Optional matching file name start.
         const char* const endsWith       Optional matching file name end.
INTERFACE:
void copyFiles( const char* const fromDirectory,
                const char* const endsWith )
PRE07( fromDirectory, *fromDirectory, toDirectory, *toDirectory,
       strcmp( fromDirectory, toDirectory ),
       IMPLIES( startsWith, *startsWith ),
       IMPLIES( endsWith, *endsWith ) )

-------------------------------------------------------------------------------

PURPOSE: forEachFile - Calls callback for each matched file in a directory.
INPUTS:  const char* const directory  Name of directory to check for files.
         const char* const startsWith     Optional matching file name start.
         const char* const endsWith       Optional matching file name end.
         ForEachFileCallback callback     Called with each matched file name.
         void* callbackData               Second argument to callback.
INTERFACE:
void forEachFile( const char* const directory,
                  void* callbackData )
PRE05( directory,
       *directory,
       IMPLIES( startsWith, *startsWith ),
       IMPLIES( endsWith, *endsWith ),
       callback )

-------------------------------------------------------------------------------

PURPOSE: directoryExists - Does directory exist?
INPUTS:  const char* name  Name of directory to remove files from.
INTERFACE:
int directoryExists( const char* name )
PRE02( name, *name )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: directoryListing - List files in a directory that end with one of
         the given extensions and are dated today.
INPUTS:  const char* directory   Name of directory.
         const char* extensions  Optional: file extensions to filter by.
                                 E.g., "shx shp txt".
         int size                Size of buffer[].
OUTPUTS: char buffer[ size ]     Result containing formatted columns:
                                 bytes hh:mm name
                                 sorted by file name.
NOTES:   Omits file names that begin with dot (.).
INTERFACE:
void directoryListing( const char* directory, const char* extensions, int size,
                       char buffer[] )
PRE04( directory, *directory, size > 0, buffer )

-------------------------------------------------------------------------------

PURPOSE: homeDirectory - Name of user's home directory.
RETURNS: const char* Name of user's home directory. Examples:
         "/Users/plessel"
         "C:\Documents and Settings\tplessel"
         "."
INTERFACE:
const char* homeDirectory( void )
POST02( *result, result[ strlen( result ) - 1 ] != '/' )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Assertions.h - Defines assertion macros for optionally verifying
         routine preconditions, postconditions and class invariants -
         as inspired by Eiffel's 'Design By Contract'.
         http://www.elj.com/eiffel/dbc/

NOTES:   This implementation is based on (uses) the ISO/ANSI Standard C/C++
         Pre-processor (cpp).

         Macros defined include:

           assert_static(c)             Assert condition at compile time.
                                        Note this does not generate code at
                                        runtime and therefore is unaffected by
                                        the various assertion level options
                                        defined below.

           PRE0(c), PRE02(c1,c2), ...   Assert precondition(s)
           POST0(c), POST02(c1,c2), ... Assert postcondition(s)
           PRE(c),  PRE2(c1,c2),  ...   Assert invariant and precondition(s)
           POST(c), POST2(c1,c2), ...   Assert invariant and postcondition(s)

         There are three levels of assertion checking and they are
         specified on the command line or in the Makefile:

           (default)            - Enables  all assertion checking.
           -DNO_ASSERTIONS      - Disables all assertion checking.
           -DPRECONDITIONS_ONLY - Enables PRE(c) checking only.

         Specifying -DNO_INVARIANT during pre-processing causes the PRE() and
         POST() macros to NOT also assert the class invariant, otherwise, by
         default, they invoke a function assumed to be in local (module)
         scope with the following signature:

         If C++:

           virtual bool invariant() const;

         If C:

           int invariant( self );

         Use -DINVARIANT_SELF=THIS to rename the first argument of each
         module call to 'THIS' instead of the default, 'self'.

         In C++ constructors or code in headers or any non-ADT code,
         use PRE0, PRE02, POST0, ..., macros to avoid invariant evaluation.

         Additional assertion checking:

           CHECK(c), CHECK2(c1,c2),       Assert arbitrary condition(s)
                                          Useful to insert in the middle of
                                          a long routine to verify
                                          intermediate results.

           CHECKING(s)                    Includes arbitrary statements, s,
                                          only when CHECK macros are
                                          enabled. This is useful for
                                          including/removing variables and
                                          routines whose only use occurs
                                          within CHECK/POST macros.

         Similaraly, there are two levels of debugging:

           (default)            - Disables DEBUG(s) statements.
           -DDEBUGGING          - Enables  DEBUG(s) statements.

           DEBUG(s)                       Add optional debug statements
                                          independent of assertions.

         Assertions support macros include:

           OLD(variable)                  For referring to previous values.
           REMEMBER(type,variable)        Required if OLD() is used...
           REMEMBER_F(type,function_name) Same as above but for functions.


         Macros for boolean expressions. The functional forms e.g.,

           IMPLIES_ELSE( found,
                         AND2( index > 0, items( index ) == sought_item ),
                         index == -1 )

         have been shown to be more readable than the infix-operator form:

           found && ( index > 0 && items( index ) == sought_item )
           || ! found && index == -1


           IMPLIES(p,c)                   Logical implication.
           IMPLIES_ELSE(p,c1,c2)          p -> c1 or !p ->c2
           AND2(c1,c2), AND3(c1,c2,c3)... Logical and.
           OR2(c1,c2),  OR3(c1,c2,c3)...  Logical or.
           XOR2(c1,c2), XOR3(c1,c2,c3)... Logical exclusive-or.
                                          XORn(c1,c2,...) is 1 iff exactly
                                          one of the conditions is true.
                                          Not short-circuited.
           IN3(x,a,b),  IN4(x,a,b,c)...   Set membership: x in {a,b}?
           IN_RANGE(x,low,high)           x in [low,high]?
           IS_BOOL2(a,b), ...             Each in {0, 1}?
           NON_ZERO2(a,b), ...            Each != 0?
           IS_ZERO2(a,b), ...             Each == 0?
           GT_ZERO2(a,b), ...             Each >  0?
           GE_ZERO2(a,b), ...             Each >= 0?


         If any asserted condition evaluates to false at runtime then
         the program will display a message such as:

           Assertion failed: PRE: index >= 0, file Test.c, line 44

         And then abort() producing a core file used for debugging.
         For example, to debug a bad call to a routine (violated
         pre-condition):

           dbx Test
           dbx> up 4
           (this is the assertion line)
           dbx> up
           (this is the bad call line)

         Checking preconditions or postconditions imply checking the
         invariant also. If there is no precondition or postcondition then
         use PRE( true ) and POST( true ) so that the invariant is still
         checked. See search() below for an example of this.

         The invariant should be a non-pure virtual function
         (one with a body that at least returns true) so that it can be
         called by decendents. See invariant() below.

         First C++ Example:

         $ ls
         Assertions.h        assertions_test.C
         $ cat assertions_test.C

         // assertions_test.C - demonstrate Assertions.h macros.

         #include <iostream> // For std::cout, std::endl.

         #include <Assertions.h> // For PRE*(), POST*(), CHECK*(), IN_RANGE().

         class Counter {
         private:
           int value;   // Current value of counter.
           int maximum; // Maximum value allowed.
         public:

           ~Counter() {
             PRE( true ); // Use PRE( true ) so that invariant() is evaluated.
             value = maximum = 0;
           }

           Counter( int maximum_value = 10 )
             : value( 1 ), maximum( maximum_value ) {
             POST2( count() == 1, limit() == maximum_value ); // 'anded' args.
           }

           int limit() const {
             PRE( true );
             const int result = maximum;
             POST( result > 0 );
             return result;
           }

           int count() const {
             PRE( true );
             const int result = value;
             POST( IN_RANGE( result, 1, limit() ) ); // IN_RANGE is inclusive.
             return result;
           }

           void increment() {
             PRE( count() < limit() );
             REMEMBER_F( int, count ); // declares 'int count_old_ = count();'
             ++value;
             POST( count() == OLD( count ) + 1 );
           }

           void decrement() {
             PRE( count() > 1 );
             REMEMBER_F( int, count );
             --value;
             POST( count() == OLD( count ) - 1 );
           }

           // Class invariant: AND2(limit() > 0, IN_RANGE(count(), 1, limit()))
           bool invariant() const {
             const bool result = AND2( maximum > 0,
                                       IN_RANGE( value, 1, maximum ) );
             return result;
           }
         };

         int main() {
           assert_static( sizeof (long long) == 8 );
           assert_static( sizeof (double) == 8 );
           Counter c;
           std::cout << "c.count() = " << c.count() << std::endl;
           std::cout << "c.limit() = " << c.limit() << std::endl;
           c.increment();
           CHECK( c.count() == 2 );
           c.increment();
           CHECK( c.count() == 3 );
           c.decrement();
           CHECK( c.count() == 2 );
           std::cout << "c.count() = " << c.count() << std::endl;
           c.decrement();
           CHECK( c.count() == 1 );
           c.decrement(); // Defect: decrement when count() is 1.
           std::cout << "c.count() = " << c.count() << std::endl;
           return 0;
         }

         $ CC -LANG:std -I. -g -o assertions_test assertions_test.C
         $ assertions_test
         c.count() = 1
         c.limit() = 10
         c.count() = 2
         Assertion failed: PRE: count() > 1, file assertions_test.C, line 51
         Abort (core dumped)
         $ dbx assertions_test
         dbx version 7.3.1 68542_Oct26 MR Oct 26 2000 17:50:34
         Core from signal SIGABRT: Abort (see abort(3c))
         (dbx) up 4
         Counter::decrement:  51  PRE( count() > 1 );
         (dbx) up
         ::main:  77  c.decrement(); // Defect: decrement when count() is 1.
         (dbx) quit
         $ \rm core
         $ CC -LANG:std -I. -DNO_ASSERTIONS -O \
              -o assertions_test assertions_test.C
         $ assertions_test
         c.count() = 1
         c.limit() = 10
         c.count() = 2
         c.count() = 0


         Second C++ example with inheritance:

           // Array10.h:

           class Array10 : public Array, public FixedSize {
           private:
             int n;
             double a[ 10 ];
           public:
             virtual bool invariant() const; // This is called by PRE/POST().
             bool insert( int i, double x ); // Insert x at a[ i ].
             int search(  double x ); // Return index of x in a[] or -1.
             // ...
           };

           // Array10.C:

           #include <Assertions.h>
           #include <Array10.h>

           bool Array10::invariant() const {
             // Should be written to call each of the immediate parent's
             // invariant() also (no variance):

             return AND3( Array::invariant(), FixedSize::invariant(),
                          IN_RANGE( n, 0, 10 ) );
                          // The IN_RANGE() part is this class's invariant.
           }

           void Array10::insert( int i, double x ) {
             PRE2( 0 <= i, i <= n );
             REMEMBER( int, n ); // REMEMBER() here if using OLD() in POST().

             // ...
             a[ i ] = x;
             // ...

             POST2( a[ i ] == x, n == OLD( n ) + 1 ); // Also invariant.
           }

           int Array10::search( double x ) {
             PRE( true ); // Must check the invariant.
             int result = -1;
             size_t i;

             for ( i = 0; i < n; ++i ) if ( a[ i ] == x ) break;

             if ( i < n ) result = i;

             POST( IMPLIES( result != -1, a[ result ] == x ) );
             return result;
           }

           The CHECK() macro can be used to assert a condition without
           implying the class invariant - e.g., inside a helper routine.
           The DEBUG() macro is used to optionally insert any statements.

           Examples:

           int X::helper( int i ) {
             CHECK( i > 0 );
             DEBUG( cout << "X::helper( int i = " << i << " )" << endl; )
             // ...
             CHECK( result > 0 );
             DEBUG( cout << "X::helper() returning " << result << endl; )
             return result;
           }

           When compiling with C, the PRE*() macros declare and initialize
           a variable 'unused_assert_' that is otherwise not used.
           This is done to enable the PRE*() macros to be placed at the
           beginning of the routine (just like C++). For example:

           int half_fast_routine( int value ) {
             PRE( value >= 0 );
             const int result = value >> 1;
             POST2( result >= 0, result + result <= value );
             return result;
           }

           With or without assertions enabled, the semi-colon following PRE()
           and before the declaration of result requires that PRE() be some
           kind of declaration. When assertions are enabled it declares a
           local unused variable unused_assert_.
           When assertions are disabled, it declares 'extern int errno'
           (a global variable in the Standard C Library) which does not cause
           any code-generation. Groovy.


MACROS:

/*
 * Define a compile-time assertion that only accepts compile-time constant
 * expressions and if false results in a compile-time error and if true
 * generates no instructions or warnings.
 *
 * Example usage: assert_static( sizeof (long long) == 8 );
 */

#define assert_static(a) extern int unused_assert_static_[ (a) ? 1 : -1 ]


/*
 * Define a custom assert-like macro that includes a prefix tag that identifies
 * the assertion type (PRE, POST, CHECK).
 * This macro calls the "Standard" C Library function void __assert().
 */

#ifndef NO_ASSERTIONS

#if defined( __MINGW32__ ) || defined( __MINGW64__ )
#define ASSERT2_(prefix,expression) \
((void) ((expression) ? 0 \
:(_assert(#prefix": "#expression,__FILE__,__LINE__), 0)))
#elif defined( _WIN32 )
#define ASSERT2_(prefix,expression) \
((void) ((expression) ? 0 \
:(_assert(__FILE__,__LINE__,#prefix": "#expression), 0)))
#elif defined(__CYGWIN__)
#define ASSERT2_(prefix,expression) \
((void) ((expression) ? 0 \
:(__assert(__FILE__,__LINE__,#prefix": "#expression), 0)))
#else
#define ASSERT2_(prefix,expression) \
((void) ((expression) ? 0 \
:(__assert(#prefix": "#expression,__FILE__,__LINE__), 0)))
#endif

#define PRE_ASSERT_(expression) ASSERT2_(PRE,expression)
#define POST_ASSERT_(expression) ASSERT2_(POST,expression)
#define CHECK_ASSERT_(expression) ASSERT2_(CHECK,expression)
#else
#define ASSERT2_(unused1,unused2)
#define PRE_ASSERT_(unused)
#define POST_ASSERT_(unused)
#define CHECK_ASSERT_(unused)
#endif


#ifdef NO_ASSERTIONS

/******************************* NO_ASSERTIONS *******************************/

/* Disable all checking. */

#define CHECK(c)
#define CHECK2(c1,c2)
#define CHECK3(c1,c2,c3)
#define CHECK4(c1,c2,c3,c4)
#define CHECK5(c1,c2,c3,c4,c5)
#define CHECK6(c1,c2,c3,c4,c5,c6)
#define CHECK7(c1,c2,c3,c4,c5,c6,c7)
#define CHECK8(c1,c2,c3,c4,c5,c6,c7,c8)
#define CHECK9(c1,c2,c3,c4,c5,c6,c7,c8,c9)
#define CHECK10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10)
#define CHECK11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11)
#define CHECK12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12)
#define CHECK13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13)
#define CHECK14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14)
#define CHECK15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15)
#define CHECK16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16)
#define CHECK17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17)
#define CHECK18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18)

#define CHECK19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19)

#define CHECK20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20)

#define CHECK21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21)

#define CHECK22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22)

#define CHECK23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23)

#define CHECK24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24)

#define CHECK25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25)

#define CHECK26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26)

#define CHECK27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27)

#define CHECK28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28)

#define CHECK29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29)

#define CHECK30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30)

/* An external variable declaration is needed in C so pre can be first line. */

#ifdef __cplusplus
#define NOP_DECLARATION_
#else
#define NOP_DECLARATION_ extern int errno
#endif

#define PRE(c1) NOP_DECLARATION_
#define PRE2(c1,c2) NOP_DECLARATION_
#define PRE3(c1,c2,c3) NOP_DECLARATION_
#define PRE4(c1,c2,c3,c4) NOP_DECLARATION_
#define PRE5(c1,c2,c3,c4,c5) NOP_DECLARATION_
#define PRE6(c1,c2,c3,c4,c5,c6) NOP_DECLARATION_
#define PRE7(c1,c2,c3,c4,c5,c6,c7) NOP_DECLARATION_
#define PRE8(c1,c2,c3,c4,c5,c6,c7,c8) NOP_DECLARATION_
#define PRE9(c1,c2,c3,c4,c5,c6,c7,c8,c9) NOP_DECLARATION_
#define PRE10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) NOP_DECLARATION_
#define PRE11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) NOP_DECLARATION_
#define PRE12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) NOP_DECLARATION_
#define PRE13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) NOP_DECLARATION_
#define PRE14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) NOP_DECLARATION_

#define PRE15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
 NOP_DECLARATION_

#define PRE16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
 NOP_DECLARATION_

#define PRE17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
 NOP_DECLARATION_

#define PRE18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
 NOP_DECLARATION_

#define PRE19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) NOP_DECLARATION_

#define PRE20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) NOP_DECLARATION_

#define PRE21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) NOP_DECLARATION_

#define PRE22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) NOP_DECLARATION_

#define PRE23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) NOP_DECLARATION_

#define PRE24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) NOP_DECLARATION_

#define PRE25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) NOP_DECLARATION_

#define PRE26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) NOP_DECLARATION_

#define PRE27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) NOP_DECLARATION_

#define PRE28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) NOP_DECLARATION_

#define PRE29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) NOP_DECLARATION_

#define PRE30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) NOP_DECLARATION_

#define PRE0 PRE
#define PRE02 PRE2
#define PRE03 PRE3
#define PRE04 PRE4
#define PRE05 PRE5
#define PRE06 PRE6
#define PRE07 PRE7
#define PRE08 PRE8
#define PRE09 PRE9
#define PRE010 PRE10
#define PRE011 PRE11
#define PRE012 PRE12
#define PRE013 PRE13
#define PRE014 PRE14
#define PRE015 PRE15
#define PRE016 PRE16
#define PRE017 PRE17
#define PRE018 PRE18
#define PRE019 PRE19
#define PRE020 PRE20
#define PRE021 PRE21
#define PRE022 PRE22
#define PRE023 PRE23
#define PRE024 PRE24
#define PRE025 PRE25
#define PRE026 PRE26
#define PRE027 PRE27
#define PRE028 PRE28
#define PRE029 PRE29
#define PRE030 PRE30

#define POST CHECK
#define POST2 CHECK2
#define POST3 CHECK3
#define POST4 CHECK4
#define POST5 CHECK5
#define POST6 CHECK6
#define POST7 CHECK7
#define POST8 CHECK8
#define POST9 CHECK9
#define POST10 CHECK10
#define POST11 CHECK11
#define POST12 CHECK12
#define POST13 CHECK13
#define POST14 CHECK14
#define POST15 CHECK15
#define POST16 CHECK16
#define POST17 CHECK17
#define POST18 CHECK18
#define POST19 CHECK19
#define POST20 CHECK20
#define POST21 CHECK21
#define POST22 CHECK22
#define POST23 CHECK23
#define POST24 CHECK24
#define POST25 CHECK25
#define POST26 CHECK26
#define POST27 CHECK27
#define POST28 CHECK28
#define POST29 CHECK29
#define POST30 CHECK30

#define POST0 CHECK
#define POST02 CHECK2
#define POST03 CHECK3
#define POST04 CHECK4
#define POST05 CHECK5
#define POST06 CHECK6
#define POST07 CHECK7
#define POST08 CHECK8
#define POST09 CHECK9
#define POST010 CHECK10
#define POST011 CHECK11
#define POST012 CHECK12
#define POST013 CHECK13
#define POST014 CHECK14
#define POST015 CHECK15
#define POST016 CHECK16
#define POST017 CHECK17
#define POST018 CHECK18
#define POST019 CHECK19
#define POST020 CHECK20
#define POST021 CHECK21
#define POST022 CHECK22
#define POST023 CHECK23
#define POST024 CHECK24
#define POST025 CHECK25
#define POST026 CHECK26
#define POST027 CHECK27
#define POST028 CHECK28
#define POST029 CHECK29
#define POST030 CHECK30

#define CHECKING(s)

#define OLD(variable)
#define REMEMBER(type,variable) NOP_DECLARATION_
#define REMEMBER_F(type,function_name) NOP_DECLARATION_


#elif defined(PRECONDITIONS_ONLY)

/***************************** PRECONDITIONS_ONLY ****************************/

/* Enable pre-condition checking only. */

#ifdef __cplusplus

#define PRE(c) PRE_ASSERT_(c)

#define PRE2(c1,c2) PRE_ASSERT_(c1),PRE_ASSERT_(c2)

#define PRE3(c1,c2,c3) PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3)

#define PRE4(c1,c2,c3,c4) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4)

#define PRE5(c1,c2,c3,c4,c5) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),PRE_ASSERT_(c5)

#define PRE6(c1,c2,c3,c4,c5,c6) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6)

#define PRE7(c1,c2,c3,c4,c5,c6,c7) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7)

#define PRE8(c1,c2,c3,c4,c5,c6,c7,c8) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8)

#define PRE9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9)

#define PRE10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10)

#define PRE11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11)

#define PRE12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),
PRE_ASSERT_(c12)

#define PRE13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13)

#define PRE14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14)

#define PRE15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15)

#define PRE16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16)

#define PRE17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17)

#define PRE18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18)

#define PRE19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19)

#define PRE20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20)

#define PRE21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21)

#define PRE22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22)

#define PRE23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23)

#define PRE24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24)

#define PRE25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25)

#define PRE26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26)

#define PRE27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27)

#define PRE28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28)

#define PRE29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29)

#define PRE30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29),PRE_ASSERT_(c30)

#else /* ! __cplusplus */

/* C versions declare a local variable so they can be the first statement. */

#define PRE(c) const int unused_assert_ = (PRE_ASSERT_(c),&unused_assert_!=0)

#define PRE2(c1,c2) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),&unused_assert_!=0)

#define PRE3(c1,c2,c3) \
const int unused_assert_ = \
(PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),&unused_assert_!=0)

#define PRE4(c1,c2,c3,c4) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),&unused_assert_!=0)

#define PRE5(c1,c2,c3,c4,c5) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),&unused_assert_!=0)

#define PRE6(c1,c2,c3,c4,c5,c6) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),\
PRE_ASSERT_(c6),&unused_assert_!=0)

#define PRE7(c1,c2,c3,c4,c5,c6,c7) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
&unused_assert_!=0)

#define PRE8(c1,c2,c3,c4,c5,c6,c7,c8) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),&unused_assert_!=0)

#define PRE9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),&unused_assert_!=0)

#define PRE10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),&unused_assert_!=0)

#define PRE11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
&unused_assert_!=0)

#define PRE12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),&unused_assert_!=0)

#define PRE13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),&unused_assert_!=0)

#define PRE14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),&unused_assert_!=0)

#define PRE15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
&unused_assert_!=0)

#define PRE16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),&unused_assert_!=0)

#define PRE17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),&unused_assert_!=0)

#define PRE18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),&unused_assert_!=0)

#define PRE19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
&unused_assert_!=0)

#define PRE20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),&unused_assert_!=0)

#define PRE21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),&unused_assert_!=0)

#define PRE22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),&unused_assert_!=0)

#define PRE23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
&unused_assert_!=0)

#define PRE24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),&unused_assert_!=0)

#define PRE25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),&unused_assert_!=0)

#define PRE26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),PRE_ASSERT_(c26),&unused_assert_!=0)

#define PRE27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),\
&unused_assert_!=0)

#define PRE28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),\
PRE_ASSERT_(c28),&unused_assert_!=0)

#define PRE29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),\
PRE_ASSERT_(c28),PRE_ASSERT_(c29),&unused_assert_!=0)

#define PRE30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),\
PRE_ASSERT_(c4),PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),\
PRE_ASSERT_(c8),PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),\
PRE_ASSERT_(c12),PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),\
PRE_ASSERT_(c16),PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),\
PRE_ASSERT_(c20),PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),\
PRE_ASSERT_(c24),PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),\
PRE_ASSERT_(c28),PRE_ASSERT_(c29),PRE_ASSERT_(c30),&unused_assert_!=0)


#endif /*!  __cplusplus */


#define CHECK(c)
#define CHECK2(c1,c2)
#define CHECK3(c1,c2,c3)
#define CHECK4(c1,c2,c3,c4)
#define CHECK5(c1,c2,c3,c4,c5)
#define CHECK6(c1,c2,c3,c4,c5,c6)
#define CHECK7(c1,c2,c3,c4,c5,c6,c7)
#define CHECK8(c1,c2,c3,c4,c5,c6,c7,c8)
#define CHECK9(c1,c2,c3,c4,c5,c6,c7,c8,c9)
#define CHECK10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10)
#define CHECK11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11)
#define CHECK12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12)
#define CHECK13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13)
#define CHECK14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14)
#define CHECK15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15)
#define CHECK16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16)
#define CHECK17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17)
#define CHECK18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18)

#define CHECK19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19)

#define CHECK20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20)

#define CHECK21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21)

#define CHECK22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22)

#define CHECK23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23)

#define CHECK24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24)

#define CHECK25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25)

#define CHECK26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26)

#define CHECK27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27)

#define CHECK28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28)

#define CHECK29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29)

#define CHECK30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30)

#define PRE0 PRE
#define PRE02 PRE2
#define PRE03 PRE3
#define PRE04 PRE4
#define PRE05 PRE5
#define PRE06 PRE6
#define PRE07 PRE7
#define PRE08 PRE8
#define PRE09 PRE9
#define PRE010 PRE10
#define PRE011 PRE11
#define PRE012 PRE12
#define PRE013 PRE13
#define PRE014 PRE14
#define PRE015 PRE15
#define PRE016 PRE16
#define PRE017 PRE17
#define PRE018 PRE18
#define PRE019 PRE19
#define PRE020 PRE20
#define PRE021 PRE21
#define PRE022 PRE22
#define PRE023 PRE23
#define PRE024 PRE24
#define PRE025 PRE25
#define PRE026 PRE26
#define PRE027 PRE27
#define PRE028 PRE28
#define PRE029 PRE29
#define PRE030 PRE30

#define POST CHECK
#define POST2 CHECK2
#define POST3 CHECK3
#define POST4 CHECK4
#define POST5 CHECK5
#define POST6 CHECK6
#define POST7 CHECK7
#define POST8 CHECK8
#define POST9 CHECK9
#define POST10 CHECK10
#define POST11 CHECK11
#define POST12 CHECK12
#define POST13 CHECK13
#define POST14 CHECK14
#define POST15 CHECK15
#define POST16 CHECK16
#define POST17 CHECK17
#define POST18 CHECK18
#define POST19 CHECK19
#define POST20 CHECK20
#define POST21 CHECK21
#define POST22 CHECK22
#define POST23 CHECK23
#define POST24 CHECK24
#define POST25 CHECK25
#define POST26 CHECK26
#define POST27 CHECK27
#define POST28 CHECK28
#define POST29 CHECK29
#define POST30 CHECK30

#define POST0 CHECK
#define POST02 CHECK2
#define POST03 CHECK3
#define POST04 CHECK4
#define POST05 CHECK5
#define POST06 CHECK6
#define POST07 CHECK7
#define POST08 CHECK8
#define POST09 CHECK9
#define POST010 CHECK10
#define POST011 CHECK11
#define POST012 CHECK12
#define POST013 CHECK13
#define POST014 CHECK14
#define POST015 CHECK15
#define POST016 CHECK16
#define POST017 CHECK17
#define POST018 CHECK18
#define POST019 CHECK19
#define POST020 CHECK20
#define POST021 CHECK21
#define POST022 CHECK22
#define POST023 CHECK23
#define POST024 CHECK24
#define POST025 CHECK25
#define POST026 CHECK26
#define POST027 CHECK27
#define POST028 CHECK28
#define POST029 CHECK29
#define POST030 CHECK30

#define CHECKING(s)

#define NOP_DECLARATION_ extern int errno

#define OLD(variable)
#define REMEMBER(type,variable) NOP_DECLARATION_
#define REMEMBER_F(type,function_name) NOP_DECLARATION_


#else /* ! PRECONDITIONS_ONLY */

/******************************* ALL ASSERTIONS ******************************/

/* Enable all checking. */

#define CHECK(c) CHECK_ASSERT_(c)

#define CHECK2(c1,c2) CHECK_ASSERT_(c1),CHECK_ASSERT_(c2)

#define CHECK3(c1,c2,c3) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3)

#define CHECK4(c1,c2,c3,c4) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4)

#define CHECK5(c1,c2,c3,c4,c5) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5)

#define CHECK6(c1,c2,c3,c4,c5,c6) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6)

#define CHECK7(c1,c2,c3,c4,c5,c6,c7) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7)

#define CHECK8(c1,c2,c3,c4,c5,c6,c7,c8) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8)

#define CHECK9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9)

#define CHECK10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10)

#define CHECK11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11)

#define CHECK12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12)

#define CHECK13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13)

#define CHECK14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14)

#define CHECK15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15)

#define CHECK16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16)

#define CHECK17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17)

#define CHECK18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18)

#define CHECK19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19)

#define CHECK20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20)

#define CHECK21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21)

#define CHECK22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22)

#define CHECK23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23)

#define CHECK24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24)

#define CHECK25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25)

#define CHECK26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25),CHECK_ASSERT_(c26)

#define CHECK27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25),CHECK_ASSERT_(c26),CHECK_ASSERT_(c27)

#define CHECK28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25),CHECK_ASSERT_(c26),CHECK_ASSERT_(c27),CHECK_ASSERT_(c28)

#define CHECK29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25),CHECK_ASSERT_(c26),CHECK_ASSERT_(c27),CHECK_ASSERT_(c28),\
CHECK_ASSERT_(c29)

#define CHECK30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
CHECK_ASSERT_(c1),CHECK_ASSERT_(c2),CHECK_ASSERT_(c3),CHECK_ASSERT_(c4),\
CHECK_ASSERT_(c5),CHECK_ASSERT_(c6),CHECK_ASSERT_(c7),CHECK_ASSERT_(c8),\
CHECK_ASSERT_(c9),CHECK_ASSERT_(c10),CHECK_ASSERT_(c11),CHECK_ASSERT_(c12),\
CHECK_ASSERT_(c13),CHECK_ASSERT_(c14),CHECK_ASSERT_(c15),CHECK_ASSERT_(c16),\
CHECK_ASSERT_(c17),CHECK_ASSERT_(c18),CHECK_ASSERT_(c19),CHECK_ASSERT_(c20),\
CHECK_ASSERT_(c21),CHECK_ASSERT_(c22),CHECK_ASSERT_(c23),CHECK_ASSERT_(c24),\
CHECK_ASSERT_(c25),CHECK_ASSERT_(c26),CHECK_ASSERT_(c27),CHECK_ASSERT_(c28),\
CHECK_ASSERT_(c29),CHECK_ASSERT_(c30)



#define POST0(c) POST_ASSERT_(c)

#define POST02(c1,c2) POST_ASSERT_(c1),POST_ASSERT_(c2)

#define POST03(c1,c2,c3) POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3)

#define POST04(c1,c2,c3,c4) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4)

#define POST05(c1,c2,c3,c4,c5) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5)

#define POST06(c1,c2,c3,c4,c5,c6) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6)

#define POST07(c1,c2,c3,c4,c5,c6,c7) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7)

#define POST08(c1,c2,c3,c4,c5,c6,c7,c8) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8)

#define POST09(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9)

#define POST010(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10)

#define POST011(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11)

#define POST012(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12)

#define POST013(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13)

#define POST014(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14)

#define POST015(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15)

#define POST016(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16)

#define POST017(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17)

#define POST018(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18)

#define POST019(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19)

#define POST020(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20)

#define POST021(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21)

#define POST022(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22)

#define POST023(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23)

#define POST024(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24)

#define POST025(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25)

#define POST026(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25),POST_ASSERT_(c26)

#define POST027(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25),POST_ASSERT_(c26),POST_ASSERT_(c27)

#define POST028(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25),POST_ASSERT_(c26),POST_ASSERT_(c27),POST_ASSERT_(c28)

#define POST029(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25),POST_ASSERT_(c26),POST_ASSERT_(c27),POST_ASSERT_(c28),\
POST_ASSERT_(c29)

#define POST030(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
POST_ASSERT_(c1),POST_ASSERT_(c2),POST_ASSERT_(c3),POST_ASSERT_(c4),\
POST_ASSERT_(c5),POST_ASSERT_(c6),POST_ASSERT_(c7),POST_ASSERT_(c8),\
POST_ASSERT_(c9),POST_ASSERT_(c10),POST_ASSERT_(c11),POST_ASSERT_(c12),\
POST_ASSERT_(c13),POST_ASSERT_(c14),POST_ASSERT_(c15),POST_ASSERT_(c16),\
POST_ASSERT_(c17),POST_ASSERT_(c18),POST_ASSERT_(c19),POST_ASSERT_(c20),\
POST_ASSERT_(c21),POST_ASSERT_(c22),POST_ASSERT_(c23),POST_ASSERT_(c24),\
POST_ASSERT_(c25),POST_ASSERT_(c26),POST_ASSERT_(c27),POST_ASSERT_(c28),\
POST_ASSERT_(c29),POST_ASSERT_(c30)



#ifdef __cplusplus

#ifndef NO_INVARIANT
#define EVALUATE_INVARIANT CHECK_ASSERT_(invariant())
#else
#define EVALUATE_INVARIANT ((void)(0))
#endif


#define PRE0(c) PRE_ASSERT_(c)

#define PRE02(c1,c2) PRE_ASSERT_(c1),PRE_ASSERT_(c2)

#define PRE03(c1,c2,c3) PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3)

#define PRE04(c1,c2,c3,c4) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4)

#define PRE05(c1,c2,c3,c4,c5) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5)

#define PRE06(c1,c2,c3,c4,c5,c6) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6)

#define PRE07(c1,c2,c3,c4,c5,c6,c7) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7)

#define PRE08(c1,c2,c3,c4,c5,c6,c7,c8) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8)

#define PRE09(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9)

#define PRE010(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10)

#define PRE011(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11)

#define PRE012(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12)

#define PRE013(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13)

#define PRE014(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14)

#define PRE015(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15)

#define PRE016(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16)

#define PRE017(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17)

#define PRE018(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18)

#define PRE019(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19)

#define PRE020(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20)

#define PRE021(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21)

#define PRE022(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22)

#define PRE023(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23)

#define PRE024(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24)

#define PRE025(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25)

#define PRE026(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26)

#define PRE027(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27)

#define PRE028(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28)

#define PRE029(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29)

#define PRE030(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29),PRE_ASSERT_(c30)


#define PRE(c) EVALUATE_INVARIANT,PRE0(c)

#define PRE2(c1,c2) EVALUATE_INVARIANT,PRE02(c1,c2)

#define PRE3(c1,c2,c3) EVALUATE_INVARIANT,PRE03(c1,c2,c3)

#define PRE4(c1,c2,c3,c4) EVALUATE_INVARIANT,PRE04(c1,c2,c3,c4)

#define PRE5(c1,c2,c3,c4,c5) EVALUATE_INVARIANT,PRE05(c1,c2,c3,c4,c5)

#define PRE6(c1,c2,c3,c4,c5,c6) EVALUATE_INVARIANT,PRE06(c1,c2,c3,c4,c5,c6)

#define PRE7(c1,c2,c3,c4,c5,c6,c7) \
EVALUATE_INVARIANT,PRE07(c1,c2,c3,c4,c5,c6,c7)

#define PRE8(c1,c2,c3,c4,c5,c6,c7,c8) \
EVALUATE_INVARIANT,PRE08(c1,c2,c3,c4,c5,c6,c7,c8)

#define PRE9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
EVALUATE_INVARIANT,PRE09(c1,c2,c3,c4,c5,c6,c7,c8,c9)

#define PRE10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
EVALUATE_INVARIANT,PRE010(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10)

#define PRE11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
EVALUATE_INVARIANT,PRE011(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11)

#define PRE12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
EVALUATE_INVARIANT,PRE012(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12)

#define PRE13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
EVALUATE_INVARIANT,PRE013(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13)

#define PRE14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
EVALUATE_INVARIANT,PRE014(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14)

#define PRE15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
EVALUATE_INVARIANT,PRE015(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15)

#define PRE16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
EVALUATE_INVARIANT,PRE016(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,\
c16)

#define PRE17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
EVALUATE_INVARIANT,\
PRE017(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17)

#define PRE18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,\
c18) \
EVALUATE_INVARIANT,\
PRE018(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18)

#define PRE19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
EVALUATE_INVARIANT,\
PRE019(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19)

#define PRE20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
EVALUATE_INVARIANT,\
PRE020(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20)

#define PRE21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,\
c18,c19,c20,c21) \
EVALUATE_INVARIANT,\
PRE021(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21)

#define PRE22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
EVALUATE_INVARIANT,\
PRE022(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22)

#define PRE23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
EVALUATE_INVARIANT,\
PRE023(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23)

#define PRE24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
EVALUATE_INVARIANT,\
PRE024(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24)

#define PRE25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
EVALUATE_INVARIANT,\
PRE025(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25)

#define PRE26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
EVALUATE_INVARIANT,\
PRE026(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25,c26)

#define PRE27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
EVALUATE_INVARIANT,\
PRE027(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25,c26,c27)

#define PRE28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
EVALUATE_INVARIANT,\
PRE028(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25,c26,c27,c28)

#define PRE29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
EVALUATE_INVARIANT,\
PRE029(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25,c26,c27,c28,c29)

#define PRE30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
EVALUATE_INVARIANT,\
PRE030(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,\
c21,c22,c23,c24,c25,c26,c27,c28,c29,c30)

#else /* ! __cplusplus */


#ifndef NO_INVARIANT
#ifndef INVARIANT_SELF
#define INVARIANT_SELF self
#endif
#define EVALUATE_INVARIANT \
  CHECK_ASSERT_(INVARIANT_SELF?INVARIANT_SELF->invariant(INVARIANT_SELF):0)
#else
#define EVALUATE_INVARIANT ((void)(0))
#endif


#define PRE0(c) const int unused_assert_ = (PRE_ASSERT_(c),&unused_assert_!=0)

#define PRE02(c1,c2) \
const int unused_assert_ = (PRE_ASSERT_(c1),PRE_ASSERT_(c2),&unused_assert_!=0)

#define PRE03(c1,c2,c3) \
const int unused_assert_ = \
(PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),&unused_assert_!=0)

#define PRE04(c1,c2,c3,c4) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
&unused_assert_!=0)

#define PRE05(c1,c2,c3,c4,c5) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),&unused_assert_!=0)

#define PRE06(c1,c2,c3,c4,c5,c6) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),&unused_assert_!=0)

#define PRE07(c1,c2,c3,c4,c5,c6,c7) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),&unused_assert_!=0)

#define PRE08(c1,c2,c3,c4,c5,c6,c7,c8) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
&unused_assert_!=0)

#define PRE09(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),&unused_assert_!=0)

#define PRE010(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),&unused_assert_!=0)

#define PRE011(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),&unused_assert_!=0)

#define PRE012(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
&unused_assert_!=0)

#define PRE013(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),&unused_assert_!=0)

#define PRE014(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),&unused_assert_!=0)

#define PRE015(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),&unused_assert_!=0)

#define PRE016(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
&unused_assert_!=0)

#define PRE017(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),&unused_assert_!=0)

#define PRE018(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),&unused_assert_!=0)

#define PRE019(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),&unused_assert_!=0)

#define PRE020(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
&unused_assert_!=0)

#define PRE021(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),&unused_assert_!=0)

#define PRE022(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),&unused_assert_!=0)

#define PRE023(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),&unused_assert_!=0)

#define PRE024(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
&unused_assert_!=0)

#define PRE025(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),&unused_assert_!=0)

#define PRE026(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),&unused_assert_!=0)

#define PRE027(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),&unused_assert_!=0)

#define PRE028(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
&unused_assert_!=0)

#define PRE029(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29), &unused_assert_!=0)

#define PRE030(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
const int unused_assert_ = (\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29),PRE_ASSERT_(c30), &unused_assert_!=0)



#define PRE(c) const int unused_assert_ = \
(EVALUATE_INVARIANT,PRE_ASSERT_(c),&unused_assert_!=0)

#define PRE2(c1,c2) \
const int unused_assert_ = \
(EVALUATE_INVARIANT,PRE_ASSERT_(c1),PRE_ASSERT_(c2),&unused_assert_!=0)

#define PRE3(c1,c2,c3) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),&unused_assert_!=0)

#define PRE4(c1,c2,c3,c4) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
&unused_assert_!=0)

#define PRE5(c1,c2,c3,c4,c5) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),&unused_assert_!=0)

#define PRE6(c1,c2,c3,c4,c5,c6) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),&unused_assert_!=0)

#define PRE7(c1,c2,c3,c4,c5,c6,c7) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),&unused_assert_!=0)

#define PRE8(c1,c2,c3,c4,c5,c6,c7,c8) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
&unused_assert_!=0)

#define PRE9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),&unused_assert_!=0)

#define PRE10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),&unused_assert_!=0)

#define PRE11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),&unused_assert_!=0)

#define PRE12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
&unused_assert_!=0)

#define PRE13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),&unused_assert_!=0)

#define PRE14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),&unused_assert_!=0)

#define PRE15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),&unused_assert_!=0)

#define PRE16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
&unused_assert_!=0)

#define PRE17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),&unused_assert_!=0)

#define PRE18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),&unused_assert_!=0)

#define PRE19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),&unused_assert_!=0)

#define PRE20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
&unused_assert_!=0)

#define PRE21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),&unused_assert_!=0)

#define PRE22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),&unused_assert_!=0)

#define PRE23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),&unused_assert_!=0)

#define PRE24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
&unused_assert_!=0)

#define PRE25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),&unused_assert_!=0)

#define PRE26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),&unused_assert_!=0)

#define PRE27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),&unused_assert_!=0)

#define PRE28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
&unused_assert_!=0)

#define PRE29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29), &unused_assert_!=0)

#define PRE30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
const int unused_assert_ = (EVALUATE_INVARIANT,\
PRE_ASSERT_(c1),PRE_ASSERT_(c2),PRE_ASSERT_(c3),PRE_ASSERT_(c4),\
PRE_ASSERT_(c5),PRE_ASSERT_(c6),PRE_ASSERT_(c7),PRE_ASSERT_(c8),\
PRE_ASSERT_(c9),PRE_ASSERT_(c10),PRE_ASSERT_(c11),PRE_ASSERT_(c12),\
PRE_ASSERT_(c13),PRE_ASSERT_(c14),PRE_ASSERT_(c15),PRE_ASSERT_(c16),\
PRE_ASSERT_(c17),PRE_ASSERT_(c18),PRE_ASSERT_(c19),PRE_ASSERT_(c20),\
PRE_ASSERT_(c21),PRE_ASSERT_(c22),PRE_ASSERT_(c23),PRE_ASSERT_(c24),\
PRE_ASSERT_(c25),PRE_ASSERT_(c26),PRE_ASSERT_(c27),PRE_ASSERT_(c28),\
PRE_ASSERT_(c29),PRE_ASSERT_(c30), &unused_assert_!=0)



#endif /* ! __cplusplus */



#define POST(c) EVALUATE_INVARIANT,POST0(c)
#define POST2(c1,c2) EVALUATE_INVARIANT,POST02(c1,c2)
#define POST3(c1,c2,c3) EVALUATE_INVARIANT,POST03(c1,c2,c3)
#define POST4(c1,c2,c3,c4) EVALUATE_INVARIANT,POST04(c1,c2,c3,c4)
#define POST5(c1,c2,c3,c4,c5) EVALUATE_INVARIANT,POST05(c1,c2,c3,c4,c5)
#define POST6(c1,c2,c3,c4,c5,c6) EVALUATE_INVARIANT,POST06(c1,c2,c3,c4,c5,c6)

#define POST7(c1,c2,c3,c4,c5,c6,c7) \
EVALUATE_INVARIANT,POST07(c1,c2,c3,c4,c5,c6,c7)

#define POST8(c1,c2,c3,c4,c5,c6,c7,c8) \
EVALUATE_INVARIANT,POST08(c1,c2,c3,c4,c5,c6,c7,c8)

#define POST9(c1,c2,c3,c4,c5,c6,c7,c8,c9) \
EVALUATE_INVARIANT,POST09(c1,c2,c3,c4,c5,c6,c7,c8,c9)

#define POST10(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10) \
EVALUATE_INVARIANT,POST010(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10)

#define POST11(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11) \
EVALUATE_INVARIANT,POST011(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11)

#define POST12(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12) \
EVALUATE_INVARIANT,POST012(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12)

#define POST13(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) \
EVALUATE_INVARIANT,POST013(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13)

#define POST14(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14) \
EVALUATE_INVARIANT,POST014(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14)

#define POST15(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15) \
EVALUATE_INVARIANT,POST015(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15)

#define POST16(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16) \
EVALUATE_INVARIANT,\
POST016(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16)

#define POST17(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17) \
EVALUATE_INVARIANT,\
POST017(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17)

#define POST18(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18) \
EVALUATE_INVARIANT,\
POST018(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18)

#define POST19(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19) \
EVALUATE_INVARIANT,\
POST019(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19)

#define POST20(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20) \
EVALUATE_INVARIANT,\
POST020(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20)

#define POST21(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21) \
EVALUATE_INVARIANT,\
POST021(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21)

#define POST22(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22) \
EVALUATE_INVARIANT,\
POST022(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22)

#define POST23(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23) \
EVALUATE_INVARIANT,\
POST023(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23)

#define POST24(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24) \
EVALUATE_INVARIANT,\
POST024(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24)

#define POST25(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25) \
EVALUATE_INVARIANT,\
POST025(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25)

#define POST26(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26) \
EVALUATE_INVARIANT,\
POST026(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26)

#define POST27(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27) \
EVALUATE_INVARIANT,\
POST027(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27)

#define POST28(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28) \
EVALUATE_INVARIANT,\
POST028(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28)

#define POST29(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29) \
EVALUATE_INVARIANT,\
POST029(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29)

#define POST30(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30) \
EVALUATE_INVARIANT,\
POST030(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,\
c19,c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30)



#define CHECKING(s) s

#define OLD(variable) variable##_old_
#define REMEMBER(type,variable) type OLD(variable) = variable
#define REMEMBER_F(type,function_name) type OLD(function_name)=function_name()


#endif /* NO_ASSERTIONS */


/* Handle optional debugging statements separately. */

#ifdef DEBUGGING
#define DEBUG(s) s
#else
#define DEBUG(s)
#endif

#if defined( DEBUGGING ) || defined( DEBUGGING2 )
#define DEBUG2(s) s
#else
#define DEBUG2(unused_)
#endif



/******************************************************************************
 * Other macros useful in PRE() and POST() expressions:
 * E.g., PRE3( str, str[0], IN_RANGE( i, 0, 8 ) )
 *
 * Implies: p implies c: if p is true then c must be true.
 * Example:
 * void f( size_t count, int items[] ) { PRE( IMPLIES( count, items ) ) }
 */

#define IMPLIES(p,c) (!(p)||(c))
#define IMPLIES_ELSE(p,c1,c2) (((p)&&(c1))||((!(p))&&(c2)))

/* Boolean functions: */

#define NOT(a) (!(a))

/* multi-argument NOT() forms omitted due to ambiguous interpretation. */


#define AND2(a,b) ((a)&&(b))
#define AND3(a,b,c) ((a)&&(b)&&(c))
#define AND4(a,b,c,d) ((a)&&(b)&&(c)&&(d))
#define AND5(a,b,c,d,e) ((a)&&(b)&&(c)&&(d)&&(e))
#define AND6(a,b,c,d,e,f) ((a)&&(b)&&(c)&&(d)&&(e)&&(f))
#define AND7(a,b,c,d,e,f,g) ((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g))
#define AND8(a,b,c,d,e,f,g,h) ((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h))

#define AND9(a,b,c,d,e,f,g,h,i) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i))

#define AND10(a,b,c,d,e,f,g,h,i,j) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j))

#define AND11(a,b,c,d,e,f,g,h,i,j,k) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k))

#define AND12(a,b,c,d,e,f,g,h,i,j,k,l) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l))

#define AND13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m))

#define AND14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n))

#define AND15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o))

#define AND16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p))

#define AND17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q))

#define AND18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r))

#define AND19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s))

#define AND20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t))

#define AND21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u))

#define AND22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v))

#define AND23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w))

#define AND24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x))

#define AND25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y))

#define AND26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y)&&(z))

#define AND27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y)&&(z)&&(a2))

#define AND28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y)&&(z)&&(a2)&&(b2))

#define AND29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y)&&(z)&&(a2)&&(b2)&&(c2))

#define AND30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2,d2) \
((a)&&(b)&&(c)&&(d)&&(e)&&(f)&&(g)&&(h)&&(i)&&(j)&&(k)&&(l)&&(m)&&(n)&&(o)&&(p)\
&&(q)&&(r)&&(s)&&(t)&&(u)&&(v)&&(w)&&(x)&&(y)&&(z)&&(a2)&&(b2)&&(c2)&&(d2))



#define OR2(a,b) ((a)||(b))
#define OR3(a,b,c) ((a)||(b)||(c))
#define OR4(a,b,c,d) ((a)||(b)||(c)||(d))
#define OR5(a,b,c,d,e) ((a)||(b)||(c)||(d)||(e))
#define OR6(a,b,c,d,e,f) ((a)||(b)||(c)||(d)||(e)||(f))
#define OR7(a,b,c,d,e,f,g) ((a)||(b)||(c)||(d)||(e)||(f)||(g))
#define OR8(a,b,c,d,e,f,g,h) ((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h))

#define OR9(a,b,c,d,e,f,g,h,i) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i))

#define OR10(a,b,c,d,e,f,g,h,i,j) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j))

#define OR11(a,b,c,d,e,f,g,h,i,j,k) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k))

#define OR12(a,b,c,d,e,f,g,h,i,j,k,l) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l))

#define OR13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m))

#define OR14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n))

#define OR15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o))

#define OR16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p))

#define OR17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q))

#define OR18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r))

#define OR19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s))

#define OR20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t))

#define OR21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u))

#define OR22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v))

#define OR23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w))

#define OR24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x))

#define OR25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y))

#define OR26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y)||(z))

#define OR27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y)||(z)||(a2))

#define OR28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y)||(z)||(a2)||(b2))

#define OR29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y)||(z)||(a2)||(b2)||(c2))

#define OR30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2,d2) \
((a)||(b)||(c)||(d)||(e)||(f)||(g)||(h)||(i)||(j)||(k)||(l)||(m)||(n)||(o)||(p)\
||(q)||(r)||(s)||(t)||(u)||(v)||(w)||(x)||(y)||(z)||(a2)||(b2)||(c2)||(d2))






/* Also see XOR() below. */


/* Numeric tests: */

/* Range membership: */

#define IN_RANGE(x,low,high) ((low)<=(x)&&(x)<=(high))
#define SIGN(x) ((x)<0?-1:1)

/* For C int 'flag' usage: */

#define IS_BOOL(a) ((a)==0||(a)==1)
#define IS_BOOL2(a,b) AND2(IS_BOOL(a),IS_BOOL(b))
#define IS_BOOL3(a,b,c) AND3(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c))
#define IS_BOOL4(a,b,c,d) AND4(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d))

#define IS_BOOL5(a,b,c,d,e) \
AND5(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e))

#define IS_BOOL6(a,b,c,d,e,f) \
AND6(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f))

#define IS_BOOL7(a,b,c,d,e,f,g) \
AND7(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g))

#define IS_BOOL8(a,b,c,d,e,f,g,h) \
AND8(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h))

#define IS_BOOL9(a,b,c,d,e,f,g,h,i) \
AND9(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i))

#define IS_BOOL10(a,b,c,d,e,f,g,h,i,j) \
AND10(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j))

#define IS_BOOL11(a,b,c,d,e,f,g,h,i,j,k) \
AND11(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k))

#define IS_BOOL12(a,b,c,d,e,f,g,h,i,j,k,l) \
AND12(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l))

#define IS_BOOL13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
AND13(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m))

#define IS_BOOL14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
AND14(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n))

#define IS_BOOL15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
AND15(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o))

#define IS_BOOL16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
AND16(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p))

#define IS_BOOL17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
AND17(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q))

#define IS_BOOL18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
AND18(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r))

#define IS_BOOL19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
AND19(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s))

#define IS_BOOL20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
AND20(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t))

#define IS_BOOL21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
AND21(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u))

#define IS_BOOL22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
AND22(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v))

#define IS_BOOL23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
AND23(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w))

#define IS_BOOL24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
AND24(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x))

#define IS_BOOL25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
AND25(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y))

#define IS_BOOL26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
AND26(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y),IS_BOOL(z))

#define IS_BOOL27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
AND27(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y),IS_BOOL(z),IS_BOOL(a2))

#define IS_BOOL28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
AND28(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y),IS_BOOL(z),IS_BOOL(a2),\
IS_BOOL(b2))

#define IS_BOOL29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2)\
AND29(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y),IS_BOOL(z),IS_BOOL(a2),\
IS_BOOL(b2),IS_BOOL(c2))

#define IS_BOOL30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2,d2)\
AND30(IS_BOOL(a),IS_BOOL(b),IS_BOOL(c),IS_BOOL(d),IS_BOOL(e),IS_BOOL(f),\
IS_BOOL(g),IS_BOOL(h),IS_BOOL(i),IS_BOOL(j),IS_BOOL(k),IS_BOOL(l),IS_BOOL(m),\
IS_BOOL(n),IS_BOOL(o),IS_BOOL(p),IS_BOOL(q),IS_BOOL(r),IS_BOOL(s),IS_BOOL(t),\
IS_BOOL(u),IS_BOOL(v),IS_BOOL(w),IS_BOOL(x),IS_BOOL(y),IS_BOOL(z),IS_BOOL(a2),\
IS_BOOL(b2),IS_BOOL(c2),IS_BOOL(d2))



#define NON_ZERO2 AND2
#define NON_ZERO3 AND3
#define NON_ZERO4 AND4
#define NON_ZERO5 AND5
#define NON_ZERO6 AND6
#define NON_ZERO7 AND7
#define NON_ZERO8 AND8
#define NON_ZERO9 AND9
#define NON_ZERO10 AND10
#define NON_ZERO11 AND11
#define NON_ZERO12 AND12
#define NON_ZERO13 AND13
#define NON_ZERO14 AND14
#define NON_ZERO15 AND15
#define NON_ZERO16 AND16
#define NON_ZERO17 AND17
#define NON_ZERO18 AND18
#define NON_ZERO19 AND19
#define NON_ZERO20 AND20
#define NON_ZERO21 AND21
#define NON_ZERO22 AND22
#define NON_ZERO23 AND23
#define NON_ZERO24 AND24
#define NON_ZERO25 AND25
#define NON_ZERO26 AND26
#define NON_ZERO27 AND27
#define NON_ZERO28 AND28
#define NON_ZERO29 AND29
#define NON_ZERO30 AND30


#define IS_ZERO2(a,b) ((a)==0&&(b)==0)
#define IS_ZERO3(a,b,c) ((a)==0&&(b)==0&&(c)==0)
#define IS_ZERO4(a,b,c,d) ((a)==0&&(b)==0&&(c)==0&&(d)==0)
#define IS_ZERO5(a,b,c,d,e) ((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0)
#define IS_ZERO6(a,b,c,d,e,f) ((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0)

#define IS_ZERO7(a,b,c,d,e,f,g) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0)

#define IS_ZERO8(a,b,c,d,e,f,g,h) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0)

#define IS_ZERO9(a,b,c,d,e,f,g,h,i) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0)

#define IS_ZERO10(a,b,c,d,e,f,g,h,i,j) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&(j)==0)

#define IS_ZERO11(a,b,c,d,e,f,g,h,i,j,k) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0)

#define IS_ZERO12(a,b,c,d,e,f,g,h,i,j,k,l) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0)

#define IS_ZERO13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0)

#define IS_ZERO14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0)

#define IS_ZERO15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0)

#define IS_ZERO16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0)

#define IS_ZERO17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0)

#define IS_ZERO18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0)

#define IS_ZERO19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0)

#define IS_ZERO20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0)

#define IS_ZERO21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0)

#define IS_ZERO22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0)

#define IS_ZERO23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0)

#define IS_ZERO24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0)

#define IS_ZERO25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0)

#define IS_ZERO26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0&&(z)==0)

#define IS_ZERO27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0&&(z)==0&&(a2)==0)

#define IS_ZERO28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0&&(z)==0&&(a2)==0&&\
(b2)==0)

#define IS_ZERO29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0&&(z)==0&&(a2)==0&&\
(b2)==0&&(c2)==0)

#define IS_ZERO30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2,d2) \
((a)==0&&(b)==0&&(c)==0&&(d)==0&&(e)==0&&(f)==0&&(g)==0&&(h)==0&&(i)==0&&\
(j)==0&&(k)==0&&(l)==0&&(m)==0&&(n)==0&&(o)==0&&(p)==0&&(q)==0&&(r)==0&&\
(s)==0&&(t)==0&&(u)==0&&(v)==0&&(w)==0&&(x)==0&&(y)==0&&(z)==0&&(a2)==0&&\
(b2)==0&&(c2)==0&&(d2)==0)


#define GT_ZERO2(a,b) ((a)>0&&(b)>0)
#define GT_ZERO3(a,b,c) ((a)>0&&(b)>0&&(c)>0)
#define GT_ZERO4(a,b,c,d) ((a)>0&&(b)>0&&(c)>0&&(d)>0)
#define GT_ZERO5(a,b,c,d,e) ((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0)
#define GT_ZERO6(a,b,c,d,e,f) ((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0)

#define GT_ZERO7(a,b,c,d,e,f,g) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0)

#define GT_ZERO8(a,b,c,d,e,f,g,h) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0)

#define GT_ZERO9(a,b,c,d,e,f,g,h,i) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0)

#define GT_ZERO10(a,b,c,d,e,f,g,h,i,j) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0)

#define GT_ZERO11(a,b,c,d,e,f,g,h,i,j,k) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0)

#define GT_ZERO12(a,b,c,d,e,f,g,h,i,j,k,l) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0)

#define GT_ZERO13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0)

#define GT_ZERO14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0)

#define GT_ZERO15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0)

#define GT_ZERO16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0)

#define GT_ZERO17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0)

#define GT_ZERO18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0)

#define GT_ZERO19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0)

#define GT_ZERO20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0)

#define GT_ZERO21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0)

#define GT_ZERO22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0)

#define GT_ZERO23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0)

#define GT_ZERO24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0)

#define GT_ZERO25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0)

#define GT_ZERO26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0&&(z)>0)

#define GT_ZERO27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0&&(z)>0&&(a2)>0)

#define GT_ZERO28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0&&(z)>0&&(a2)>0&&(b2)>0)

#define GT_ZERO29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0&&(z)>0&&(a2)>0&&(b2)>0&&(c2)>0)

#define GT_ZERO30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2,d2) \
((a)>0&&(b)>0&&(c)>0&&(d)>0&&(e)>0&&(f)>0&&(g)>0&&(h)>0&&(i)>0&&(j)>0&&\
(k)>0&&(l)>0&&(m)>0&&(n)>0&&(o)>0&&(p)>0&&(q)>0&&(r)>0&&(s)>0&&(t)>0&&(u)>0&&\
(v)>0&&(w)>0&&(x)>0&&(y)>0&&(z)>0&&(a2)>0&&(b2)>0&&(c2)>0&&(d2)>0)




#define GE_ZERO2(a,b) ((a)>=0&&(b)>=0)
#define GE_ZERO3(a,b,c) ((a)>=0&&(b)>=0&&(c)>=0)
#define GE_ZERO4(a,b,c,d) ((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0)
#define GE_ZERO5(a,b,c,d,e) ((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0)
#define GE_ZERO6(a,b,c,d,e,f) ((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0)

#define GE_ZERO7(a,b,c,d,e,f,g) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0)

#define GE_ZERO8(a,b,c,d,e,f,g,h) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0)

#define GE_ZERO9(a,b,c,d,e,f,g,h,i) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0)

#define GE_ZERO10(a,b,c,d,e,f,g,h,i,j) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&(j)>=0)

#define GE_ZERO11(a,b,c,d,e,f,g,h,i,j,k) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0)

#define GE_ZERO12(a,b,c,d,e,f,g,h,i,j,k,l) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0)

#define GE_ZERO13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0)

#define GE_ZERO14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0)

#define GE_ZERO15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0)

#define GE_ZERO16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0)

#define GE_ZERO17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0)

#define GE_ZERO18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0)

#define GE_ZERO19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&(s)>=0)

#define GE_ZERO20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0)

#define GE_ZERO21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0)

#define GE_ZERO22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0)

#define GE_ZERO23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0)

#define GE_ZERO24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0)

#define GE_ZERO25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0)

#define GE_ZERO26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0&&(z)>=0)

#define GE_ZERO27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0&&(z)>=0&&(a2)>=0)

#define GE_ZERO28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0&&(z)>=0&&(a2)>=0&&\
(b2)>=0)

#define GE_ZERO29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0&&(z)>=0&&(a2)>=0&&\
(b2)>=0&&(c2)>=0)

#define GE_ZERO30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,\
c2,d2) \
((a)>=0&&(b)>=0&&(c)>=0&&(d)>=0&&(e)>=0&&(f)>=0&&(g)>=0&&(h)>=0&&(i)>=0&&\
(j)>=0&&(k)>=0&&(l)>=0&&(m)>=0&&(n)>=0&&(o)>=0&&(p)>=0&&(q)>=0&&(r)>=0&&\
(s)>=0&&(t)>=0&&(u)>=0&&(v)>=0&&(w)>=0&&(x)>=0&&(y)>=0&&(z)>=0&&(a2)>=0&&\
(b2)>=0&&(c2)>=0&&(d2)>=0)


/* Set membership. */

#define IN3(x,a,b ) ((x)==(a)||(x)==(b))
#define IN4(x,a,b,c ) ((x)==(a)||(x)==(b)||(x)==(c))
#define IN5(x,a,b,c,d ) ((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d))

#define IN6(x,a,b,c,d,e) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e))

#define IN7(x,a,b,c,d,e,f) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f))

#define IN8(x,a,b,c,d,e,f,g) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g))

#define IN9(x,a,b,c,d,e,f,g,h) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h))

#define IN10(x,a,b,c,d,e,f,g,h,i) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i))

#define IN11(x,a,b,c,d,e,f,g,h,i,j) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j))

#define IN12(x,a,b,c,d,e,f,g,h,i,j,k) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k))

#define IN13(x,a,b,c,d,e,f,g,h,i,j,k,l) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l))

#define IN14(x,a,b,c,d,e,f,g,h,i,j,k,l,m) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m))

#define IN15(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n))

#define IN16(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o))

#define IN17(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p))

#define IN18(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q))

#define IN19(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r))

#define IN20(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s))

#define IN21(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t))

#define IN22(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u))

#define IN23(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v))

#define IN24(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w))

#define IN25(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2))

#define IN26(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2,b2) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2)||(x)==(b2))

#define IN27(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2,b2,c2) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2)||(x)==(b2)||(x)==(c2))

#define IN28(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2,b2,c2,d2) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2)||(x)==(b2)||(x)==(c2)||(x)==(d2))

#define IN29(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2,b2,c2,d2,e2) \
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2)||(x)==(b2)||(x)==(c2)||(x)==(d2)||(x)==(e2))

#define IN30(x,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,a2,b2,c2,d2,e2,f2)\
((x)==(a)||(x)==(b)||(x)==(c)||(x)==(d)||(x)==(e)||(x)==(f)||(x)==(g)||(x)==(h)\
||(x)==(i)||(x)==(j)||(x)==(k)||(x)==(l)||(x)==(m)||(x)==(n)||(x)==(o)\
||(x)==(p)||(x)==(q)||(x)==(r)||(x)==(s)||(x)==(t)||(x)==(u)||(x)==(v)\
||(x)==(w)||(x)==(a2)||(x)==(b2)||(x)==(c2)||(x)==(d2)||(x)==(e2)||(x)==(f2))


/* NON_ZERO_COUNT*() evaluates to the number of arguments that are non-zero: */

#define NON_ZERO_COUNT2(a,b) (((a)!=0)+((b)!=0))
#define NON_ZERO_COUNT3(a,b,c) (((a)!=0)+((b)!=0)+((c)!=0))
#define NON_ZERO_COUNT4(a,b,c,d) (((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0))

#define NON_ZERO_COUNT5(a,b,c,d,e) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0))

#define NON_ZERO_COUNT6(a,b,c,d,e,f) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0))

#define NON_ZERO_COUNT7(a,b,c,d,e,f,g) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0))

#define NON_ZERO_COUNT8(a,b,c,d,e,f,g,h) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0))

#define NON_ZERO_COUNT9(a,b,c,d,e,f,g,h,i) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0))

#define NON_ZERO_COUNT10(a,b,c,d,e,f,g,h,i,j) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0))

#define NON_ZERO_COUNT11(a,b,c,d,e,f,g,h,i,j,k) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0))

#define NON_ZERO_COUNT12(a,b,c,d,e,f,g,h,i,j,k,l) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0))

#define NON_ZERO_COUNT13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0))

#define NON_ZERO_COUNT14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0))

#define NON_ZERO_COUNT15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0))

#define NON_ZERO_COUNT16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0))

#define NON_ZERO_COUNT17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0))

#define NON_ZERO_COUNT18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0))

#define NON_ZERO_COUNT19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0))

#define NON_ZERO_COUNT20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0))

#define NON_ZERO_COUNT21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0))

#define NON_ZERO_COUNT22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0))

#define NON_ZERO_COUNT23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0))

#define NON_ZERO_COUNT24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0))

#define NON_ZERO_COUNT25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0))

#define NON_ZERO_COUNT26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0)+((z)!=0))

#define NON_ZERO_COUNT27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\
a2) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0)+((z)!=0)+((a2)!=0))

#define NON_ZERO_COUNT28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\
a2,b2) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0)+((z)!=0)+((a2)!=0)+((b2)!=0))

#define NON_ZERO_COUNT29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\
a2,b2,c2) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0)+((z)!=0)+((a2)!=0)+((b2)!=0)+((c2)!=0))

#define NON_ZERO_COUNT30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,\
a2,b2,c2,d2) \
(((a)!=0)+((b)!=0)+((c)!=0)+((d)!=0)+((e)!=0)+((f)!=0)+((g)!=0)+((h)!=0)\
+((i)!=0)+((j)!=0)+((k)!=0)+((l)!=0)+((m)!=0)+((n)!=0)+((o)!=0)+((p)!=0)\
+((q)!=0)+((r)!=0)+((s)!=0)+((t)!=0)+((u)!=0)+((v)!=0)+((w)!=0)+((x)!=0)\
+((y)!=0)+((z)!=0)+((a2)!=0)+((b2)!=0)+((c2)!=0)+((d2)!=0))



/* Exclusive-or does not do short-circuited boolean evaluation: */

#define XOR2(a,b) (NON_ZERO_COUNT2(a,b)==1)
#define XOR3(a,b,c) (NON_ZERO_COUNT3(a,b,c)==1)
#define XOR4(a,b,c,d) (NON_ZERO_COUNT4(a,b,c,d)==1)
#define XOR5(a,b,c,d,e) (NON_ZERO_COUNT5(a,b,c,d,e)==1)
#define XOR6(a,b,c,d,e,f) (NON_ZERO_COUNT6(a,b,c,d,e,f)==1)
#define XOR7(a,b,c,d,e,f,g) (NON_ZERO_COUNT7(a,b,c,d,e,f,g)==1)
#define XOR8(a,b,c,d,e,f,g,h) (NON_ZERO_COUNT8(a,b,c,d,e,f,g,h)==1)
#define XOR9(a,b,c,d,e,f,g,h,i) (NON_ZERO_COUNT9(a,b,c,d,e,f,g,h,i)==1)
#define XOR10(a,b,c,d,e,f,g,h,i,j) (NON_ZERO_COUNT10(a,b,c,d,e,f,g,h,i,j)==1)

#define XOR11(a,b,c,d,e,f,g,h,i,j,k) \
(NON_ZERO_COUNT11(a,b,c,d,e,f,g,h,i,j,k)==1)

#define XOR12(a,b,c,d,e,f,g,h,i,j,k,l) \
(NON_ZERO_COUNT12(a,b,c,d,e,f,g,h,i,j,k,l)==1)

#define XOR13(a,b,c,d,e,f,g,h,i,j,k,l,m) \
(NON_ZERO_COUNT13(a,b,c,d,e,f,g,h,i,j,k,l,m)==1)

#define XOR14(a,b,c,d,e,f,g,h,i,j,k,l,m,n) \
(NON_ZERO_COUNT14(a,b,c,d,e,f,g,h,i,j,k,l,m,n)==1)

#define XOR15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) \
(NON_ZERO_COUNT15(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)==1)

#define XOR16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
(NON_ZERO_COUNT16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)==1)

#define XOR17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) \
(NON_ZERO_COUNT17(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)==1)

#define XOR18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) \
(NON_ZERO_COUNT18(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)==1)

#define XOR19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) \
(NON_ZERO_COUNT19(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)==1)

#define XOR20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) \
(NON_ZERO_COUNT20(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)==1)

#define XOR21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) \
(NON_ZERO_COUNT21(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)==1)

#define XOR22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) \
(NON_ZERO_COUNT22(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)==1)

#define XOR23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) \
(NON_ZERO_COUNT23(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)==1)

#define XOR24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) \
(NON_ZERO_COUNT24(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)==1)

#define XOR25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) \
(NON_ZERO_COUNT25(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)==1)

#define XOR26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) \
(NON_ZERO_COUNT26(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)==1)

#define XOR27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2) \
(NON_ZERO_COUNT27(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2)==1)

#define XOR28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2) \
(NON_ZERO_COUNT28(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,\
b2)==1)

#define XOR29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2) \
(NON_ZERO_COUNT29(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,\
b2,c2)==1)

#define XOR30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,b2,c2,d2)\
(NON_ZERO_COUNT30(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a2,\
b2,c2,d2)==1)




===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: DateTime.h - Declare routines for date/time computation.


FUNCTIONS:

extern int isValidDate( int yyyyddd );

extern int isValidTime( int hhmmss );

extern int isValidTimestepSize( int hhmmss );

extern int isLeapYear( int yyyy );

extern int timestepsInRange( int firstDate, int firstTime,
                             int lastDate,  int lastTime );

extern void monthAndDay( int yyyyddd, int* month, int* dayOfMonth );

extern void incrementOneHour( int* yyyyddd, int* hhmmss );

extern void decrementOneHour( int* yyyyddd, int* hhmmss );

extern void incrementTime( int* yyyyddd, int* hhmmss, int step );

extern void decrementTime( int* yyyyddd, int* hhmmss, int step );



/* New date/time routines: */

enum { UTC_TIMESTAMP_LENGTH = 24 }; /* YYYY-MM-DDTHH:MM:SS-ZZZZ */
typedef char UTCTimestamp[ UTC_TIMESTAMP_LENGTH + 1 ];

extern int isValidUTCTimestamp( const char* string );
extern void toUTCTimestamp( long long yyyydddhhmm, UTCTimestamp string );
extern long long fromUTCTimestamp( const UTCTimestamp string );
extern void incrementTimestamp( long long* yyyydddhhmm );
extern void decrementTimestamp( long long* yyyydddhhmm );
extern long long offsetTimestamp( long long yyyydddhhmm, int hours );
extern int parseTimestamp( const char* string, long long* yyyydddhh00 );
extern int isValidTimestamp( long long yyyydddhhmm );
extern int isValidYearMonthDay( int yyyymmdd );
extern int convertYearMonthDay( int yyyymmdd );
extern long long nowUTC( void ); /* Returns YYYYDDDHHMM. */
extern int fileDateUTC( const char* fileName );
extern int timeZoneOffset( const char* timeZoneName );

extern int isYear( const int yyyy );
extern int daysInYear( const int yyyy );
extern int isYYYYMMDD( const int yyyy, const int mm, const int dd );
extern int isHHMMSS( const int hhmmss );
extern int isUTCTimestamp( const UTCTimestamp value );

extern int daysInMonth( int year, int month );
extern int isValidYYYYMMDD( int yyyymmdd );
extern int incrementDate( int yyyymmdd, int days );
extern int isValidYYYYMMDDHH( int yyyymmddhh );
extern int incrementDateTime( int yyyymmddhh, int hours );

#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: isValidDate - Is the given date valid YYYYDDD format?
INPUTS:  int yyyyddd  The date to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidDate( int yyyyddd )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidTime - Is the given time valid HHMMSS format?
INPUTS:  int hhmmss  The time to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidTime( int hhmmss )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidTimestepSize - Is the given time valid *HHMMSS format?
INPUTS:  int hhmmss  The timestep size to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidTimestepSize( int hhmmss )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isLeapYear - Does the year have 366 days?
INPUTS:  int yyyy  YYYY.
RETURNS: int 1 if yyyy is a leap year, else 0.
INTERFACE:
int isLeapYear( int yyyy )
PRE0( isValidDate( yyyy * 1000 + 1 ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: timestepsInRange - Number of one-hour timesteps in range, inclusive.
INPUTS:  int firstDate  YYYYDDD
         int firstTime  HHMMSS
         int lastDate   YYYYDDD
         int lastTime   HHMMSS
RETURNS: int Number of one-hour timesteps in range, inclusive.
INTERFACE:
int timestepsInRange( int firstDate, int firstTime,
                      int lastDate,  int lastTime )
PRE06( isValidDate( firstDate ), isValidTime( firstTime ),
       isValidDate( lastDate  ), isValidTime( lastTime  ),
       firstDate <= lastDate,
       IMPLIES( firstDate == lastDate, firstTime <= lastTime ) )
POST0( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: monthAndDay - Month [1..12] and day of month [1..31] of yyyyddd.
INPUTS:  int yyyyddd      Year and day of year.
OUTPUTS: int* month       Month of year [1..12].
         int* dayOfMonth  Day of month [1..31].
INTERFACE:
void monthAndDay( int yyyyddd, int* month, int* dayOfMonth )
PRE03( isValidDate( yyyyddd ), month, dayOfMonth )
POST02( IN_RANGE( *month, 1, 12 ), IN_RANGE( *dayOfMonth, 1, 31 ) )

-------------------------------------------------------------------------------

PURPOSE: incrementOneHour - Increment date/time by one hour.
INPUTS:  int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
OUTPUTS: int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
INTERFACE:
void incrementOneHour( int* yyyyddd, int* hhmmss )
PRE04( yyyyddd, hhmmss, isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )
POST02( isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )

-------------------------------------------------------------------------------

PURPOSE: decrementOneHour - Decrement date/time by one hour.
INPUTS:  int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
OUTPUTS: int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
INTERFACE:
void decrementOneHour( int* yyyyddd, int* hhmmss )
PRE04( yyyyddd, hhmmss, isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )
POST02( isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )

-------------------------------------------------------------------------------

PURPOSE: incrementTime - Increment date/time by step.
INPUTS:  int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
         int  step     ...HHMMSS.
OUTPUTS: int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
INTERFACE:
void incrementTime( int* yyyyddd, int* hhmmss, int step )
PRE05( yyyyddd, hhmmss, isValidDate( *yyyyddd ), isValidTime( *hhmmss ),
       isValidTimestepSize( step ) )
POST02( isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )

-------------------------------------------------------------------------------

PURPOSE: decrementTime - Decrement date/time by step.
INPUTS:  int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
         int  step     HHMMSS.
OUTPUTS: int* yyyyddd  YYYYDDD.
         int* hhmmss   HHMMSS.
INTERFACE:
void decrementTime( int* yyyyddd, int* hhmmss, int step )
PRE05( yyyyddd, hhmmss, isValidDate( *yyyyddd ), isValidTime( *hhmmss ),
       isValidTimestepSize( step ) )
POST02( isValidDate( *yyyyddd ), isValidTime( *hhmmss ) )

-------------------------------------------------------------------------------

PURPOSE: isValidUTCTimestamp - Is string a valid UTCTimestamp?
INPUTS:  const char* string  The string to examine.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidUTCTimestamp( const char* string )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: toUTCTimestamp - Convert timestamp to ISO UTC string format.
INPUTS:  long long yyyydddhhmm  Timestamp to convert.
OUTPUTS: UTCTimestamp string  ISO UTC string format for the timestamp.
INTERFACE:
void toUTCTimestamp( long long yyyydddhhmm, UTCTimestamp string )
PRE02( isValidTimestamp( yyyydddhhmm ), string )
POST0( strlen( string ) == UTC_TIMESTAMP_LENGTH )

-------------------------------------------------------------------------------

PURPOSE: fromUTCTimestamp - Convert ISO UTC string to integer.
INPUTS:  const UTCTimestamp string  ISO UTC string to convert.
RETURNS: long long yyyydddhhmm timestamp.
INTERFACE:
long long fromUTCTimestamp( const UTCTimestamp string )
PRE0( isValidUTCTimestamp( (const char*) string ) )
POST0( isValidTimestamp( result ) )

-------------------------------------------------------------------------------

PURPOSE: parseTimestamp - Parse string timestamp into its integer value.
INPUTS:  const char* string      String representation of timestamp.
OUTPUTS: long long*    yyyydddhh00 Value of string as yyyydddhh00.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int parseTimestamp( const char* string, long long* yyyydddhh00 )
PRE02( string, yyyydddhh00 )
POST02( IS_BOOL( result ),
       IMPLIES_ELSE( result,
                     isValidTimestamp( *yyyydddhh00 ), *yyyydddhh00 == 0 ) )

-------------------------------------------------------------------------------

PURPOSE: isValidTimestamp - Is the timestamp valid?
INPUTS:  long long yyyydddhhmm The timestamp to examine.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidTimestamp( long long yyyydddhhmm )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidYearMonthDay - Is the date valid?
INPUTS:  int yyyymmdd The date to examine.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidYearMonthDay( int yyyymmdd )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: convertYearMonthDay - Convert date from YYYYMMDD to YYYYDDD.
INPUTS:  int yyyymmdd  Year, month, day to convert.
RETURNS: int yyyyddd equivalent day.
INTERFACE:
int convertYearMonthDay( int yyyymmdd )
PRE03( yyyymmdd / 10000 > 1000,
      IN_RANGE(  yyyymmdd / 100 % 100, 1, 12 ),
      IN_RANGE(  yyyymmdd % 100, 1,
                 daysPerMonth[ isLeapYear( yyyymmdd / 10000 ) ]
                 [ yyyymmdd / 100 % 100 - 1] ) )
POST03( result / 1000 == yyyymmdd / 10000,
        result % 1000 > 0,
        result % 1000 <= 365 + isLeapYear( yyyymmdd / 10000 ) )

-------------------------------------------------------------------------------

PURPOSE: incrementTimestamp - Increment timestamp by one hour.
INPUTS:  long long* yyyydddhhmm  Timestamp to increment.
OUTPUTS: long long* yyyydddhhmm  Inremented timestamp.
INTERFACE:
void incrementTimestamp( long long* yyyydddhhmm )
PRE02( yyyydddhhmm, isValidTimestamp( *yyyydddhhmm ) )
POST0( isValidTimestamp( *yyyydddhhmm ) )

-------------------------------------------------------------------------------

PURPOSE: decrementTimestamp - Decrement timestamp by one hour.
INPUTS:  long long* yyyydddhhmm  Timestamp to increment.
OUTPUTS: long long* yyyydddhhmm  Deremented timestamp.
INTERFACE:
void decrementTimestamp( long long* yyyydddhhmm )
PRE02( yyyydddhhmm, isValidTimestamp( *yyyydddhhmm ) )
POST0( isValidTimestamp( *yyyydddhhmm ) )

-------------------------------------------------------------------------------

PURPOSE: offsetTimestamp - Compute timestamp + offset.
INPUTS:  long long yyyydddhhmm  Initial timestamp.
         int hours        + or - hours to offset.
RETURNS: long long yyyydddhhmm + hours.
INTERFACE:
long long offsetTimestamp( long long yyyydddhhmm, int hours )
PRE0( isValidTimestamp( yyyydddhhmm ) )
POST02( isValidTimestamp( result ),
        OR3( AND2( hours == 0, result == yyyydddhhmm ),
             AND2( hours < 0,  result <  yyyydddhhmm ),
             AND2( hours > 0,  result >  yyyydddhhmm ) ) )

-------------------------------------------------------------------------------

PURPOSE: nowUTC - Current timestamp in UTC.
RETURNS: long long yyyydddhhmm.
INTERFACE:
long long nowUTC( void )
POST0( isValidTimestamp( result ) )

-------------------------------------------------------------------------------

PURPOSE: fileDateUTC - UTC date when named file was last modified.
INPUTS:  const char* fileName  Name of file to check.
RETURNS: int yyyymmdd.
INTERFACE:
int fileDateUTC( const char* fileName )
POST0( isValidYearMonthDay( result ) )

-------------------------------------------------------------------------------

PURPOSE: timeZoneOffset - Hour offset (subtracted) from GMT.
INPUTS:  const char* timeZoneName  E.g., "EST".
RETURNS: int offset from GMT (e.g., 4).
INTERFACE:
int timeZoneOffset( const char* timeZoneName )
PRE02( timeZoneName, *timeZoneName )
POST0( IN_RANGE( result, 0, 23 ) )

-------------------------------------------------------------------------------

PURPOSE: daysInMonth - The number of days in the given [year, month].
INPUTS:  int year  4-digit year.
         int month [1, 12].
RETURNS: int [1, 31].
INTERFACE:
int daysInMonth( int year, int month )
PRE02( IN_RANGE( year, 1800, 2147 ), IN_RANGE( month, 1, 12 ) )
POST0( IN_RANGE( result, 1, 31 ) )

-------------------------------------------------------------------------------

PURPOSE: isValidYYYYMMDD - Is the date yyyymmdd valid?
INPUTS:  int yyyymmdd  E.g., 20090501 is May 1, 2009.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidYYYYMMDD( int yyyymmdd )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: incrementDate - The date (yyyymmdd) incremented by the given of days.
INPUTS:  int yyyymmdd  E.g., 20090501 is May 1, 2009.
         int days      Number of days to increment from yyyymmdd.
RETURNS: int incremented yyyymmdd or maximum value upon overflow.
INTERFACE:
int incrementDate( int yyyymmdd, int days )
PRE02( isValidYYYYMMDD( yyyymmdd ), days >= 0 )
POST0( isValidYYYYMMDD( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidYYYYMMDDHH - Is the date yyyymmddhh valid?
INPUTS:  int yyyymmddhh  E.g., 2009050112 is May 1, 2009 at noon.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidYYYYMMDDHH( int yyyymmddhh )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: incrementDateTime - The date (yyyymmddhh) incremented by hours.
INPUTS:  int yyyymmddhh  E.g., 2009050112 is May 1, 2009 noon.
         int hours      Number of hours to increment from yyyymmddhh.
RETURNS: int incremented yyyymmddhh or maximum value upon overflow.
INTERFACE:
int incrementDateTime( int yyyymmddhh, int hours )
PRE02( isValidYYYYMMDDHH( yyyymmddhh ), hours >= 0 )
POST0( isValidYYYYMMDDHH( result ) )



===============================================================================


 
TYPES:

enum { BOTTOM_UP_ROW_ORDER, TOP_DOWN_ROW_ORDER };

FUNCTIONS:


extern int readPNGFile( FILE* input, int width, int height, int rowOrder,
                        unsigned char rgb[] );

extern int writePNGFile( FILE* output, int width, int height,
                         unsigned char rgba[] );


#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: readPNGFile - Read a PNG image stream.
INPUTS:  FILE* input  Stream to read.
         int width    Image width in pixels to match.
         int height   Image height in pixels to match.
         int rowOrder Output BOTTOM_UP_ROW_ORDER or TOP_DOWN_ROW_ORDER.
OUTPUTS: unsigned char rgb[ height * width * 3 ]  RGB pixel values.
RETURNS: int 1 if successful, else 0 and a message is printed to stderr.
INTERFACE:
int readPNGFile( FILE* input, int width, int height, int rowOrder,
                 unsigned char rgb[] )

-------------------------------------------------------------------------------

PURPOSE: writePNGFile - Write a PNG file.
INPUTS:  FILE* output  File to write to.
         int width     Image width in pixels.
         int height    Image height in pixels.
         unsigned char rgba[ height * width * 4 ]  RGBA pixel values in
                                                   OpenGL bottom-up row order.
RETURNS: int 1 if successful, else 0 and a message is printed to stderr.
INTERFACE:
int writePNGFile( FILE* output, int width, int height, unsigned char rgba[] )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: MapFile.h - Declare routines to read .bin map polyline files.

-------------------------------------------------------------------------------

PURPOSE: MapFile.h - Define routines to read .bin map polyline files.

-------------------------------------------------------------------------------

PURPOSE: readMapFileHeader - Read header dimensions of map_*.bin file.
INPUTS:  FILE* file  Opened readable file.
OUTPUTS: int* polylineCount  Number of polylines in file.
         int* vertexCount    Number of lon-lat vertices in file.
RETURNS: int 1 if successful, else 0 and failureMessage is called.
INTERFACE:
int readMapFileHeader( FILE* file, int* polylineCount, int* vertexCount )
PRE03( file, polylineCount, vertexCount )
POST0( IMPLIES_ELSE( result,
                    GT_ZERO2( *polylineCount, *vertexCount ),
                    IS_ZERO2( *polylineCount, *vertexCount ) ) )

-------------------------------------------------------------------------------

PURPOSE: readMapFileData - Read data of map_*.bin file.
INPUTS:  FILE* file  Opened readable file, seeked to data.
         int polylineCount  Number of polylines in file.
         int vertexCount    Number of lon-lat vertex pairs in file.
OUTPUTS: int counts[ polylineCount ]  Array of vertex counts per polyline.
         float vertices[ vertexCount * 2 ] Array of lon-lat vertices.
RETURNS: int 1 if successful, else 0.
INTERFACE:
int readMapFileData( FILE* file,
                     int counts[], float vertices[] )
PRE05( file, polylineCount > 0, vertexCount > 0, counts, vertices )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: subsetMapFloat - Count and clip polylines to bounds.
INPUTS:  int inputPolylineCount  Number of polylines in input data.
         int inputVertexCount    Number of vertices in input data.
         const int inputCounts[inputPolylines] Vertex count per input polyline.
         const float inputVertices[ inputVertexCount * 2 ] Input vertices.
OUTPUTS: double resolution  Minimum distance between included points.
         const double bounds[ 2 ][ 2 ]  Longitude-latitude bounds to include.
                           bounds[ LONGITUDE, LATITUDE ][ MINIMUM, MAXIMUM ].
         int* outputPolylineCount  Number of polylines in output data.
         int* outputVertexCount    Number of vertices in output data.
         int outputCounts[outputPolylines] Vertex count per output polyline.
         float outputVertices[ outputVertexCount * 2 ] Output vertices if non-0
INTERFACE:
void subsetMapFloat( int inputPolylineCount,
                     float outputVertices[] )
PRE012( inputPolylineCount > 0,
        inputVertexCount > 0,
        inputCounts,
        inputCounts[ 0 ] > 0,
        inputCounts[ inputPolylineCount - 1 ] > 0,
        inputVertices,
        IN_RANGE( inputVertices[ 0 ], -180.0, 180.0 ),
        IN_RANGE( inputVertices[ 1 ],  -90.0,  90.0 ),
        resolution >= 0.0,
        isValidBounds( (const double (*)[2]) bounds ),
        outputPolylineCount,
        outputVertexCount )
POST0( IMPLIES_ELSE( *outputPolylineCount == 0, *outputVertexCount == 0,
         AND3( *outputVertexCount >= 2,
               IMPLIES( outputCounts,
                        AND2( minimumItemi( outputCounts,
                                            *outputPolylineCount ) >= 2,
                              sum( outputCounts, *outputPolylineCount )
                                == *outputVertexCount ) ),
               IMPLIES( outputVertices,
                        inBoundsFloat( outputVertices, *outputVertexCount,
                                       (const double (*)[2]) bounds ) ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: subsetMapDouble - Count and clip polylines to bounds.
INPUTS:  int inputPolylineCount  Number of polylines in input data.
         int inputVertexCount    Number of vertices in input data.
         const int inputCounts[inputPolylines] Vertex count per input polyline.
         const double inputVertices[ inputVertexCount * 2 ] Input vertices.
OUTPUTS: double resolution  Minimum distance between included points.
         const double bounds[ 2 ][ 2 ]  Longitude-latitude bounds to include.
                           bounds[ LONGITUDE, LATITUDE ][ MINIMUM, MAXIMUM ].
         int* outputPolylineCount  Number of polylines in output data.
         int* outputVertexCount    Number of vertices in output data.
         int outputCounts[outputPolylines] Vertex count per output polyline.
         double outputVertices[ outputVertexCount * 2] Output vertices if non-0
INTERFACE:
void subsetMapDouble( int inputPolylineCount,
                      double outputVertices[] )
PRE012( inputPolylineCount > 0,
        inputVertexCount > 0,
        inputCounts,
        inputCounts[ 0 ] > 0,
        inputCounts[ inputPolylineCount - 1 ] > 0,
        inputVertices,
        IN_RANGE( inputVertices[ 0 ], -180.0, 180.0 ),
        IN_RANGE( inputVertices[ 1 ],  -90.0,  90.0 ),
        resolution >= 0.0,
        isValidBounds( (const double (*)[2]) bounds ),
        outputPolylineCount,
        outputVertexCount )
POST0( IMPLIES_ELSE( *outputPolylineCount == 0, *outputVertexCount == 0,
         AND3( *outputVertexCount >= 2,
               IMPLIES( outputCounts,
                        AND2( minimumItemi( outputCounts,
                                            *outputPolylineCount ) >= 2,
                              sum( outputCounts, *outputPolylineCount )
                                == *outputVertexCount ) ),
               IMPLIES( outputVertices,
                        inBoundsDouble( outputVertices, *outputVertexCount,
                                        (const double (*)[2]) bounds )))))



===============================================================================


 
-------------------------------------------------------------------------------


FUNCTIONS:

unsigned char* readImageFile( const char* fileName, const Bounds clip,
                              int* width, int* height,
                              Bounds domain, Bounds corners );

#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: readImageFile - Read a subset of an image.
INPUTS:  const char* fileName  Name of image file (.bin).
         const Bounds clip     Optional Lon-lat bounds to clip image to or 0.
OUTPUTS: int* width            Subsetted image width in pixels.
         int* height           Subsetted image height in pixels.
         Bounds domain         Lon-lat bounds of unsubsetted image.
         Bounds corners        Lon-lat bounds of subsetted image.
RETURNS: unsigned char* array of RGB pixels of subsetted image.
NOTES:   free() result when no longer needed, e.g., when used as a texture.
INTERFACE:
unsigned char* readImageFile( const char* fileName, const Bounds clip,
                              Bounds domain, Bounds corners )
PRE07( fileName, *fileName,
       IMPLIES( clip, isValidBounds( clip ) ),
       width, height, domain, corners )
POST0( IMPLIES_ELSE( result,
                     AND4( *width > 0, *height > 0,
                           isValidBounds( (const double (*)[2]) domain ),
                           isValidBounds( (const double (*)[2]) corners ) ),
                     IS_ZERO10( *width, *height,
                                domain[0][0], domain[0][1],
                                domain[1][0], domain[1][1],
                                corners[0][0], corners[0][1],
                                corners[1][0], corners[1][1] ) ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: NetCDFUtilities.h - Declare convenience routines for NetCDF files.
NOTES:

TYPES:

/* Expose values used for 'type' parameters in below routines. */

#ifndef _NETCDF_
enum { NC_GLOBAL = -1, NC_CHAR = 2, NC_INT = 4, NC_FLOAT = 5, NC_DOUBLE = 6 };
#endif

FUNCTIONS:


extern int openReadableNetCDFFile( const char* fileName );

extern int createNetCDFFile( const char* fileName,
                             const int create64BitFile );

extern void closeNetCDFFile( const int file );

extern int endNetCDFHeaderDefinition( const int file );

extern int readNetCDFDimension( const int file, const char* name, int* value );

extern int createNetCDFDimensions( const int file,
                                   const int count,
                                   const char* const names[],
                                   const int values[],
                                   int ids[] );

extern int createNetCDFIOAPIVariables( const int file,
                                       const int dimensionIds[ 6 ],
                                       const int andElevation,
                                       const int forceUppercase,
                                       const int variables,
                                       const char* variableNames[],
                                       const char* variableUnits[] );

extern int createNetCDFIOAPITFLAGVariable( const int file,
                                           const int dimensionIds[ 6 ]  );

extern int createNetCDFIOAPIVariable( const int file,
                                      const int dimensionIds[ 6 ],
                                      const int forceUppercase,
                                      const char* variableName,
                                      const char* variableUnits );

extern int createNetCDFCoordinates( const int file,
                                    const int hasElevation,
                                    const int dimensionality,
                                    const int dimensions[] );

extern int writeNetCDFCOARDSAttributes( const int file,
                                        const double domain[2][2],
                                        const char* history );

extern int writeNetCDFCOARDSContents( const int file,
                                      const double domain[2][2],
                                      const char* history,
                                      const char timestamp[ 25 ],
                                      const int dimensions,
                                      const int dimensionIds[],
                                      const int dimensionSizes[],
                                      const float hours[] );

extern int createNetCDFVariable( const int file,
                                 const char* name,
                                 const char* units,
                                 const int type,
                                 const int hasMissingValues,
                                 const int dimensionality,
                                 const int* dimensionIds );

extern int readNetCDFIntAttribute( const int file,
                                   const char* name,
                                   int* value );

extern int writeNetCDFIntAttribute( const int file,
                                    const char* name,
                                    const int value );

extern int readNetCDFFloatAttribute( const int file,
                                     const char* name,
                                     float* value );

extern int writeNetCDFFloatAttribute( const int file,
                                      const int id,
                                      const char* name,
                                      const float value );

extern int readNetCDFDoubleAttribute( const int file,
                                      const char* name,
                                      double* value );

extern int writeNetCDFDoubleAttribute( const int file,
                                       const int id,
                                       const char* name,
                                       const double value );

extern int writeNetCDFTextAttribute( const int file,
                                     const int id,
                                     const char* name,
                                     const char* value );

extern int readNetCDFFloatArrayAttribute( const int file,
                                          const char* name,
                                          const int count,
                                          float values[] );

extern int writeNetCDFFloatArrayAttribute( const int file,
                                           const char* name,
                                           const float values[],
                                           const int count );

extern int readNetCDFDoubleArrayAttribute( const int file,
                                           const char* name,
                                           const int count,
                                           double values[] );

extern int writeNetCDFDoubleArrayAttribute( const int file,
                                            const char* name,
                                            const double values[],
                                            const int count );

extern int writeNetCDFAllData( const int file,
                               const char* variableName,
                               const int dimension1,
                               const int dimension2,
                               const int dimension3,
                               const int dimension4,
                               const float* data );

extern int writeNetCDFAllIntData( const int file,
                                  const char* variableName,
                                  const int dimension1,
                                  const int dimension2,
                                  const int dimension3,
                                  const int dimension4,
                                  const int* data );

extern int writeNetCDFCharData( const int file,
                                const char* variableName,
                                const int start,
                                const int length,
                                const char data[] );

extern int writeNetCDFSomeData( const int file,
                                const char* variableName,
                                const int timestep,
                                const int dimension1,
                                const int dimension2,
                                const int dimension3,
                                const int dimension4,
                                const float* data );

extern int writeNetCDFSomeIntData( const int file,
                                   const char* variableName,
                                   const int timestep,
                                   const int dimension1,
                                   const int dimension2,
                                   const int dimension3,
                                   const int dimension4,
                                   const int* data );


#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: openReadableNetCDFFile - Open a NetCDFFile for reading.
INPUTS:  const char* fileName       Name of file to open.
RETURNS: int NetCDF file ID if successful, else 0 if failed and
         a failure message is printed to stderr.
INTERFACE:
int openReadableNetCDFFile( const char* fileName )
PRE02( fileName, *fileName )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFFile - Create a NetCDFFile for writing.
INPUTS:  const char* fileName       Name of file to create.
         const int create64BitFile  Create 64-bit NetCDF file?
RETURNS: int NetCDF file ID if successful, else 0 if failed and
         a failure message is printed to stderr.
INTERFACE:
int createNetCDFFile( const char* fileName, const int create64BitFile )
PRE03( fileName, *fileName, IS_BOOL( create64BitFile ) )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: closeNetCDFFile - Close a NetCDFFile.
INPUTS:  const int file  ID of file to close.
INTERFACE:
void closeNetCDFFile( const int file )
PRE0( file >= 0 )
POST0( 1 )

-------------------------------------------------------------------------------

PURPOSE: endNetCDFHeaderDefinition - Close a NetCDFFile.
INPUTS:  const int file  ID of file to close.
INTERFACE:
int endNetCDFHeaderDefinition( const int file )
PRE0( file >= 0 )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFDimension - Read the named dimension of a NetCDF file.
INPUTS:  const int file    NetCDF file ID.
         const char* name  Name of dimension.
OUTPUTS: int* value        Value of dimension or 0 if unsuccessful.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFDimension( const int file, const char* name, int* value )
PRE04( file >= 0, name, *name, value )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result, *value >= 0, *value == 0 ) )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFDimensions - Create the named dimensions of a NetCDF file.
INPUTS:  const int file              NetCDF file ID.
         const int count             Number of dimensions.
         const char* const names[] Name of each dimension.
         const int values[]    Value of each dimension.
OUTPUTS: int ids[]             Ids of each dimension or -1 if unsuccessful.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFDimensions( const int file,
                            int ids[] )
PRE09( file >= 0, count > 0, names, *names, names[ count - 1 ],
       values, *values > 0, values[ count - 1 ] > 0, ids )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result,
                      AND2( ids[ 0 ] >=  0, ids[ count - 1 ] >=  0 ),
                      AND2( ids[ 0 ] == -1, ids[ count - 1 ] == -1 ) ) )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFIOAPIVariables - Create variables TFLAG, LONGITUDE,
         LATITUDE and optionally ELEVATION and then other named data variables.
INPUTS:  const int file               NetCDF file to write to.
         const int dimensionIds[ 6 ]  NetCDF ids of dimensions.
                                      TSTEP, DATE-TIME, LAY, VAR, ROW, COL.
         const int andElevation       Create elevation variable too?
         const int forceUppercase     Ensure variableNames are all capitals?
         const int variables          Number of data variables.
         const char* variableNames[ variables ]  Names of data variables.
         const char* variableUnits[ variables ]  Units of data variables.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFIOAPIVariables( const int file,
                                const char* variableUnits[] )
PRE021( file != -1,
        dimensionIds,
        dimensionIds[ 0 ] > -1,
        dimensionIds[ 1 ] > -1,
        dimensionIds[ 2 ] > -1,
        dimensionIds[ 3 ] > -1,
        dimensionIds[ 4 ] > -1,
        dimensionIds[ 5 ] > -1,
        IS_BOOL( andElevation ),
        IS_BOOL( forceUppercase ),
        variables > 0,
        variableNames,
        variableNames[ 0 ],
        variableNames[ 0 ][ 0 ],
        variableNames[ variables - 1 ],
        variableNames[ variables - 1 ][ 0 ],
        variableUnits,
        variableUnits[ 0 ],
        variableUnits[ 0 ][ 0 ],
        variableUnits[ variables - 1 ],
        variableUnits[ variables - 1 ][ 0 ] )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFIOAPITFLAGVariable - Create IOAPI variable TFLAG.
INPUTS:  const int file            NetCDF file to write to.
         const int dimensionIds[]  NetCDF ids of dimensions.
                                   TSTEP, DATE-TIME, LAY, VAR, ROW, COL.
RETURNS: int id if successful,
         else -1 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFIOAPITFLAGVariable( const int file,
                                    const int dimensionIds[ 6 ] )
PRE08( file != -1,
       dimensionIds,
       dimensionIds[ 0 ] > -1,
       dimensionIds[ 1 ] > -1,
       dimensionIds[ 2 ] > -1,
       dimensionIds[ 3 ] > -1,
       dimensionIds[ 4 ] > -1,
       dimensionIds[ 5 ] > -1 )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFIOAPIVariable - Create IOAPI variable.
INPUTS:  const int file               NetCDF file to write to.
         const int dimensionIds[ 6 ]  NetCDF ids of dimensions.
                                      TSTEP, DATE-TIME, LAY, VAR, ROW, COL.
         const int forceUppercase     Ensure variableNames are all capitals?
         const char* variableName     Name of variable.
         const char* variableUnits    Units of variable.
RETURNS: int id if successful,
         else -1 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFIOAPIVariable( const int file,
                               const char* variableUnits )
PRE013( file != -1,
        IS_BOOL( forceUppercase ),
        dimensionIds,
        dimensionIds[ 0 ] > -1,
        dimensionIds[ 1 ] > -1,
        dimensionIds[ 2 ] > -1,
        dimensionIds[ 3 ] > -1,
        dimensionIds[ 4 ] > -1,
        dimensionIds[ 5 ] > -1,
        variableName,
        variableName[ 0 ],
        variableUnits,
        variableUnits[ 0 ] )
POST0( result >= -1 )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFCoordinates - Create variables longitude, latitude and
         optionally elevation.
INPUTS:  const int file            NetCDF file to write to.
         const int andElevation    Create elevation variable too?
         const int dimensionality  Number of dimensions of each variable.
         const int dimensionIds[]  NetCDF ids of dimensions.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFCoordinates( const int file,
                             const int dimensionIds[] )
PRE06( file != -1, IS_BOOL( andElevation ), dimensionality > 0, dimensionIds,
       dimensionIds[ 0 ] > -1, dimensionIds[ dimensionality - 1 ] > -1 )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFCOARDSAttributes - Write COARDS header attributes.
INPUTS:  const int file             NetCDF file to write to.
         const double domain[2][2]  domain[LONGITUDE LATITUDE][MIMIMUM MAXIMUM]
         const char* history        Source/history of data (e.g., URL).
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFCOARDSAttributes( const int file,
                                 const char* history )
PRE08( file != -1,
       domain,
       isValidLongitudeLatitude( domain[ LONGITUDE ][ MINIMUM ],
                                 domain[ LATITUDE  ][ MINIMUM ] ),
       isValidLongitudeLatitude( domain[ LONGITUDE ][ MAXIMUM ],
                                 domain[ LATITUDE  ][ MAXIMUM ] ),
       domain[ LONGITUDE ][ MINIMUM ] <= domain[ LONGITUDE ][ MAXIMUM ],
       domain[ LATITUDE  ][ MINIMUM ] <= domain[ LATITUDE  ][ MAXIMUM ],
       history,
       *history )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFCOARDSContents - Write COARDS variables and attributes.
INPUTS:  const int file                NetCDF file to write to.
         const double domain[2][2]     Lon-lat bounds of data.
         const char* history           Source/history of data (e.g., URL).
         const char timestamp[ 25 ]    YYYY-MM-DDTHH:MM:SS-0000.
         const int dimensions          Number of dimensions for time varaible.
         const int dimensionIds[dimensions]  Dimensions Ids for time variable.
         const int dimensionSizes[dimensions] Dimensions sizes of time variable
         const float hours[ dimensionSizes[ 0 ] ]  Hour offsets to use
                                                   or 0 if sequential
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
NOTES:   endNetCDFHeaderDefinition() is called so only data may be written to
         file now.
INTERFACE:
int writeNetCDFCOARDSContents( const int file,
                               const float hours[] )
PRE017( file != -1,
        domain,
        isValidLongitudeLatitude( domain[ LONGITUDE ][ MINIMUM ],
                                  domain[ LATITUDE  ][ MINIMUM ] ),
        isValidLongitudeLatitude( domain[ LONGITUDE ][ MAXIMUM ],
                                  domain[ LATITUDE  ][ MAXIMUM ] ),
        domain[ LONGITUDE ][ MINIMUM ] <= domain[ LONGITUDE ][ MAXIMUM ],
        domain[ LATITUDE  ][ MINIMUM ] <= domain[ LATITUDE  ][ MAXIMUM ],
        history,
        *history,
        strlen( history ) < 128,
        isUTCTimestamp( timestamp ),
        IN_RANGE( dimensions, 1, 4 ),
        dimensionIds,
        dimensionIds[ 0 ] > -1,
        dimensionIds[ dimensions - 1 ] > -1,
        dimensionSizes,
        dimensionSizes[ 0 ] > 0,
        dimensionSizes[ dimensions - 1 ] > 0 )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: createNetCDFVariable - Create the named variable of a NetCDF file.
INPUTS:  const int file              NetCDF file ID.
         const char* name            Name of variable.
         const char* units           Units of variable.
         const int type              Type of variable.
         const int hasMissingValues  Can there be missing data values?
         const int dimensionality    Number of dimensions.
         const int* dimensionIds     Ids of dimensions.
RETURNS: int variable id > -1 if successful,
         else -1 and a failure message is printed to stderr.
INTERFACE:
int createNetCDFVariable( const int file,
                          const int* dimensionIds )
PRE010( file >= 0, name, *name, units, *units,
        IN5( type, NC_INT, NC_FLOAT, NC_DOUBLE, NC_CHAR ),
        IS_BOOL( hasMissingValues ),
        dimensionality >= 1, dimensionIds,
        OR2( dimensionIds[ 0 ] == NC_UNLIMITED, dimensionIds[ 0 ] >= 0 ) )
POST0( result >= -1 )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFIntAttribute - Read the value of a global integer
         attribute to a NetCDF file.
INPUTS:  const int file    NetCDF file ID.
         const char* name  Name of attribute.
OUTPUTS: int* value        Value of attribute or 0 if failed.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFIntAttribute( const int file, const char* name, int* value )
PRE04( file >= 0, name, *name, value )
POST02( IS_BOOL( result ), IMPLIES( result == 0, *value == 0 ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFIntAttribute - Write the value of a global integer
         attribute to a NetCDF file.
INPUTS:  const int file    NetCDF file ID.
         const char* name  Name of attribute.
         const int value   Value for attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFIntAttribute( const int file,
                             const int value )
PRE03( file >= 0, name, *name )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFFloatAttribute - Read the value of a global float
         attribute to a NetCDF file.
INPUTS:  const int file    NetCDF file ID.
         const char* name  Name of attribute.
OUTPUTS: float* value      Value of attribute or 0.0 if failed.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFFloatAttribute( const int file, const char* name, float* value )
PRE04( file >= 0, name, *name, value )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result, ! isNan( *value ), *value == 0.0 ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFFloatAttribute - Write the value of a float attribute to
         a NetCDF file.
INPUTS:  const int file      NetCDF file ID.
         const int id        NetCDF variable ID or NC_GLOBAL.
         const char* name    Name of attribute.
         const float value  Value for attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFFloatAttribute( const int file, const int id,
                               const char* name, const float value )
PRE05( file >= 0, OR2( id == NC_GLOBAL, id >= 0 ),
       name, *name, ! isNan( value ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFDoubleAttribute - Read the value of a global double
         attribute to a NetCDF file.
INPUTS:  const int file    NetCDF file ID.
         const char* name  Name of attribute.
OUTPUTS: double* value     Value of attribute or 0.0 if failed.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFDoubleAttribute(const int file, const char* name, double* value)
PRE04( file >= 0, name, *name, value )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result, ! isNan( *value ), *value == 0.0 ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFDoubleAttribute - Write the value of a double attribute to
         a NetCDF file.
INPUTS:  const int file      NetCDF file ID.
         const int id        NetCDF variable ID or NC_GLOBAL.
         const char* name    Name of attribute.
         const double value  Value for attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFDoubleAttribute( const int file, const int id,
                                const char* name, const double value )
PRE05( file >= 0, OR2( id == NC_GLOBAL, id >= 0 ),
       name, *name, ! isNan( value ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFTextAttribute - Write the value of a text attribute.
INPUTS:  const int file    NetCDF file ID.
         const int id      NetCDF variable ID or NC_GLOBAL.
         const char* name  Name of attribute.
         const char* value Value of named attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFTextAttribute( const int file, const int id, const char* name,
                              const char* value )
PRE06( file >= 0, OR2( id == NC_GLOBAL, id >= 0 ),
       name, *name, value, *value )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFFloatArrayAttribute - Read a float array attribute.
INPUTS:  const int file         NetCDF file ID to write to.
         const char* name       Name of attribute.
         const int count        Number of elements in values array.
OUTPUTS: float values[ count ]  Value of attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFFloatArrayAttribute( const int file, const char* name,
                                   const int count, float values[] )
PRE05( file >= 0, name, *name, values, count > 0 )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result,
                      isNanFreeF( values, count ),
                      IS_ZERO2( values[ 0 ], values[ count - 1 ] ) ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFFloatArrayAttribute - Write a float array attribute.
INPUTS:  const int file              NetCDF file ID to write to.
         const char* name            Name of attribute.
         const int count             Number of elements in values array.
         const float values[ count ] Value of attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFFloatArrayAttribute( const int file, const char* name,
                                    const float values[], const int count )
PRE06( file >= 0, name, *name, values, count > 0, isNanFreeF(values, count))
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: readNetCDFDoubleArrayAttribute - Read a double array attribute.
INPUTS:  const int file         NetCDF file ID to write to.
         const char* name       Name of attribute.
         const int count        Number of elements in values array.
OUTPUTS: double values[ count ]  Value of attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int readNetCDFDoubleArrayAttribute( const int file, const char* name,
                                    const int count, double values[] )
PRE05( file >= 0, name, *name, values, count > 0 )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( result,
                      isNanFree( values, count ),
                      IS_ZERO2( values[ 0 ], values[ count - 1 ] ) ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFDoubleArrayAttribute - Write a double array attribute.
INPUTS:  const int file               NetCDF file ID to write to.
         const char* name             Name of attribute.
         const int count              Number of elements in values array.
         const double values[ count ] Value of attribute.
RETURNS: int 1 if successful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFDoubleArrayAttribute( const int file, const char* name,
                                     const double values[], const int count )
PRE06( file >= 0, name, *name, values, count > 0, isNanFree(values, count))
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFAllData - Write all data to the NetCDF file.
INPUTS:  int file                  NetCDF file handle.
         const char* variableName  Name of variable to write.
         const int dimension1      E.g., timesteps.
         const int dimension2      E.g., layers or 1.
         const int dimension3      E.g., rows or 1.
         const int dimension4      E.g., columns or 1.
         const float data[]        Data to write.
RETURNS: int 1 if unsuccessful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFAllData( const int file, const char* variableName,
                        const float data[] )
PRE06( file > -1, variableName, *variableName, dimension1 > 0,
        GT_ZERO3( dimension2, dimension3, dimension4 ), data )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFAllIntData - Write all data to the NetCDF file.
INPUTS:  const int file            NetCDF file handle.
         const char* variableName  Name of variable to write.
         const int dimension1      E.g., timesteps.
         const int dimension2      E.g., layers or 1.
         const int dimension3      E.g., rows or 1.
         const int dimension4      E.g., columns or 1.
         const int data[]          Data to write.
RETURNS: int 1 if unsuccessful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFAllIntData( const int file, const char* variableName,
                           const int data[] )
PRE06( file > -1, variableName, *variableName, dimension1 > 0,
        GT_ZERO3( dimension2, dimension3, dimension4 ), data )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFCharData - Write character data to the NetCDF file.
INPUTS:  const int file            NetCDF file handle.
         const char* variableName  Name of variable to write.
         const int start           Starting index of first dimension.
         const int length          Length of each item in data[].
         const char data[ count ]  Data to write: data[ count * length ].
RETURNS: int 1 if unsuccessful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFCharData( const int file, const char* variableName,
                         const char data[] )
PRE07( file > -1, variableName, *variableName,
       start >= 0, length > 0, length < 1000, data )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFSomeData - Write some data to the NetCDF file.
INPUTS:  const int file            NetCDF file handle.
         const char* variableName  Name of variable to write.
         const int timestep        0-based timestep index to write.
         const int dimension1      E.g., subset range of timesteps or 1.
         const int dimension2      E.g., layers or 1.
         const int dimension3      E.g., rows or 1.
         const int dimension4      E.g., columns or 1.
         const float data[]        Data to write.
RETURNS: int 1 if unsuccessful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFSomeData( const int file, const char* variableName,
                         const float data[] )
PRE06( file > -1, variableName, *variableName, timestep >= 0,
        GT_ZERO4( dimension1, dimension2, dimension3, dimension4 ), data )

-------------------------------------------------------------------------------

PURPOSE: writeNetCDFSomeIntData - Write some int data to the NetCDF file.
INPUTS:  const int file            NetCDF file handle.
         const char* variableName  Name of variable to write.
         const int timestep        0-based timestep index to write.
         const int dimension1      E.g., subset range of timesteps or 1.
         const int dimension2      E.g., layers or 1.
         const int dimension3      E.g., rows or 1.
         const int dimension4      E.g., columns or 1.
         const int data[]          Data to write.
RETURNS: int 1 if unsuccessful,
         else 0 and a failure message is printed to stderr.
INTERFACE:
int writeNetCDFSomeIntData( const int file, const char* variableName,
                            const int data[] )
PRE06( file > -1, variableName, *variableName, timestep >= 0,
        GT_ZERO4( dimension1, dimension2, dimension3, dimension4 ), data )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: Shapefile.h - Declare routines for ESRI Shapefile creation.

NOTES:   Uses Shapefile and GPC free, open-source libraries.
         http://shapelib.maptools.org/shp_api.html
         http://www.cs.man.ac.uk/~toby/alan/software/gpc.html


TYPES:

/* Unproject (x, y) to (lon, lat): */

typedef void (*Unproject)( double, double, double*, double* );

typedef struct {
  int id;                 /* From original input Shapefile. */
  Bounds bounds;          /* Bounds of polygon or triangles. */
  gpc_polygon polygon;    /* After clipping to bounds. */
  gpc_tristrip triangles; /* Triangle strip for rendering. */
} PolygonShape;

/* Data read from a DBF file: */

typedef union {
  const char* s; /* String value. */
  int         i; /* int value. */
  double      d; /* double value. */
} Value;

typedef struct {
  int    rows;          /* Number of data rows. */
  int    columns;       /* Number of data columns. */
  char** columnNames;   /* columnNames[ columns ] name of each column. */
  int*   columnTypes;   /* columnTypes[columns] FTString, FTInteger, FTDouble*/
  Value* values;        /* values[ rows * columns ]. */
  char** stringStorage; /* Array of allocated unique strings Flyweight.*/
  int    capacity;      /* Number of strings in stringStorage[]. */
} ShapeData;


FUNCTIONS:

/* Point, Polyline and Grid routines: */

extern int writeASCIIGridFile( const char* fileName,
                               int rows, int columns,
                               double westEdge, double southEdge,
                               double cellSize,
                               int type,
                               const void* data );

extern int writeLambertPRJFile( const char* fileName,
                                const double centralLongitude,
                                const double centralLatitude,
                                const double lowerLatitude,
                                const double upperLatitude,
                                const int useASCIIGridForm );

extern int writeWGS84PRJFile( const char* fileName,
                              const int useASCIIGridForm );

extern int writeGridToShapefile( const char* baseFileName,
                                 const int timesteps,
                                 const int yyyymmddhh[],
                                 const int timestepType,
                                 const int rows,
                                 const int columns,
                                 const double westEdge,
                                 const double southEdge,
                                 const double cellWidth,
                                 const double cellHeight,
                                 const char* variable,
                                 const char* units,
                                 int type,
                                 int components,
                                 const void* data,
                                 Unproject unproject );

extern void writePointsToShapefile( const char* const fileName,
                                    const char* const variableName,
                                    const char* const units,
                                    const int timesteps,
                                    const int hoursPerTimestep,
                                    const int yyyymmddhh[],
                                    const int count,
                                    const float lonlats[],
                                    const float z[],
                                    const int components,
                                    const float data[],
                                    const char* const sids[] );

extern int writePolylinesToShapefile( const char* baseFileName,
                                      const int polyLineCount,
                                      const int vertexCount,
                                      const int counts[],
                                      const float lonlats[] );

extern void computePolygonVertices( const int row, const int column,
                                    const double westEdge,
                                    const double southEdge,
                                    const double cellWidth,
                                    const double cellHeight,
                                    Unproject unproject,
                                    double xy[ 5 * 2 ],
                                    double xyRange[ 2 * 2 ] );

extern void computeGridCellVertices( const int rows,
                                     const int columns,
                                     const float longitudes[],
                                     const float latitudes[],
                                     float vertices[] );

/* SHP, GPC PolygonShape routines: */

extern void printShape( const SHPObject* shape );

extern void printPolygon( const gpc_polygon* polygon );
  
extern void printTriangles( const gpc_tristrip* tristrip );

extern void deallocatePolygons( int count, PolygonShape polygonShapes[] );

extern PolygonShape* copyPolygons( int count,
                                   const PolygonShape polygonShapes[] );

extern int shapefileType( const char* baseFileName );

extern PolygonShape* readAndClipShapes( const char* baseFileName,
                                        const Bounds bounds,
                                        double minimumAdjacentVertexDistance,
                                        const char* mask,
                                        int* count, int* isPolyline );

extern PolygonShape* readAndTriangulateShapes( const char* baseFileName,
                                               int* count );

extern int pointInTriangles( double x, double y,
                             int count, const PolygonShape polygons[] );

extern int pointInsideTriangle( double x, double y,
                                double x1, double y1,
                                double x2, double y2,
                                double x3, double y3 );

extern double areaOfTriangle( double x1, double y1,
                              double x2, double y2,
                              double x3, double y3 );

extern double pointLineDistance( double x, double y,
                                 double x1, double y1,
                                 double x2, double y2 );

extern int colinear( const double x1, const double y1,
                     const double x2, const double y2,
                     const double x3, const double y3 );

extern int makePolygon( const SHPObject* shape,
                        double minimumAdjacentVertexDistance,
                        gpc_polygon* polygon,
                        Bounds bounds );

extern int clipPolylines( const gpc_polygon* const polylines,
                          const Bounds clipBounds,
                          gpc_polygon* clippedPolylines,
                          Bounds polylinesBounds );

extern int nearestPolyline( const double x, const double y,
                            const int count, const PolygonShape polylines[] );

extern int nearestPoint( const double x, const double y,
                         const ShapeData* const shapeData );

extern int ensureCorrectVertexOrder( gpc_polygon* polygon );

extern void reverseVertexList( gpc_vertex_list* vertex_list );

extern double signedAreaOfPolygon( const gpc_vertex_list* vertex_list );

extern int maximumPolygonContours( int count, const PolygonShape polygons[] );

extern int maximumPolygonertices( int count, const PolygonShape polygons[] );

extern int polygonVertexCount( const gpc_polygon* polygon );

extern void copyPolygonVertices( const gpc_polygon* polygon, int closeRing,
                                 int starts[], double x[], double y[] );


extern int writePolygonsToShapefile( SHPHandle outputFile, int isPolyline,
                                     int count, const PolygonShape polygons[]);

extern int copySubsetShapefile( SHPHandle inputFile, SHPHandle outputFile,
                                const int count, const char* mask );

extern int writePolygonDBF( const char* inputFileName, DBFHandle outputFile,
                            int offset, int count, const char* mask,
                            const PolygonShape polygons[] );

extern int writePointSubsetDBF( const char* inputFileName, const Bounds,
                                const long long huc, char** mask,
                                DBFHandle outputFile );

extern int writeBoundsDBF( const char* fileName,
                           const double areaInSquareKilometers );

extern int streamShapefiles( const char* baseFileName, const char* name,
                             const int dbfOnly, const int csv );

extern void removeShapefiles( const char* baseFileName, int dbfOnly );

/* ShapeData routines: */

extern ShapeData* readDBF( const char* fileName );

extern char* subsetDBFByTime( const char* fileName,
                              int yyyymmdd1, int yyyymmdd2 );

extern int writeShapeDataToText( const ShapeData* shapeData,
                                 const char* outputFileName );

extern int writeShapeData( const char* baseFileName,
                           const ShapeData* shapeData );

extern void deallocateShapeData( ShapeData* shapeData );

extern ShapeData* copyShapeData( const ShapeData* const shapeData );

extern int equalShapeData( const ShapeData* const shapeData1,
                           const ShapeData* const shapeData2 );

extern void printShapeData( const ShapeData* shapeData );

extern int isValidShapeData( const ShapeData* shapeData );
  
/* Value routines: */

extern int isValidColumnName( const char* columnName );

extern int isValidValue( int type, const char* units, Value value );

extern int compareValues( int type, Value value1, Value value2 );

#ifdef __cplusplus
}
#endif

-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: defineDBFColumns - Define columns of an output DBF file.
INPUTS:  const char* inputFileName  File name of input dbf.
         const int defineColumns    If 1 then define columns else just compute
                                    tableIndex and column count.
OUTPUTS: int* tableIndex            Index into table of first column.
         int* longitudeColumn       Index of column LONGITUDE, else -1 if none.
         int* latitudeColumn        Index of column LATITUDE,  else -1 if none.
         int* hucIdColumn           Index of column HUC_ID,    else -1 if none.
         DBFHandle outputFile       DBF file to write to.
RETURNS: int number of columns defined if successful,
         else 0 and a failure message is printed ro stderr.
INTERFACE:
int defineDBFColumns( const char* const inputFileName,
                             DBFHandle outputFile )
PRE05( inputFileName, *inputFileName, IS_BOOL( defineColumns ), tableIndex,
       outputFile )
POST0( OR2( AND5( result == 0,
                  *tableIndex == -1,
                  IMPLIES( longitudeColumn, *longitudeColumn == -1 ),
                  IMPLIES( latitudeColumn,  *latitudeColumn  == -1 ),
                  IMPLIES( hucIdColumn,     *hucIdColumn     == -1 ) ),
            AND2( result > 0,
                  *tableIndex >= 0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: writeASCIIGridFile - Write a single timestep-layer of grid cell scalar
         data to an ESRI ASCII Grid file.
INPUTS:  const char* const fileName  File to create. E.g.,"example.asc".
         int rows              Number of grid rows.
         int columns           Number of grid columns.
         double westEdge       Distance from origin to west edge of grid.
         double southEdge      Distance from origin to south edge of grid.
         double cellSize       Width/height of each grid cell.
         int type              Grid cell scalar data type: BYTE_TYPE, etc.
         const void* data      data[ rows * columns ] Scalar at cell centers.
NOTES:   Creates file fileName.
         http://en.wikipedia.org/wiki/ESRI_grid
INTERFACE:
int writeASCIIGridFile( const char* fileName, int rows, int columns,
                        int type, const void* data )
PRE012( fileName,
        *fileName,
        rows > 0,
        columns > 0,
        rows < INT_MAX / columns,
        ! isNan( westEdge ),
        ! isNan( southEdge ),
        ! isNan( cellSize ),
        cellSize > 0.0,
        IS_VALID_GRID_DATA_TYPE( type ),
        data,
        IMPLIES( type == FLOAT_TYPE,
                 AND2( ! isNan( ((const float*) data)[ 0 ] ),
                       ! isNan(((const float*)data)[rows * columns - 1]))))

-------------------------------------------------------------------------------

PURPOSE: writeWGS84PRJFile - Write a WGS84 ESRI projection file.
INPUTS:  const char* const fileName  File to create. E.g.,"example.prj".
         const int         useASCIIGridForm  1 = use grid form, 0 = shape form.
NOTES:   Creates file fileName.
         http://en.wikipedia.org/wiki/Well-known_text
INTERFACE:
int writeWGS84PRJFile( const char* fileName, const int useASCIIGridForm )
PRE03( fileName, *fileName, IS_BOOL( useASCIIGridForm ) )

-------------------------------------------------------------------------------

PURPOSE: writeLambertPRJFile - Write a Lambert ESRI projection file.
INPUTS:  const char* const fileName  File to create. E.g.,"example.prj".
         double centralLongitude     Longitude of center of projection. -90.0.
         double centralLatitude      Latitude of center of projection. 40.0.
         double lowerLatitude        Latitude of lower tangent. 30.0.
         double upperLatitude        Latitude of upper tangent. 60.0.
         const int useASCIIGridForm  1 = use grid form, 0 = shape form.
NOTES:   Creates file fileName. Uses MM5 sphere of radius 6,370,000m.
         http://en.wikipedia.org/wiki/Well-known_text
INTERFACE:
int writeLambertPRJFile( const char* fileName,
                         const int useASCIIGridForm )
PRE011( fileName,
        *fileName,
        isValidLongitudeLatitude( centralLongitude, centralLatitude ),
        IN_RANGE( centralLatitude, -89.0, 89.0 ),
        IN_RANGE( lowerLatitude,   -90.0, 90.0 ),
        IN_RANGE( upperLatitude,   -90.0, 90.0 ),
        lowerLatitude <= upperLatitude,
        SIGN( lowerLatitude ) == SIGN( upperLatitude ),
        IMPLIES_ELSE( lowerLatitude >= 0.0,
                      IN_RANGE( lowerLatitude, 1.0, 89.0 ),
                      IN_RANGE( lowerLatitude, -89.0, -1.0 ) ),
        IMPLIES_ELSE( upperLatitude >= 0.0,
                      IN_RANGE( upperLatitude, 1.0, 89.0 ),
                      IN_RANGE( upperLatitude, -89.0, -1.0 ) ),
        IS_BOOL( useASCIIGridForm ) )

-------------------------------------------------------------------------------

PURPOSE: writeGridToShapefile - Write a single layer of grid cells as a lon-lat
         Shapefile Polygon file set (shp, shx, dbf, prj) and a csv file
         containing time-varying data.
INPUTS:  const char* const fileName  Base name of file to create. "example".
         const int timesteps         Number of timesteps of data.
         const int yyyymmddhh[ timesteps ]  Timestamps of data.
         const int timestepType      HOURLY, DAILY, MONTHLY, YEARLY.
         const int rows              Number of grid rows.
         const int columns           Number of grid columns.
         const double westEdge       Distance from origin to west edge of grid.
         const double southEdge      Distance from origin to south edge of ".
         const double cellWidth      Width of each grid cell (e.g., 12000 m).
         const double cellWHeight    Height of each grid cell (e.g., 12000 m).
         const char* variable        Name of data variable.
         const char* units           Name of data units.
         int type                    Grid cell scalar data type: BYTE_TYPE...
         const void* data            data[ timesteps * rows * columns ]
                                     Scalar data at grid cell centers.
         Unproject unproject         Function to unproject (x,y) to (lon,lat).
RETURNS: int 1 if successful, else 0 and failure message is printed to stderr.
NOTES:   Creates files fileName.shp and fileName.shx
         then calls routines that create fileName.dbf and fileName.csv.
         See 1998 ESRI Shapefile Specification pages 2, 4, 5, 16, 23, 24.
         http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf
         This routine does not use shapelib API since it was written before
         that library was used in this project and also because this routine
         is more straight-forward and much faster than using the shapelib API.
INTERFACE:
int writeGridToShapefile( const char* fileName,
                          Unproject unproject )
PRE016( fileName,
        *fileName,
        timesteps > 0,
        yyyymmddhh,
        IS_VALID_TIMESTEP_TYPE( timestepType ),
        rows > 0,
        columns > 0,
        rows * columns > 0,
        variable,
        *variable,
        units,
        *units,
        IS_VALID_GRID_DATA_TYPE( type ),
        data,
        IMPLIES( type == FLOAT_TYPE,
                 AND2( ! isNan( ((const float*) data)[ 0 ] ),
           ! isNan(((const float*)data)[timesteps * rows * columns - 1]))),
        IMPLIES( unproject == 0,
                 AND2 ( isValidLongitudeLatitude( westEdge, southEdge ),
                        isValidLongitudeLatitude(
                                    westEdge  + columns * cellWidth,
                                    southEdge + rows    * cellHeight ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: writePointsToShapefile - Write points as a lon-lat Shapefile Point
         file set (shp, shx, dbf, prj) and a csv file containing time-varying
         data.
INPUTS:  const char* const fileName      Base name of file to create. "storet".
         const char* const variableName  Name of variable. E.g., "salinity".
         const char* const units         Units of variable. E.g., "PSU".
         const int timesteps             Number of timesteps of data.
         const int hoursPerTimestep      Number of hours per timestep. 1, 24.
         const int yyyymmddhh[ timesteps ]  Timestamps of data or 0 if no data.
         const int count                    Number of points per timestep.
         const float lonlats[ count * 2 ]   Lon-lats.
         const float z[ count ]             Optional: z coordinate of points.
         const int components               1 = scalar, 2, 3 = vector.
         const float data[ components ][ timesteps * count ]
                                         Optional: component data per point.
         const char* const sids[ count ]   Station id strings or 0.
RETURNS: int 1 if successful, else 0 and failure message is printed to stderr.
NOTES:   Creates files fileName.shp and fileName.shx
         then calls routines that create fileName.dbf and fileName.csv.
         See 1998 ESRI Shapefile Specification pages 2, 4, 5, 15, 23, 24.
         http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf
         This routine does not use shapelib API since it was written before
         that library was used in this project and also because this routine
         is more straight-forward and much faster than using the shapelib API.
INTERFACE:
void writePointsToShapefile( const char* const fileName,
                             const char* const sids[] )
PRE013( fileName,
        *fileName,
        IMPLIES( data, AND3( variableName, *variableName, units ) ),
        IMPLIES( data, timesteps > 0 ),
        IMPLIES( data, hoursPerTimestep > 0 ),
        IMPLIES( data, yyyymmddhh ),
        count > 0,
        lonlats,
        isValidLongitudeLatitude( lonlats[ 0 ], lonlats[ 1 ] ),
        isValidLongitudeLatitude( lonlats[  count * 2 - 2 ],
                                     lonlats[  count * 2 - 1 ] ),
        IMPLIES( z, AND2( ! isNan( z[ 0 ] ), ! isNan( z[ count - 1 ] ) ) ),
        IMPLIES( timesteps > 1, AND2( components > 0, data ) ),
        IMPLIES( data, AND2( ! isNan( data[ 0 ] ),
                             ! isNan( data[ timesteps * count - 1 ] ) ) ) )

-------------------------------------------------------------------------------

PURPOSE: writePolylinesToShapefile - Write a polyline coordinates as a lon-lat
         Shapefile Polyline file set (shp, shx, dbf, prj).
INPUTS:  const char* baseFileName  Base name of file to create. "edm_bounds".
         const int polylineCount   Number of polylines.
         const int vertexCount     Number of vertices.
         const int counts[ polylineCount ]   Number of vertices per polyline.
         const float lonlats[ vertexCount * 2 ]  Lon-lat vertices.
RETURNS: int 1 if successful, else 0 and a message is printed to stderr.
NOTES:   Creates files fileName.shp and fileName.shx.
         See 1998 ESRI Shapefile Specification pages 2, 4, 5, 16, 23, 24.
         http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf
         This routine does not use shapelib API since it was written before
         that library was used in this project and also because this routine
         is more straight-forward and much faster than using the shapelib API.
INTERFACE:
int writePolylinesToShapefile( const char* baseFileName,
                               const float lonlats[] )

-------------------------------------------------------------------------------

PURPOSE: computePolygonVertices - Compute vertices of grid cell as an
         explicitly closed 2D 5-vertex polygon ring in clockwise order.
INPUTS:  const int row             0-based row index of grid cell.
         const int column          0-based column index of grid cell.
         const double westEdge     Distance from origin to west edge of grid.
         const double southEdge    Distance from origin to south edge of ".
         const double cellWidth    Width of each grid cell (e.g., 12000 m).
         const double cellWHeight  Height of each grid cell (e.g., 12000 m).
OUTPUTS: double xy[ 5 * 2 ]        Sequence of polygon (x, y) vertices.
         double xyRange[ 2 * 2 ]   xMin, yMin, xMax, yMax.
INTERFACE:
void computePolygonVertices( const int row, const int column,
                             double xyRange[ 2 * 2 ] )

-------------------------------------------------------------------------------

PURPOSE: computeGridCellVertices - Compute lon-lat coordinates of rectangular
         grid cell corners.
INPUTS:  const int rows                            Number of grid row cells.
         const int columns                         Number of grid column cells.
         const float longitudes[ rows * columns ]  Longitude of cell center.
         const float latitudes[  rows * columns ]  Latitude of cell center.
OUTPUTS: float vertices[ ( rows + 1 ) * ( columns + 1 ) * 2 ]
         Corners in grid cell order with interleaved lon-lat coordinates.
NOTES:   Uses linear interpolation and extrapolation to the edges.
INTERFACE:
void computeGridCellVertices( const int rows, const int columns,
                              const float latitudes[], float vertices[] )
PRE08( rows > 1, columns > 1, rows * columns >= 4,
       longitudes, latitudes, vertices,
       isValidLongitudeLatitude( longitudes[ 0 ], latitudes[ 0 ] ),
       isValidLongitudeLatitude( longitudes[ rows * columns - 1 ],
                                    latitudes[ rows * columns - 1 ] ) )
POST02( isValidLongitudeLatitude( vertices[ 0 ], vertices[ 1 ] ),
        isValidLongitudeLatitude( vertices[(rows+1)*(columns+1)* 2 - 2 ],
                                     vertices[(rows+1)*(columns+1)* 2 - 1]))

-------------------------------------------------------------------------------

PURPOSE: printShape - Print a ESRI polygon shape for debugging purposes.
INPUTS:  const SHPObject* shape  Shape to print.
NOTES:   http://shapelib.maptools.org/shp_api.html
INTERFACE:
void printShape( const SHPObject* shape )
PRE02( shape, shape->nVertices >= 2 )

-------------------------------------------------------------------------------

PURPOSE: printPolygon - Print a polygon for tracing/debugging purposes.
INPUTS:  const gpc_polygon* polygon  Polygon to print.
NOTES:   http://www.cs.man.ac.uk/~toby/alan/software/gpc.html
INTERFACE:
void printPolygon( const gpc_polygon* polygon )

-------------------------------------------------------------------------------

PURPOSE: printTriangles - Print a triangle strip for debugging purposes.
INPUTS:  const gpc_tristrip* tristrip  Tristrip to print.
NOTES:   http://www.cs.man.ac.uk/~toby/alan/software/gpc.html
INTERFACE:
void printTriangles( const gpc_tristrip* tristrip )

-------------------------------------------------------------------------------

PURPOSE: deallocatePolygons - Deallocate polygonShapes.
OUTPUTS: int count                            Number of polygonShapes.
         PolygonShape polygonShapes[ count ]  PolygonShapes to deallocate.
INTERFACE:
void deallocatePolygons( int count, PolygonShape polygonShapes[] )
PRE02( count >= 0, IMPLIES( count, polygonShapes ) )
POST0( polygonShapes == 0 )

-------------------------------------------------------------------------------

PURPOSE: copyPolygons - Copy polygons.
OUTPUTS: int count                                  Number of polygons.
         const PolygonShape polygonShapes[ count ]  polygonShapes to copy.
RETURNS: PolygonShape* Allocated array of count objects or 0 if failed and
         a message is printed to stderr.
INTERFACE:
PolygonShape* copyPolygons( int count, const PolygonShape polygonShapes[] )
PRE02( count >= 0, IMPLIES( count, polygonShapes ) )

-------------------------------------------------------------------------------

PURPOSE: shapefileType - Get type of shapefile: SHPT_POLYGON, SHPT_ARC, etc.
INPUTS:  const char* baseFileName   Base name (no ext) of Shapefile to read.
RETURNS: int type if successful, else 0 and a failure message is printed.
INTERFACE:
int shapefileType( const char* baseFileName )
PRE02( baseFileName, *baseFileName )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: masklipShapes - Read and clip and return array of
         shapes (with ids) clipped to the given bounds.
INPUTS:  const char* baseFileName   Base name (no ext) of Shapefile to read.
         const Bounds bounds        Clip bounds.
         double minimumAdjacentVertexDistance  Adjacent vertices closer than
                                               this (in either x or y) will
                                               be merged.
         const char* mask           0 or mask[] to filter shapes by.
OUTPUTS: int* count                 Length of returned array.
         int* isPolyline            Is shape a polyline?
RETURNS: PolygonShape* if successful, else 0 and a failure message is printed.
INTERFACE:
PolygonShape* readAndClipShapes( const char* baseFileName, const Bounds bounds,
                                 int* count, int* isPolyline )
PRE04( baseFileName, bounds, count, isPolyline )
POST0( IMPLIES_ELSE( result == 0,
                      *count == 0,
                      AND6( *count > 0,
                            IS_BOOL( *isPolyline ),
                            result[ 0 ].id >= 0,
                            result[ 0 ].polygon.num_contours > 0,
                            result[ 0 ].polygon.hole != 0,
                            result[ 0 ].polygon.contour != 0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: readAndTriangulateShapes - Read and triangulate and return array of
         shapes (with ids).
INPUTS:  const char* baseFileName   Base name (no ext) of Shapefile to read.
OUTPUTS: int* count                 Length of returned array.
RETURNS: PolygonShape* if successful, else 0 and a failure message is printed.
INTERFACE:
PolygonShape* readAndTriangulateShapes( const char* baseFileName, int* count)
PRE02( baseFileName, count )
POST0( IMPLIES_ELSE( result == 0,
                      *count == 0,
                      AND4( *count > 0,
                            result[ 0 ].id >= 0,
                            result[ 0 ].triangles.num_strips > 0,
                            result[ 0 ].triangles.strip != 0 ) ) )

-------------------------------------------------------------------------------

PURPOSE: pointInTriangles - Is the specified point (x, y) in any of the set of
         triangles? If so return its index, else -1.
INPUTS:  double x          X-coordinate of point to test.
         double y          Y-coordinate of point to test.
         int count         Number of polygons in polygons[].
         const PolygonShape polygons[ count ]  Array of triangulated polygons.
RETURNS: int index [0, count - 1] if the point is inside the indexed triangles,
         else -1.
INTERFACE:
int pointInTriangles( double x, double y,
                      int count, const PolygonShape polygons[] )
PRE07( ! isNan( x ) , ! isNan( y ), count > 0, polygons,
       isValidBounds( (const double (*)[2]) polygons[ 0 ].bounds ),
       polygons[ 0 ].triangles.num_strips > 0,
       polygons[ count - 1 ].triangles.num_strips > 0 )
POST0( IN_RANGE( result, -1, count - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: pointInsideTriangle - Determine if point (x, y) is inside triangle
         with vertices (x1, y1), (x2, y2), (x3, y3).
INPUTS:  double x    X-Coordinate of point to test.
         double y    Y-Coordinate of point to test.
         double x1   X-Coordinate of 1st vertex of triangle.
         double y1   Y-Coordinate of 1st vertex of triangle.
         double x2   X-Coordinate of 2nd vertex of triangle.
         double y2   Y-Coordinate of 2nd vertex of triangle.
         double x3   X-Coordinate of 3rd vertex of triangle.
         double y3   Y-Coordinate of 3rd vertex of triangle.
RETURNS: int 1 if inside, else 0.
INTERFACE:
int pointInsideTriangle( double x, double y,
                         double x3, double y3 )

-------------------------------------------------------------------------------

PURPOSE: areaOfTriangle - Area of triangle with vertices
         (x1, y1), (x2, y2), (x3, y3).
INPUTS:  double x1   X-Coordinate of 1st vertex of triangle.
         double y1   Y-Coordinate of 1st vertex of triangle.
         double x2   X-Coordinate of 2nd vertex of triangle.
         double y2   Y-Coordinate of 2nd vertex of triangle.
         double x3   X-Coordinate of 3rd vertex of triangle.
         double y3   Y-Coordinate of 3rd vertex of triangle.
RETURNS: double area.
INTERFACE:
double areaOfTriangle( double x1, double y1,
                       double x3, double y3 )

-------------------------------------------------------------------------------

PURPOSE: nearestPolyline - Is the specified point (x, y) on any of the set of
         polylines? If so return its index, else -1.
INPUTS:  const double x          X-coordinate of point to test.
         const double y          Y-coordinate of point to test.
         const int count         Number of polygons in polygons[].
         const PolygonShape polylines[ count ]  Array of polylines.
RETURNS: int index [0, count - 1] if the point is on the indexed polylines,
         else -1.
INTERFACE:
int nearestPolyline( const double x, const double y,
                     const int count, const PolygonShape polylines[] )
PRE05( ! isNan( x ) , ! isNan( y ), count > 0, polylines,
       isValidBounds( (const double (*)[2]) polylines[ 0 ].bounds ) )
POST0( IN_RANGE( result, -1, count - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: nearestPoint - Is the specified point (x, y) on any of the set of
         points? If so return its index, else -1.
INPUTS:  const double x          X-coordinate of point to test.
         const double y          Y-coordinate of point to test.
         const ShapeData* const shapeData  ShapeData with LONGITUDE, LATITUDE.
RETURNS: int index [0, count - 1] if the point is on the indexed polylines,
         else -1.
INTERFACE:
int nearestPoint( const double x, const double y,
                  const ShapeData* const shapeData )
PRE03( ! isNan( x ) , ! isNan( y ), isValidShapeData( shapeData ) )
POST0( IN_RANGE( result, -1, shapeData->rows - 1 ) )

-------------------------------------------------------------------------------

PURPOSE: pointLineDistance - Nearest distance from point (x, y) to infinite
         undirected line containing points (x1, y1)--(x2, y2).
INPUTS:  const double x   X-Coordinate of point to check.
         const double y   Y-Coordinate of point to check.
         const double x1  X-Coordinate of 1st endpoint of line.
         const double y1  Y-Coordinate of 1st endpoint of line.
         const double x2  X-Coordinate of 2nd endpoint of line.
         const double y2  Y-Coordinate of 2nd endpoint of line.
RETURNS: double distance  Nearest distance from point to line.
NOTES:   Swokowski, Earl, "Calculus With Analytic Geometry, Second Edition",
         Prindle, Weber & Schmidt, Boston, MA, 1979, page 696.
INTERFACE:
double pointLineDistance( const double x, const double y,
                          const double x2, const double y2 )
PRE06( ! isNan( x ) , ! isNan( y ),
       ! isNan( x1 ) , ! isNan( y1 ),
       ! isNan( x2 ) , ! isNan( y2 ) )
POST0( result >= 0.0 )

-------------------------------------------------------------------------------

PURPOSE: colinear - Do the given three points lie along a line (or are they
         coincident)?
INPUTS:  const double x1  X-Coordinate of 1st point to check.
         const double y1  Y-Coordinate of 1st point to check.
         const double x2  X-Coordinate of 2nd point to check.
         const double y2  Y-Coordinate of 2nd point to check.
         const double x3  X-Coordinate of 3rd point to check.
         const double y3  Y-Coordinate of 3rd point to check.
RETURNS: int 1 if colinear, else 0.
NOTES:   Swokowski, Earl, "Calculus With Analytic Geometry, Second Edition",
         Prindle, Weber & Schmidt, Boston, MA, 1979, page 670.
INTERFACE:
int colinear( const double x1, const double y1,
              const double x3, const double y3 )
PRE06( ! isNan( x1 ) , ! isNan( y1 ),
       ! isNan( x2 ) , ! isNan( y2 ),
       ! isNan( x3 ) , ! isNan( y3 ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: makePolygon - Make a GPC-polygon from an ESRI Shape polygon/polyline.
INPUTS:  const SHPObject* shape  Shape to copy.
         double minimumAdjacentVertexDistance  Adjacent vertices closer than
                                               this (in either x or y) will
                                               be merged.
OUTPUTS: gpc_polygon* polygon  GPC polygon.
         Bounds bounds         Bounds of thinned polygon vertices.
RETURNS: int 1 if successful (that is no allocation failures, but possibly no
         contours in polygon), else 0 and a failure message is printed.
NOTES:   Call gpc_free_polygon( polygon ) when finished with it.
         http://shapelib.maptools.org/shp_api.html
         http://www.cs.man.ac.uk/~toby/alan/software/gpc.html
INTERFACE:
int makePolygon( const SHPObject* shape, double minimumAdjacentVertexDistance,
                 gpc_polygon* polygon, Bounds bounds )
PRE013( shape,
        IN5( shape->nSHPType,
             SHPT_POLYGON, SHPT_POLYGONZ, SHPT_ARC, SHPT_ARCZ ),
        shape->nShapeId >= 0,
        shape->nParts > 0,
        shape->panPartStart,
        shape->panPartType,
        shape->panPartType[ 0 ] == SHPP_RING,
        shape->nVertices > 0,
        shape->padfX,
        shape->padfY,
        minimumAdjacentVertexDistance >= 0.0,
        polygon,
        bounds )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( AND2( result, polygon->num_contours > 0 ),
                      AND4( IN_RANGE( polygon->num_contours, 1,
                                      shape->nParts ),
                            polygon->hole,
                            polygon->contour,
                            isValidBounds( (const double (*)[2]) bounds ) ),
                      IS_ZERO7( polygon->num_contours,
                                polygon->hole,
                                polygon->contour,
                                bounds[ 0 ][ 0 ],
                                bounds[ 0 ][ 1 ],
                                bounds[ 1 ][ 0 ],
                                bounds[ 1 ][ 1 ] ) ) )

-------------------------------------------------------------------------------

PURPOSE: clipPolylines - Clip polylines to a given bounds.
INPUTS:  const gpc_polygon* const polylines  GPC polylines to clip.
         const Bounds clipBounds             Clip bounds.
OUTPUTS: gpc_polygon* clippedPolylines       Clipped GPC polylines.
         Bounds clippedPolylinesBounds       Bounds of clippedPolylines.
RETURNS: int 1 if successful (that is no allocation failures, but possibly no
         contours in bounds), else 0 and a failure message is printed.
NOTES:   Call gpc_free_polygon( clippedPolylines ) when finished with it.
         http://www.cs.man.ac.uk/~toby/alan/software/gpc.html
INTERFACE:
int clipPolylines( const gpc_polygon* const polylines,
                   Bounds clippedPolylinesBounds )
PRE04( polylines,
       isValidBounds( (const double (*)[2]) clipBounds ),
       polylines,
       isValidBounds( (const double (*)[2]) clippedPolylinesBounds ) )
POST02( IS_BOOL( result ),
        IMPLIES_ELSE( AND2( result, clippedPolylines->num_contours > 0 ),
                      AND4( minimumInt( clippedPolylines->num_contours,
                                        clippedPolylines->hole ) == 0,
                            maximumInt( clippedPolylines->num_contours,
                                        clippedPolylines->hole ) == 0,
                            clippedPolylines->contour,
                            isValidBounds( (const double (*)[2])
                                           clippedPolylinesBounds ) ),
                      IS_ZERO7( clippedPolylines->num_contours,
                                clippedPolylines->hole,
                                clippedPolylines->contour,
                                clippedPolylinesBounds[ 0 ][ 0 ],
                                clippedPolylinesBounds[ 0 ][ 1 ],
                                clippedPolylinesBounds[ 1 ][ 0 ],
                                clippedPolylinesBounds[ 1 ][ 1 ] ) ) )

-------------------------------------------------------------------------------

PURPOSE: maximumPolygonContours - Maximum number of contours in set of polygons
INPUTS:  const int count                  Number of polygons.
         const PolygonShape polygons[ count ]  Polygons to check.
RETURNS: int maximum number of contours in set of polygons.
INTERFACE:
int maximumPolygonContours( int count, const PolygonShape polygons[] )
PRE02( count > 0, polygons )
POST0( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: maximumPolygonVertices - Maximum number of vertices in set of polygons
INPUTS:  const int count                  Number of polygons.
         const PolygonShape polygons[ count ]  Polygons to check.
RETURNS: int maximum number of vertices in set of polygons.
INTERFACE:
int maximumPolygonVertices( int count, const PolygonShape polygons[] )
PRE02( count > 0, polygons )
POST0( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: polygonVertexCount - Number of vertices in polygon.
INPUTS:  const gpc_polygon* polygon  Polygon to check.
RETURNS: int number of vertices in polygon.
INTERFACE:
int polygonVertexCount( const gpc_polygon* polygon )
PRE0( polygon )
POST0( result > 0 )

-------------------------------------------------------------------------------

PURPOSE: copyPolygonVertices - Copy vertices from polygon to x and y arrays.
INPUTS:  const gpc_polygon* polygon  Polygon to copy from.
         int closeRing               Copy first vertex to last to close ring?
OUTPUTS: int starts[]                0-based indices of vertex lists.
         double x[]                  X-coordinates of vertices.
         double y[]                  Y-coordinates of vertices.
INTERFACE:
void copyPolygonVertices( const gpc_polygon* polygon, int closeRing,
                          int starts[], double x[], double y[] )
PRE07( polygon, IS_BOOL( closeRing ), polygon->num_contours > 0,
       IMPLIES( polygon->num_contours > 1, starts ),
       x, y, x != y )
POST04( x[ 0 ] == polygon->contour->vertex->x,
        y[ 0 ] == polygon->contour->vertex->y,
        IMPLIES( starts, starts[ 0 ] == 0 ),
        IMPLIES( AND2( starts, polygon->num_contours > 1 ),
                 AND2( starts[ 1 ] > starts[ 0 ],
                       starts[ polygon->num_contours - 1 ] >
                         starts[ polygon->num_contours - 2 ] ) ) )

-------------------------------------------------------------------------------

PURPOSE: ensureCorrectVertexOrder - Check and correct the vertex order to match
         hole designation to ESRI spec - i.e., hole vertices are in CCW order.
INPUTS:  gpc_polygon* polygon  Polygon to check/correct.
RETURNS: int 1 if corrected polygon now has strictly positive net area,
         else 0 which indicates that the area of the holes is >=
         the area of the non-holes.
NOTES:   http://mathworld.wolfram.com/PolygonArea.html
INTERFACE:
int ensureCorrectVertexOrder( gpc_polygon* polygon )
PRE0( polygon )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: reverseVertexList - Reverse the vertex order.
INPUTS:  gpc_vertex_list* vertex_list  Vertices to reverse.
OUTPUTS: gpc_vertex_list* vertex_list  Vertices in reversed order.
INTERFACE:
void reverseVertexList( gpc_vertex_list* vertex_list )
PRE03( vertex_list, vertex_list->vertex, vertex_list->num_vertices > 0 )

-------------------------------------------------------------------------------

PURPOSE: signedAreaOfPolygon - Signed area of a single contour of a polygon.
INPUTS:  const gpc_vertex_list* vertex_list  Vertex list to compute area of.
RETURNS: double signed area of polygon.
         Negative if vertices are in counter-clockwise order.
NOTES:   http://mathworld.wolfram.com/PolygonArea.html
INTERFACE:
double signedAreaOfPolygon( const gpc_vertex_list* vertex_list )
PRE03( vertex_list, vertex_list->num_vertices > 3, vertex_list->vertex )

-------------------------------------------------------------------------------

PURPOSE: writePolygonsToShapefile - Write clipped polygons to Shapefile
         (shx, shp).
INPUTS:  SHPHandle outputFile                  File to write to.
         int isPolyline                        Is shapefile polyline?
         int count                             Number of shapes.
         const PolygonShape polygons[ count ]  Shapes to write.
RETURNS: int 1 if successful, else 0 failure message is printed.
NOTES:   Uses external shapelib API and GPC API polygon data type.
INTERFACE:
int writePolygonsToShapefile( SHPHandle outputFile, int isPolyline,
                              int count, const PolygonShape polygons[] )
PRE03( outputFile, count > 0, polygons )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: copySubsetShapefile - Copy masked subset of polygons to Shapefile
         (shx, shp).
INPUTS:  SHPHandle inputFile       File to read from.
         SHPHandle outputFile      File to write to.
         const int count           Number of shapes.
         const char mask[ count ]  If mask[i] == 1 write shape i else skip.
RETURNS: int number of subset shapes written if successful,
         else 0 failure message is printed.
NOTES:   Uses external shapelib API.
INTERFACE:
int copySubsetShapefile( SHPHandle inputFile, SHPHandle outputFile,
                         const int count, const char* mask )
PRE04( inputFile, outputFile, count > 0, mask )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: writePolygonDBF - Write subset of DBF file for clipped polygons.
INPUTS:  const char* inputFileName        File name of input dbf.
         DBFHandle outputFile             DBF file to write to.
         int offset                       Record offset to starting writing.
         int count                        Number of shapes.
         const char* mask                 0 or mask (0,1) to filter shapes by.
         const PolygonShape polygons[ count ]  Shapes to write.
RETURNS: int 1 if successful, else 0 failure message is printed.
NOTES:   Uses static file-global table[] at the top of this file and
         external shapelib API.
INTERFACE:
int writePolygonDBF( const char* inputFileName, DBFHandle outputFile,
                     const PolygonShape polygons[] )
PRE06( inputFileName, *inputFileName, outputFile, offset >= 0, count > 0,
       polygons )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writePointSubsetDBF - Write subset of DBF file for points in bounds.
INPUTS:  const char* inputFileName  File name of input dbf.
         const Bounds          Bounds to subset rows of point multi-data DBF.
         const long long huc   Or huc to filter by (if > 0).
         DBFHandle outputFile  DBF file to write to.
OUTPUTS: char** mask           If not 0, allocate and initialize array of
                               shape indices in subset.
RETURNS: int > 0 if successful (if mask then return length),
         else 0 failure message is printed.
NOTES:   Uses static file-global table[] at the top of this file and
         external shapelib API.
INTERFACE:
int writePointSubsetDBF( const char* inputFileName, const Bounds bounds,
                         DBFHandle outputFile )
PRE05( inputFileName,
       *inputFileName,
       isValidBounds( (const double (*)[2]) bounds ),
       huc >= 0,
       outputFile )
POST0( result >= 0 )

-------------------------------------------------------------------------------

PURPOSE: writeShapeData - Write point multi-data ShapeData to DBF and SHP.
INPUTS:  const char* fileName        Pathed base file name to create.
         const ShapeData* shapeData  Data to write.
RETURNS: int 1 if successful, else 0 failure message is printed.
NOTES:   Uses external shapelib API.
INTERFACE:
int writeShapeData( const char* fileName, const ShapeData* shapeData )
PRE03( fileName, *fileName, isValidShapeData( shapeData ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: writeBoundsDBF - Write DBF file for bounds.
INPUTS:  const char* fileName                 File name of output dbf.
         const double areaInSquareKilometers  Area to write to DBF.
RETURNS: int 1 if successful, else 0 failure message is printed.
NOTES:   Uses external shapelib API.
INTERFACE:
int writeBoundsDBF(const char* fileName, const double areaInSquareKilometers)
PRE03( fileName, *fileName, IN_RANGE( areaInSquareKilometers, 0.001, 1e+10))
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: streamShapefiles - Stream shx, shp, dbf files to stdout preceeded
         by a one line ASCII header listing the (unpathed) base file name and
         sizes in bytes of the three files.
INPUTS:  const char* baseFileName  Base (no ext) name of shx/shp/dbf files.
         const char* name          Name to use in header.
         const int dbfOnly         Only process DBF file (not shx/p)?
         const int csv             Stream csv file too?
RETURNS: int 1 if successful, else 0.
INTERFACE:
int streamShapefiles( const char* baseFileName, const char* name,
                      const int dbfOnly, const int csv )
PRE06( baseFileName, *baseFileName, name, *name,
       IS_BOOL( dbfOnly ), IS_BOOL( csv ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: removeShapefiles - Remove set of temporary shx, shp, dbf files.
INPUTS:  const char* baseFileName  Base (no ext) file name of files to remove.
         int dbfOnly               Only process DBF file?
INTERFACE:
void removeShapefiles( const char* baseFileName, int dbfOnly )
PRE03( baseFileName, *baseFileName, IS_BOOL( dbfOnly ) )

-------------------------------------------------------------------------------

PURPOSE: deallocateShapeData - Deallocate storage of a ShapeData.
INPUTS:  ShapeData* shapeData  Shape data to deallocate.
OUTPUTS: ShapeData* shapeData  Deallocated shapeData.
INTERFACE:
void deallocateShapeData( ShapeData* shapeData )
POST0( shapeData == 0 )

-------------------------------------------------------------------------------

PURPOSE: copyShapeData - Allocate and copy a ShapeData.
INPUTS:  const ShapeData* shapeData  Shape data to copy.
RETURNS: ShapeData* Allocated and copied shapeData.
INTERFACE:
ShapeData* copyShapeData( const ShapeData* const shapeData )
PRE0( isValidShapeData( shapeData ) )
POST0( IMPLIES( result, equalShapeData( result, shapeData ) ) )

-------------------------------------------------------------------------------

PURPOSE: equalShapeData - Are ShapeData objects equal?.
INPUTS:  const ShapeData* const shapeData1  Shape data to compare.
         const ShapeData* const shapeData2  Shape data to compare.
RETURNS: int 1 if equal else 0.
INTERFACE:
int equalShapeData( const ShapeData* const shapeData1,
                    const ShapeData* const shapeData2 )
PRE02( isValidShapeData( shapeData1 ), isValidShapeData( shapeData2 ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: printShapeData - Print a ShapeData (for tracing/debugging).
INPUTS:  const ShapeData* shapeData  Shape data to print.
INTERFACE:
void printShapeData( const ShapeData* shapeData )

-------------------------------------------------------------------------------

PURPOSE: isValidShapeData - Validate a ShapeData.
INPUTS:  const ShapeData* shapeData  Shape data to validate.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidShapeData( const ShapeData* shapeData )

-------------------------------------------------------------------------------

PURPOSE: isValidColumnName - Is DBF column name valid?
INPUTS:  const char* const columnName  Name to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidColumnName( const char* columnName )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: isValidValue - Is Value valid - i.e., non-missing-valued?
INPUTS:  int type           Type portion to check.
         const char* units  Units of value, e.g., %.
         Value value        Value to check.
RETURNS: int 1 if valid, else 0.
INTERFACE:
int isValidValue( int type, const char* units, Value value )
PRE0( IN4( type, FTString, FTInteger, FTDouble ) )
POST0( IS_BOOL( result ) )

-------------------------------------------------------------------------------

PURPOSE: compareValues - Compare values for sorting order.
INPUTS:  Value value1  1st value to check.
         Value value2  2nd value to check.
RETURNS: int -1 if value1 < value2 else 1 if value1 > value2 else 0.
INTERFACE:
int compareValues( int type, Value value1, Value value2 )
PRE0( IN4( type, FTString, FTInteger, FTDouble ) )
POST0( IN4( result, -1, 0, 1 ) )

-------------------------------------------------------------------------------

PURPOSE: readDBF - Read a DBF file.
INPUTS:  const char* fileName  Name of input dbf file to read.
RETURNS: ShapeData* if successful, else 0 and failure message is printed.
INTERFACE:
ShapeData* readDBF( const char* fileName )
PRE02( fileName, *fileName )
POST0( IMPLIES( result, isValidShapeData( result ) ) )

-------------------------------------------------------------------------------

PURPOSE: subsetDBFByTime - Subset ShapeData by timestamp range.
INPUTS:  const char* fileName  Base file name of DBF file to read.
         int yyyymmdd1         1st timestamp to filter by.
         int yyyymmdd2         2nd timestamp to filter by.
RETURNS: char* array of mask flags 1 or 0 for each row.
NOTES:   This is for filtering out rows/shapes in HMS smoke polygon data that
         are outside the subset time range.
INTERFACE:
char* subsetDBFByTime( const char* fileName, int yyyymmdd1, int yyyymmdd2 )
PRE05( fileName,
       *fileName,
      isValidYearMonthDay( yyyymmdd1 ),
      isValidYearMonthDay( yyyymmdd2 ),
      yyyymmdd1 <= yyyymmdd2 )

-------------------------------------------------------------------------------

PURPOSE: writeShapeDataToText - Write ShapeData to a tab-delimited text file.
INPUTS:  const ShapeData* shapeData  ShapeData to write.
         const char* outputFileName  Name of output txt file to create.
RETURNS: int 1 if successful, else 0 and failure message is printed.
INTERFACE:
int writeShapeDataToText( const ShapeData* shapeData,
                          const char* outputFileName )
PRE03( isValidShapeData( shapeData ), outputFileName, *outputFileName )
POST0( IS_BOOL( result ) )



===============================================================================


 
-------------------------------------------------------------------------------

PURPOSE: KMLFile.h - Declare routines for KML file creation.

NOTES:   


FUNCTIONS:

/* Call once when KML file is created: */

extern void writeStartKML( FILE* file,
                           const char* name, const char* description,
                           const Bounds bounds );

extern void writeEndKML( FILE* file ); /* Call just before closing KML file. */

/* Write a set of map image files (modisTrueColoryyyymmdd.png): */

extern void writeMapImagesToKML( FILE* file,
                                 const char* const inputDirectory,
                                 const char* const outputDirectory,
                                 const char* const startsWith,
                                 const char* const endsWith,
                                 const Bounds bounds );

/* Writes a set of map polylines: */

extern void writeMapPolylinesToKML( FILE* file,
                                    int polylineCount,
                                    const int counts[],
                                    const float vertices[],
                                    const char* name,
                                    Color color );
/* Write a polygons dataset: */

extern void writePolygonsToKML( FILE* file,
                                const LongName source,
                                const Name name,
                                const Units units,
                                const int yyyymmddhhStart,
                                const int yyyymmddhhEnd,
                                const int count,
                                const PolygonShape polygons[],
                                const ShapeData* shapeData,
                                const int column,
                                const double sameValue,
                                const double dataRange[ 2 ],
                                DataColor dataColor);

/* For non-polygons datasets, call once per dataset: */

extern void writeStartFolderKML( FILE* file,
                                 const LongName source,
                                 const Name name,
                                 const Units units,
                                 const char* const dataType,
                                 const char* const description );

extern void writeEndFolderKML( FILE* file ); /* Call at end of dataset. */

/* Call once per cell of dataset: cell will be point, vector, quad or hex. */

extern void writeCellDataToKML( FILE* file,
                                const LongName source,
                                const Name name,
                                const Units units,
                                const long long timestamp,
                                const int components,
                                const double datum,
                                const double datum2,
                                const double datum3,
                                const int vertices,
                                const double coordinates[],
                                const Color color );


#ifdef __cplusplus
}
#endif
    
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------

PURPOSE: writeStartKML - Write start of KML file.
INPUTS:  FILE* file                     File to write to.
         const char* name               Name of document.
         const char* description        Description of document.
         const Bounds bounds            0 or Bounds of KML data.
INTERFACE:
void writeStartKML( FILE* file,
                    const Bounds bounds )
PRE06( file, name, *name, description, *description,
       IMPLIES( bounds, isValidBounds( bounds ) ) )

-------------------------------------------------------------------------------

PURPOSE: writeEndKML - Write end of KML file.
INPUTS:  FILE* file  File to write to.
INTERFACE:
void writeEndKML( FILE* file )
PRE0( file )

-------------------------------------------------------------------------------

PURPOSE: writeMapImagesToKML - Write satellite map images files to KML.
INPUTS:  FILE* file                         File to write to.
         const char* const inputDirectory   Directory path to check for
                                            map_image_yyyymmdd.png files.
         const char* const startsWith       File names start with. "map_image_"
         const char* const endsWith         File names end with. E.g., ".png".
         const char* const outputDirectory  Directory path for outputing files.
         const Bounds bounds                Lon-lat bounds of images.
INTERFACE:
void writeMapImagesToKML( FILE* file,
                          const Bounds bounds )
PRE011( file, inputDirectory, *inputDirectory,
        startsWith, *startsWith, endsWith, *endsWith,
        outputDirectory, *outputDirectory,
        strcmp( inputDirectory, outputDirectory ),
        isValidBounds( bounds ) )

-------------------------------------------------------------------------------

PURPOSE: writeMapPolylinesToKML - Write map polylines to KML file.
INPUTS:  FILE* file                         KML file to write to.
         int polylineCount                  Number of polylines.
         const int counts[ polylineCount ]  Number of vertices per polyline.
         const float vertices[]             Lon-lat vertices.
         const char* name                   Name of polyline set placemark.
         Color color                        Color of lines.
INTERFACE:
void writeMapPolylinesToKML( FILE* file,
                             Color color )
PRE010( file,
        polylineCount > 0,
        counts,
        counts[ 0 ] > 1,
        counts[ polylineCount - 1 ] > 1,
        vertices,
        isValidLongitudeLatitude( vertices[ 0 ], vertices[ 1 ] ),
        name,
        *name,
        isValidColor( color ) )

-------------------------------------------------------------------------------

PURPOSE: writePolygonsToKML - Write a polygon dataset to KML.
INPUTS:  FILE* file                       File to write to.
         const LongName source            E.g., "HMS".
         const Name name                  E.g., "smoke".
         const Units units                E.g., "ug/m3".
         const int yyyymmddhhStart        Starting timestamp or 0.
         const int yyyymmddhhEnd          Ending timestamp or 0.
         const int count                  Number of polygons.
         const PolygonShape polygons[ count ]  Polygons to write.
         const ShapeData* shapeData       ShapeData for polygons.
         const int column                 Data column of value.
         const double sameValue           If not -9999.0 then use for all
                                          polygons instead of shapeData->values
         const double dataRange[ 2 ]      Minimum and maximum data values.
         const DataColor dataColor        DataColor function to use.
INTERFACE:
void writePolygonsToKML( FILE* file,
                         DataColor dataColor )
PRE017( file,
        OR2( IS_ZERO2( yyyymmddhhStart, yyyymmddhhEnd ),
             AND3( isValidYYYYMMDDHH( yyyymmddhhStart ),
                   isValidYYYYMMDDHH( yyyymmddhhEnd ),
                   yyyymmddhhStart <= yyyymmddhhEnd ) ),
        count > 0, polygons, shapeData, source, *source, name, *name,
        IN_RANGE( column, 0, shapeData->columns - 1 ),
        sameValue >= -9999.0,
        units, *units,
        ! isNan( dataRange[ 0 ] ), ! isNan( dataRange[ 1 ] ),
        dataRange[ MINIMUM ] <= dataRange[ MAXIMUM ],
        dataColor )

-------------------------------------------------------------------------------

PURPOSE: writeStartFolderKML - Write initial descriptive folder tags to KML.
INPUTS:  FILE* file                     File to write to.
         const LongName source          E.g., "CMAQ".
         const Name name                E.g., "WIND", "O3".
         const Units units              E.g., "m/s", "ppm".
         const char* const dataType     E.g., "Gridded", "Gridded_Vector".
         const char* const description  E.g., "Modeled 3D wind.", "Ozone.".
INTERFACE:
void writeStartFolderKML( FILE* file,
                          const char* const description )
PRE07( file, source, *source, name, *name, units, *units )

-------------------------------------------------------------------------------

PURPOSE: writeEndFolderKML - Write indented ending folder tag to KML.
INPUTS:  FILE* file  File to write to.
INTERFACE:
void writeEndFolderKML( FILE* file )
PRE0( file )

-------------------------------------------------------------------------------

PURPOSE: writeCellDataToKML - Write one colored point, quadrilateral or vector
         to KML.
INPUTS:  FILE* file                     File to write to.
         const LongName source          E.g., "CMAQ".
         const Name name                E.g., "WIND", "O3".
         const Units units              E.g., "m/s", "ppm".
         const long long timestamp      One of: yyyy, yyyymm, yyyymmdd,
                                        yyyymmddhh, yyyymmddhhmm.
         const int components           1 = scalar 2 or 3 is vector.
         const double datum             Value for cell.
         const double datum2            -9999.0 or 2nd vector component value.
         const double datum3            -9999.0 or 3rd vector component value.
         const int vertices             1 = point, 4 = quadrilateral,
                                        8 = hexahedron.
         const double coordinates[ vertices * 3 ] Counter-clockwise
                                                  (right-hand-rule) vertex
                                                  order coordinates for
                                                  quad cell faces.
         const Color color                        Color of cell.
INTERFACE:
void writeCellDataToKML( FILE* file,
                         const Color color )
PRE017( file,
        source, *source, name, *name, units, *units,
        timestamp < 3000 ? isYear( timestamp )
          : timestamp < 300012 ? isValidYearMonthDay( timestamp * 100 + 1 )
          : timestamp < 30001231 ? isValidYearMonthDay( timestamp )
          : timestamp < 3000123123LL ? isValidYYYYMMDDHH( timestamp )
          : AND2( isValidYYYYMMDDHH( timestamp / 100 ),
                  isValidTime( timestamp % 10000 * 100 ) ),
        IN_RANGE( components, 0, 3 ),
        datum > -9999.0, datum2 >= -9999.0, datum3 >= -9999.0,
        IN4( vertices, 1, 4, 8 ),
        coordinates,
        isValidLongitudeLatitude( coordinates[ 0 ], coordinates[ 1 ] ),
        isValidLongitudeLatitude( coordinates[ ( vertices - 1 ) * 3 ],
                                  coordinates[ ( vertices - 1 ) * 3 + 1 ] ),
        isValidColor( color ) )

