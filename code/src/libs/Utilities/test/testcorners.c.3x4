/*
gcc -Wall -g -o testcorners testcorners.c ; testcorners
*/

#include <stdio.h>  /* For printf(). */
#include <string.h> /* For memset(). */

#define PRE08(unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8)
#define POST02(unused1,unused2)
#define CLAMPED_TO_RANGE( value, low, high ) \
((value) < (low) ? (low) : (value) > (high) ? (high) : (value))

#define PRE07(unused1,unused2,unused3,unused4,unused5,unused6,unused7)
#define POST0(unused)
#define OR2(a,b) ((a)||(b))
typedef long long Integer;
typedef double Real;

void computeGridCellVertices( const int rows, const int columns,
                              const float longitudes[],
                              const float latitudes[], float vertices[] );

static void computeCorners( Integer rows, Integer columns,
                            const Real longitudes[], const Real latitudes[],
                            Real corners[] );

int main( void ) {
  enum {
    ROWS = 3, COLUMNS = 4, CELLS = ROWS * COLUMNS,
    VROWS = ROWS + 1, VCOLUMNS = COLUMNS + 1
  };
  const float longitudes[ ROWS * COLUMNS ] = {
    -93.0, -92.0, -91.0, -90.0,
    -93.1, -92.1, -91.1 -90.1,
    -93.2, -92.2, -91.2 -90.2
  };
  const float latitudes[ ROWS * COLUMNS ] = {
    30.0, 30.1, 30.2, 30.3,
    31.0, 31.1, 31.2, 31.3,
    32.0, 32.1, 32.2, 32.3
  };
  float vertices[ VROWS * VCOLUMNS * 2 ];
  Real longitudes2[ ROWS * COLUMNS ];
  Real latitudes2[ ROWS * COLUMNS ];
  Real corners[ ROWS * COLUMNS * 8 ];
  Real* const longitudes_sw = corners;
  Real* const longitudes_se = longitudes_sw + CELLS;
  Real* const longitudes_nw = longitudes_se + CELLS;
  Real* const longitudes_ne = longitudes_nw + CELLS;
  Real* const latitudes_sw  = longitudes_ne + CELLS;
  Real* const latitudes_se  = latitudes_sw + CELLS;
  Real* const latitudes_nw  = latitudes_se + CELLS;
  Real* const latitudes_ne  = latitudes_nw + CELLS;
  int index = 0;
  int row = 0;

  memset( vertices, 0, sizeof vertices );
  memset( longitudes2, 0, sizeof longitudes2 );
  memset( latitudes2, 0, sizeof latitudes2 );
  memset( corners, 0, sizeof corners );

  for ( index = 0; index < CELLS; ++index ) {
    longitudes2[ index ] = longitudes[ index ];
    latitudes2[  index ] = latitudes[  index ];
  }

  computeGridCellVertices( ROWS, COLUMNS, longitudes, latitudes, vertices );

  printf( "\ninput:\n" );

  for ( row = 0, index = 0; row < ROWS; ++row ) {
    int column = 0;

    for ( column = 0; column < COLUMNS; ++column, ++index ) {
      const float longitude = longitudes[ index ];
      const float latitude  = latitudes[ index ];
      printf( "[%g %g] ", longitude, latitude );
    }

    printf( "\n" );
  }

  printf( "\noutput vertices:\n" );

  for ( row = 0, index = 0; row < VROWS; ++row ) {
    int column = 0;

    for ( column = 0; column < VCOLUMNS; ++column, index += 2 ) {
      const float longitude = vertices[ index ];
      const float latitude  = vertices[ index + 1 ];
      printf( "[%g %g] ", longitude, latitude );
    }

    printf( "\n" );
  }

  printf( "\ncomputeCorners():\n" );

  computeCorners( ROWS, COLUMNS, longitudes2, latitudes2, corners );

  printf( "\noutput corners:\n" );

  for ( row = 0, index = 0; row < ROWS; ++row ) {
    int column = 0;

    for ( column = 0; column < COLUMNS; ++column, ++index ) {
      const float longitude_sw = longitudes_sw[ index ];
      const float longitude_se = longitudes_se[ index ];
      const float longitude_nw = longitudes_nw[ index ];
      const float longitude_ne = longitudes_ne[ index ];
      const float latitude_sw = latitudes_sw[ index ];
      const float latitude_se = latitudes_se[ index ];
      const float latitude_nw = latitudes_nw[ index ];
      const float latitude_ne = latitudes_ne[ index ];
      printf( "sw[%lg %lg] ", longitude_sw, latitude_sw );
      printf( "se[%lg %lg] ", longitude_se, latitude_se );
      printf( "nw[%lg %lg] ", longitude_nw, latitude_nw );
      printf( "ne[%lg %lg] ", longitude_ne, latitude_ne );
      printf( "\n" );
    }

    printf( "\n" );
  }

  return 0;
}



/******************************************************************************
PURPOSE: computeGridCellVertices - Compute lon-lat coordinates of rectangular
         grid cell corners.
INPUTS:  const int rows                            Number of grid row cells.
         const int columns                         Number of grid column cells.
         const float longitudes[ rows * columns ]  Longitude of cell center.
         const float latitudes[  rows * columns ]  Latitude of cell center.
OUTPUTS: float vertices[ ( rows + 1 ) * ( columns + 1 ) * 2 ]
         Corners in grid cell order with interleaved lon-lat coordinates.
NOTES:   Uses linear interpolation and extrapolation to the edges.
******************************************************************************/

void computeGridCellVertices( const int rows, const int columns,
                              const float longitudes[],
                              const float latitudes[], float vertices[] ) {

  PRE08( rows > 1, columns > 1, rows * columns > = 4,
         longitudes, latitudes, vertices,
         is_valid_longitude_latitude( longitudes[ 0 ], latitudes[ 0 ] ),
         is_valid_longitude_latitude( longitudes[ rows * columns - 1 ],
                                      latitudes[ rows * columns - 1 ] ) );

  const int rows_1    = rows - 1;
  const int columns_1 = columns - 1;
  const int columnsPlus1 = columns + 1;
  const int columnsPlus1Times2 = columnsPlus1 + columnsPlus1;
  const int count = ( rows + 1 ) * ( columns + 1 ) * 2;
  int row    = 0;
  int column = 0;
  int vIndex = 0;

  /*
   * First compute linearly interpolated corners of all interior cells:
   * Note: rows increase north to south and columns increase west to east.
   */

  printf( "\ninterpolated interior vertices:\n" );

#pragma omp parallel for private( column )

  for ( row = 0; row < rows_1; ++row ) {
    const int nextRow        = row + 1;
    const int rowOffset      = row     * columns;
    const int nextRowOffset  = nextRow * columns;
    const int verticesOffset = nextRow * columnsPlus1Times2 + 2;

    /* Interior row, interior columns: */

    for ( column = 0; column < columns_1; ++column ) {
      const int nextColumn             = column + 1;
      const int verticesIndex          = verticesOffset + column + column;
      const int index                  = rowOffset + column;
      const int nextColumnIndex        = index + 1;
      const int nextRowIndex           = nextRowOffset + column;
      const int nextRowNextColumnIndex = nextRowOffset + nextColumn;

      const float longitude                  = longitudes[ index ];
      const float nextColumnLongitude        = longitudes[ nextColumnIndex ];
      const float nextRowLongitude           = longitudes[ nextRowIndex ];
      const float nextRowNextColumnLongitude =
        longitudes[ nextRowNextColumnIndex ];

      const float latitude                  = latitudes[ index ];
      const float nextColumnLatitude        = latitudes[ nextColumnIndex ];
      const float nextRowLatitude           = latitudes[ nextRowIndex ];
      const float nextRowNextColumnLatitude =
        latitudes[ nextRowNextColumnIndex ];
      const float interpolatedLongitude = 0.25 *
        ( longitude + nextColumnLongitude +
          nextRowLongitude + nextRowNextColumnLongitude );
      const float interpolatedLatitude = 0.25 *
        ( latitude + nextColumnLatitude +
          nextRowLatitude + nextRowNextColumnLatitude );

      vertices[ verticesIndex     ] = interpolatedLongitude;
      vertices[ verticesIndex + 1 ] = interpolatedLatitude;

      printf( "[%d] = %g, ", verticesIndex, interpolatedLongitude );
      printf( "[%d] = %g\n", verticesIndex + 1, interpolatedLatitude );

    } /* End loop on interior columns. */

  } /* End parallel loop on interior rows. */

  /* Serial region (not worth parallelizing): */

  /* Last row, interior columns (extrapolated top edge, except corners): */

  printf( "\nextrapolated top edge, except corners:\n" );

  for ( column = 1, vIndex = rows_1 * columnsPlus1Times2 + 2;
        column < columns; ++column, vIndex += 2 ) {
    const int extrapolatedIndex       = vIndex + columnsPlus1Times2;
    const int previousRowIndex        = vIndex - columnsPlus1Times2;
    const float longitude             = vertices[ vIndex ];
    const float latitude              = vertices[ vIndex + 1 ];
    const float previousRowLongitude  = vertices[ previousRowIndex ];
    const float previousRowLatitude   = vertices[ previousRowIndex + 1 ];
    const float longitudeDifference   = longitude - previousRowLongitude;
    const float latitudeDifference    = latitude  - previousRowLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  =  latitude + latitudeDifference;
    vertices[ extrapolatedIndex     ] = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ] = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* First row, interior columns (extrapolated bottom edge, except corners): */

  printf( "\nextrapolated bottom edge, except corners:\n" );

  for ( column = 1, vIndex = columnsPlus1Times2 + 2;
        column < columns; ++column, vIndex += 2 ) {
    const int extrapolatedIndex       = vIndex - columnsPlus1Times2;
    const int nextRowIndex            = vIndex + columnsPlus1Times2;
    const float longitude             = vertices[ vIndex ];
    const float latitude              = vertices[ vIndex + 1 ];
    const float nextRowLongitude      = vertices[ nextRowIndex ];
    const float nextRowLatitude       = vertices[ nextRowIndex + 1 ];
    const float longitudeDifference   = longitude - nextRowLongitude;
    const float latitudeDifference    = latitude  - nextRowLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex     ] = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ] = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* First column, interior rows (extrapolated left edge, except corners): */

  printf( "\nextrapolated left edge, except corners:\n" );

  for ( row = 1, vIndex = columnsPlus1Times2 + 2;
        row < rows; ++row, vIndex += columnsPlus1Times2 ) {
    const int extrapolatedIndex       = vIndex - 2;
    const int nextColumnIndex         = vIndex + 2;
    const float longitude             = vertices[ vIndex ];
    const float latitude              = vertices[ vIndex + 1 ];
    const float nextColumnLongitude   = vertices[ nextColumnIndex ];
    const float nextColumnLatitude    = vertices[ nextColumnIndex + 1 ];
    const float longitudeDifference   = longitude - nextColumnLongitude;
    const float latitudeDifference    = latitude  - nextColumnLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex     ] = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ] = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* Last column, interior rows (extrapolated right edge, except corners): */

  printf( "\nextrapolated right edge, except corners:\n" );

  for ( row = 1, vIndex = columnsPlus1Times2 + columnsPlus1Times2 - 4;
        row < rows; ++row, vIndex += columnsPlus1Times2 ) {
    const int extrapolatedIndex         = vIndex + 2;
    const int previousColumnIndex       = vIndex - 2;
    const float longitude               = vertices[ vIndex ];
    const float latitude                = vertices[ vIndex + 1 ];
    const float previousColumnLongitude = vertices[ previousColumnIndex ];
    const float previousColumnLatitude  = vertices[ previousColumnIndex + 1 ];
    const float longitudeDifference     = longitude - previousColumnLongitude;
    const float latitudeDifference      = latitude  - previousColumnLatitude;
    const float extrapolatedLongitude   = longitude + longitudeDifference;
    const float extrapolatedLatitude    = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex     ]   = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ]   = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* First row, first column cell (extrapolated bottom-left corner): */

  printf( "\nextrapolated bottom-left corner:\n" );
  
  vIndex = columnsPlus1Times2 + 2;

  {
    const float longitude             = longitudes[ 0 ];
    const float latitude              = latitudes[ 0 ];
    const float diagonalLongitude     = vertices[ vIndex ];
    const float diagonalLatitude      = vertices[ vIndex + 1 ];
    const float longitudeDifference   = longitude - diagonalLongitude;
    const float latitudeDifference    = latitude  - diagonalLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ 0 ]                     = extrapolatedLongitude;
    vertices[ 1 ]                     = extrapolatedLatitude;
    printf( "[0] = %g, ", extrapolatedLongitude );
    printf( "[1] = %g\n", extrapolatedLatitude );
  }

  /* Last row, first column cell (extrapolated top-left corner): */

  printf( "\nextrapolated top-left corner:\n" );

  vIndex = rows_1 * columnsPlus1Times2 + 2;

  {
    const int extrapolatedIndex       = rows * columnsPlus1Times2;
    const int index                   = rows_1 * columns;
    const float longitude             = longitudes[ index ];
    const float latitude              = latitudes[ index ];
    const float diagonalLongitude     = vertices[ vIndex ];
    const float diagonalLatitude      = vertices[ vIndex + 1 ];
    const float longitudeDifference   = longitude - diagonalLongitude;
    const float latitudeDifference    = latitude  - diagonalLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex     ] = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ] = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* First row, last column cell (extrapolated bottom-right corner): */

  printf( "\nextrapolated bottom-right corner:\n" );

  vIndex = columnsPlus1Times2 + columnsPlus1Times2 - 4;

  {
    const int extrapolatedIndex       = columnsPlus1Times2 - 2;
    const int index                   = columns - 1;
    const float longitude             = longitudes[ index ];
    const float latitude              = latitudes[ index ];
    const float diagonalLongitude     = vertices[ vIndex ];
    const float diagonalLatitude      = vertices[ vIndex + 1 ];
    const float longitudeDifference   = longitude - diagonalLongitude;
    const float latitudeDifference    = latitude  - diagonalLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex ]     = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1 ] = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* Last row, last column cell (extrapolated top-right corner): */

  printf( "\nextrapolated top-right corner:\n" );

  vIndex = rows * columnsPlus1Times2 - 4;

  {
    const int extrapolatedIndex       = vIndex + columnsPlus1Times2 + 2;
    const int index                   = rows * columns - 1;
    const float longitude             = longitudes[ index ];
    const float latitude              = latitudes[ index ];
    const float diagonalLongitude     = vertices[ vIndex ];
    const float diagonalLatitude      = vertices[ vIndex + 1 ];
    const float longitudeDifference   = longitude - diagonalLongitude;
    const float latitudeDifference    = latitude  - diagonalLatitude;
    const float extrapolatedLongitude = longitude + longitudeDifference;
    const float extrapolatedLatitude  = latitude  + latitudeDifference;
    vertices[ extrapolatedIndex ]     = extrapolatedLongitude;
    vertices[ extrapolatedIndex + 1]  = extrapolatedLatitude;
    printf( "[%d] = %g, ", extrapolatedIndex, extrapolatedLongitude );
    printf( "[%d] = %g\n", extrapolatedIndex + 1, extrapolatedLatitude );
  }

  /* Clamp any out-of-range values: */

  printf( "\nclamping:\n" );

#pragma omp parallel for

  for ( vIndex = 0; vIndex < count; vIndex += 2 ) {
    const int vIndex1 = vIndex + 1;
    vertices[ vIndex  ] = CLAMPED_TO_RANGE( vertices[ vIndex ], -180.0, 180.0);
    vertices[ vIndex1 ] = CLAMPED_TO_RANGE( vertices[ vIndex1 ], -90.0, 90.0 );
    printf( "[%d] = %g, ", vIndex, vertices[ vIndex  ] );
    printf( "[%d] = %g\n", vIndex1, vertices[ vIndex1 ] );
  }

  printf( "\n" );

  POST02( is_valid_longitude_latitude( vertices[ 0 ], vertices[ 1 ] ),
          is_valid_longitude_latitude( vertices[ (rows+1) * (columns+1) - 2 ],
                                       vertices[ (rows+1) * (columns+1) - 1]));
}



/******************************************************************************
PURPOSE: computeCorners - Compute and store the corner variables
         (Longitude_SW, ... , Latitude_NE) for each center/pixel.
INPUTS:  Integer rows          Number of rows in swath.
         Integer columns       Number of columns in swath.
         const Real longitudes[ rows * columns ]  Longitudes of swath points.
         const Real latitudes[  rows * columns ]  Latitudes  of swath points.
OUTPUTS: Real corners[ 8 * rows * columns ]       Longitude_SW..Latitude_NE.
NOTES:   Uses linear interpolation and extrapolation to the edges.
******************************************************************************/

static void computeCorners( Integer rows, Integer columns,
                            const Real longitudes[], const Real latitudes[],
                            Real corners[] ) {

  PRE07( rows > 0, columns > 0, rows * columns > 0, longitudes, latitudes,
         corners,
         validLongitudesAndLatitudes( rows * columns, longitudes, latitudes ));

  const Integer rows1    = rows - 1;
  const Integer columns1 = columns - 1;
  const Integer cells    = rows * columns;
  Real* const longitudes_sw = corners;
  Real* const longitudes_se = longitudes_sw + cells;
  Real* const longitudes_nw = longitudes_se + cells;
  Real* const longitudes_ne = longitudes_nw + cells;
  Real* const latitudes_sw  = longitudes_ne + cells;
  Real* const latitudes_se  = latitudes_sw + cells;
  Real* const latitudes_nw  = latitudes_se + cells;
  Real* const latitudes_ne  = latitudes_nw + cells;
  Integer cell = 0;

  if ( OR2( rows < 2, columns < 2 ) ) {

    /* Copy all center values to the corners in such degenerate cases: */

#pragma omp parallel for

    for ( cell = 0; cell < cells; ++cell ) {
      longitudes_sw[ cell ] =
      longitudes_se[ cell ] =
      longitudes_nw[ cell ] =
      longitudes_ne[ cell ] = longitudes[ cell ];
      latitudes_sw[ cell ] =
      latitudes_se[ cell ] =
      latitudes_nw[ cell ] =
      latitudes_ne[ cell ] = latitudes[ cell ];
    }

  } else { /* Linearly interpolate and extrapolate the corner points: */
    Integer row    = 0;
    Integer column = 0;

    /*
     * First compute linearly interpolated corners of all interior cells:
     * Note: rows increase north to south and columns increase west to east.
     */

    printf( "\n\ninterpolated interior corners:\n" );

#pragma omp parallel for private( column )

    for ( row = 1; row < rows1; ++row ) {
      const Integer previousRow       = row - 1;
      const Integer nextRow           = row + 1;
      const Integer rowOffset         = row         * columns;
      const Integer previousRowOffset = previousRow * columns;
      const Integer nextRowOffset     = nextRow     * columns;

      /* Interior row, interior columns: */

      for ( column = 1; column < columns1; ++column ) {
        const Integer previousColumn       = column - 1;
        const Integer nextColumn           = column + 1;
        const Integer index                = rowOffset + column;
        const Integer previousColumnIndex  = index - 1;
        const Integer nextColumnIndex      = index + 1;
        const Integer previousRowIndex     = previousRowOffset + column;
        const Integer nextRowIndex         = nextRowOffset     + column;
        const Integer previousRowPreviousColumnIndex =
          previousRowOffset + previousColumn;
        const Integer previousRowNextColumnIndex =
          previousRowOffset + nextColumn;
        const Integer nextRowPreviousColumnIndex =
          nextRowOffset + previousColumn;
        const Integer nextRowNextColumnIndex     = nextRowOffset + nextColumn;

        const Real longitude                 = longitudes[ index ];
        const Real previousLongitude         = longitudes[previousColumnIndex];
        const Real nextLongitude             = longitudes[ nextColumnIndex ];
        const Real thisPlusPreviousLongitude = longitude + previousLongitude;
        const Real thisPlusNextLongitude     = longitude + nextLongitude;
        const Real previousRowLongitude      = longitudes[ previousRowIndex ];
        const Real nextRowLongitude          = longitudes[ nextRowIndex ];

        const Real latitude                 = latitudes[ index ];
        const Real previousLatitude         = latitudes[ previousColumnIndex ];
        const Real nextLatitude             = latitudes[ nextColumnIndex ];
        const Real thisPlusPreviousLatitude = latitude + previousLatitude;
        const Real thisPlusNextLatitude     = latitude + nextLatitude;
        const Real previousRowLatitude      = latitudes[ previousRowIndex ];
        const Real nextRowLatitude          = latitudes[ nextRowIndex ];

        longitudes_sw[ index ] = 0.25 *
          ( thisPlusPreviousLongitude +
            longitudes[ nextRowPreviousColumnIndex ] + nextRowLongitude );

        longitudes_se[ index ] = 0.25 *
          ( thisPlusNextLongitude +
            nextRowLongitude + longitudes[ nextRowNextColumnIndex ] );

        longitudes_nw[ index ] = 0.25 *
          ( thisPlusPreviousLongitude + previousRowLongitude +
            longitudes[ previousRowPreviousColumnIndex ] );

        longitudes_ne[ index ] = 0.25 *
          ( thisPlusNextLongitude + previousRowLongitude +
            longitudes[ previousRowNextColumnIndex ] );

        latitudes_sw[ index ] = 0.25 *
          ( thisPlusPreviousLatitude +
            latitudes[ nextRowPreviousColumnIndex ] + nextRowLatitude );

        latitudes_se[ index ] = 0.25 *
          ( thisPlusNextLatitude +
            nextRowLatitude + latitudes[ nextRowNextColumnIndex ] );

        latitudes_nw[ index ] = 0.25 *
          ( thisPlusPreviousLatitude + previousRowLatitude +
            latitudes[ previousRowPreviousColumnIndex ] );

        latitudes_ne[ index ] = 0.25 *
          ( thisPlusNextLatitude + previousRowLatitude +
            latitudes[ previousRowNextColumnIndex ] );

        printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
        printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
        printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
        printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
        printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
        printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
        printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
        printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
        printf( "\n" );

      } /* End loop on interior columns. */

    } /* End parallel loop on interior rows. */

    /* Serial region (not worth parallelizing): */

    /* Interior rows, first column (extrapolated left edge): */

    printf( "\nextrapolated outer edge, except corners:\n" );

    for ( row = 1; row < rows1; ++row ) {
      const Integer index              = row * columns;
      const Integer nextColumnIndex    = index + 1;
      const Real nextColumnNWLongitude = longitudes_nw[ nextColumnIndex ];
      const Real nextColumnSWLongitude = longitudes_sw[ nextColumnIndex ];
      const Real nextColumnNWLatitude  = latitudes_nw[  nextColumnIndex ];
      const Real nextColumnSWLatitude  = latitudes_sw[  nextColumnIndex ];

      longitudes_ne[ index ] = nextColumnNWLongitude;
      longitudes_se[ index ] = nextColumnSWLongitude;

      longitudes_nw[ index ] =
        nextColumnNWLongitude -
        ( longitudes_ne[ nextColumnIndex ] - nextColumnNWLongitude );

      longitudes_sw[ index ] =
        nextColumnSWLongitude -
        ( longitudes_se[ nextColumnIndex ] - nextColumnSWLongitude );

      latitudes_ne[ index ] = nextColumnNWLatitude;
      latitudes_se[ index ] = nextColumnSWLatitude;

      latitudes_nw[ index ] =
        nextColumnNWLatitude -
        ( latitudes_ne[ nextColumnIndex ] - nextColumnNWLatitude );

      latitudes_sw[ index ] =
        nextColumnSWLatitude -
        ( latitudes_se[ nextColumnIndex ] - nextColumnSWLatitude );

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* Interior rows, last column (extrapolated right edge): */

    printf( "\nextrapolated right edge, except corners:\n" );

    for ( row = 1; row < rows1; ++row ) {
      const Integer index                  = row * columns + columns1;
      const Integer previousColumnIndex    = index - 1;
      const Real previousColumnNELongitude =longitudes_ne[previousColumnIndex];
      const Real previousColumnSELongitude =longitudes_se[previousColumnIndex];
      const Real previousColumnNELatitude  = latitudes_ne[previousColumnIndex];
      const Real previousColumnSELatitude  = latitudes_se[previousColumnIndex];

      longitudes_nw[ index ] = previousColumnNELongitude;
      longitudes_sw[ index ] = previousColumnSELongitude;

      longitudes_ne[ index ] =
        previousColumnNELongitude +
        previousColumnNELongitude - longitudes_nw[ previousColumnIndex ];

      longitudes_se[ index ] =
        previousColumnSELongitude +
        previousColumnSELongitude - longitudes_sw[ previousColumnIndex ];

      latitudes_nw[ index ] = previousColumnNELatitude;
      latitudes_sw[ index ] = previousColumnSELatitude;

      latitudes_ne[ index ] =
        previousColumnNELatitude +
        previousColumnNELatitude - latitudes_nw[ previousColumnIndex ];

      latitudes_se[ index ] =
        previousColumnSELatitude +
        previousColumnSELatitude - latitudes_sw[ previousColumnIndex ];

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* First row, interior columns (extrapolated bottom edge): */

    printf( "\nextrapolated bottom edge, except corners:\n" );

    for ( column = 1; column < columns1; ++column ) {
      const Integer nextRowIndex    = columns + column;
      const Real nextRowNELongitude = longitudes_ne[ nextRowIndex ];
      const Real nextRowNWLongitude = longitudes_nw[ nextRowIndex ];
      const Real nextRowNELatitude  = latitudes_ne[  nextRowIndex ];
      const Real nextRowNWLatitude  = latitudes_nw[  nextRowIndex ];

      longitudes_sw[ column ] = longitudes_nw[ nextRowIndex ];
      longitudes_se[ column ] = longitudes_ne[ nextRowIndex ];

      longitudes_ne[ column ] =
        nextRowNELongitude + nextRowNELongitude - longitudes_se[ nextRowIndex];

      longitudes_nw[ column ] =
        nextRowNWLongitude + nextRowNWLongitude - longitudes_sw[ nextRowIndex];

      latitudes_sw[ column ] = latitudes_nw[ nextRowIndex ];
      latitudes_se[ column ] = latitudes_ne[ nextRowIndex ];

      latitudes_ne[ column ] =
        nextRowNELatitude + nextRowNELatitude - latitudes_se[ nextRowIndex ];

      latitudes_nw[ column ] =
        nextRowNWLatitude + nextRowNWLatitude - latitudes_sw[ nextRowIndex ];

      printf( "lon_sw[%lld] = %lg, ", column, longitudes_sw[ column ] );
      printf( "lat_sw[%lld] = %lg, ", column, latitudes_sw[ column ] );
      printf( "lon_se[%lld] = %lg, ", column, longitudes_se[ column ] );
      printf( "lat_se[%lld] = %lg, ", column, latitudes_se[ column ] );
      printf( "lon_nw[%lld] = %lg, ", column, longitudes_nw[ column ] );
      printf( "lat_nw[%lld] = %lg, ", column, latitudes_nw[ column ] );
      printf( "lon_ne[%lld] = %lg, ", column, longitudes_ne[ column ] );
      printf( "lat_ne[%lld] = %lg, ", column, latitudes_ne[ column ] );
      printf( "\n" );
    }

    /* Last row, interior columns (extrapolated top edge): */

    printf( "\nextrapolated top edge, except corners:\n" );

    for ( column = 1; column < columns1; ++column ) {
      const Integer index               = cells - columns + column;
      const Integer previousRowIndex    = index - columns;
      const Real previousRowSELongitude = longitudes_se[ previousRowIndex ];
      const Real previousRowSWLongitude = longitudes_sw[ previousRowIndex ];
      const Real previousRowSELatitude  = latitudes_se[  previousRowIndex ];
      const Real previousRowSWLatitude  = latitudes_sw[  previousRowIndex ];

      longitudes_nw[ index ] = longitudes_sw[ previousRowIndex ];
      longitudes_ne[ index ] = longitudes_se[ previousRowIndex ];

      longitudes_sw[ index ] =
        previousRowSWLongitude +
        previousRowSWLongitude - longitudes_nw[ previousRowIndex ];

      longitudes_se[ index ] =
        previousRowSELongitude +
        previousRowSELongitude - longitudes_ne[ previousRowIndex ];

      latitudes_nw[ index ] = latitudes_sw[ previousRowIndex ];
      latitudes_ne[ index ] = latitudes_se[ previousRowIndex ];

      latitudes_sw[ index ] =
        previousRowSWLatitude +
        previousRowSWLatitude - latitudes_nw[ previousRowIndex ];

      latitudes_se[ index ] =
        previousRowSELatitude +
        previousRowSELatitude - latitudes_ne[ previousRowIndex ];

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* First row, first column cell (extrapolated bottom-left corner): */

    printf( "\nextrapolated bottom-left corner:\n" );

    {
      const Integer nextRowIndex    = columns;
      const Real nextRowNWLongitude = longitudes_nw[ nextRowIndex ];
      const Real nextRowNWLatitude  = latitudes_nw[  nextRowIndex ];

      longitudes_sw[ 0 ] = nextRowNWLongitude;
      longitudes_se[ 0 ] = longitudes_ne[ nextRowIndex ];
      longitudes_ne[ 0 ] = longitudes_nw[ 1 ];

      longitudes_nw[ 0 ] =
        nextRowNWLongitude - (longitudes_sw[nextRowIndex] -nextRowNWLongitude);

      latitudes_sw[ 0 ] = nextRowNWLatitude;
      latitudes_se[ 0 ] = latitudes_ne[ nextRowIndex ];
      latitudes_ne[ 0 ] = latitudes_nw[ 1 ];

      latitudes_nw[ 0 ] =
        nextRowNWLatitude - ( latitudes_sw[ nextRowIndex] - nextRowNWLatitude);

      printf( "lon_sw[0] = %lg, ", longitudes_sw[ 0 ] );
      printf( "lat_sw[0] = %lg, ", latitudes_sw[ 0 ] );
      printf( "lon_se[0] = %lg, ", longitudes_se[ 0 ] );
      printf( "lat_se[0] = %lg, ", latitudes_se[ 0 ] );
      printf( "lon_nw[0] = %lg, ", longitudes_nw[ 0 ] );
      printf( "lat_nw[0] = %lg, ", latitudes_nw[ 0 ] );
      printf( "lon_ne[0] = %lg, ", longitudes_ne[ 0 ] );
      printf( "lat_ne[0] = %lg, ", latitudes_ne[ 0 ] );
      printf( "\n" );
    }

    /* First row, last column cell (extrapolated bottom-right corner): */

    printf( "\nextrapolated bottom-right corner:\n" );

    {
      const Integer index               = columns1;
      const Integer previousColumnIndex = index - 1;
      const Integer nextRowIndex        = index + columns;
      const Real nextRowNELongitude     = longitudes_ne[ nextRowIndex ];
      const Real nextRowNELatitude      = latitudes_ne[  nextRowIndex ];

      longitudes_sw[ index ] = longitudes_nw[ nextRowIndex ];
      longitudes_se[ index ] = nextRowNELongitude;
      longitudes_nw[ index ] = longitudes_ne[ previousColumnIndex ];

      longitudes_ne[ index ] =
        nextRowNELongitude - (longitudes_se[nextRowIndex] -nextRowNELongitude);

      latitudes_sw[ index ] = latitudes_nw[ nextRowIndex ];
      latitudes_se[ index ] = nextRowNELatitude;
      latitudes_nw[ index ] = latitudes_ne[ previousColumnIndex ];

      latitudes_ne[ index ] =
        nextRowNELatitude - ( latitudes_se[nextRowIndex] - nextRowNELatitude );

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* Last row, first column cell (extrapolated top-left corner): */

    printf( "\nextrapolated top-left corner:\n" );

    {
      const Integer index               = cells - columns;
      const Integer nextColumnIndex     = index + 1;
      const Integer previousRowIndex    = index - columns;
      const Real previousRowSWLongitude = longitudes_sw[ previousRowIndex ];
      const Real previousRowSWLatitude  = latitudes_sw[  previousRowIndex ];

      longitudes_nw[ index ] = previousRowSWLongitude;
      longitudes_ne[ index ] = longitudes_se[ previousRowIndex ];
      longitudes_se[ index ] = longitudes_sw[ nextColumnIndex ];

      longitudes_sw[ index ] =
        previousRowSWLongitude -
        ( longitudes_nw[ previousRowIndex ] - previousRowSWLongitude );

      latitudes_nw[ index ] = previousRowSWLatitude;
      latitudes_ne[ index ] = latitudes_se[ previousRowIndex ];
      latitudes_se[ index ] = latitudes_sw[ nextColumnIndex ];

      latitudes_sw[ index ] =
        previousRowSWLatitude -
        ( latitudes_nw[ previousRowIndex ] - previousRowSWLatitude );

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* Last row, last column cell (extrapolated top-right corner): */

    printf( "\nextrapolated top-right corner:\n" );

    {
      const Integer index               = cells - 1;
      const Integer previousColumnIndex = index - 1;
      const Integer previousRowIndex    = index - columns;
      const Real previousRowSELongitude = longitudes_se[ previousRowIndex ];
      const Real previousRowSELatitude  = latitudes_se[  previousRowIndex ];

      longitudes_nw[ index ] = longitudes_ne[ previousColumnIndex ];
      longitudes_sw[ index ] = longitudes_se[ previousColumnIndex ];
      longitudes_ne[ index ] = previousRowSELongitude;

      longitudes_se[ index ] =
        previousRowSELongitude -
        ( longitudes_ne[ previousRowIndex ] - previousRowSELongitude );

      latitudes_nw[ index ] = latitudes_ne[ previousColumnIndex ];
      latitudes_sw[ index ] = latitudes_se[ previousColumnIndex ];
      latitudes_ne[ index ] = previousRowSELatitude;

      latitudes_se[ index ] =
        previousRowSELatitude -
        ( latitudes_ne[ previousRowIndex ] - previousRowSELatitude );

      printf( "lon_sw[%lld] = %lg, ", index, longitudes_sw[ index ] );
      printf( "lat_sw[%lld] = %lg, ", index, latitudes_sw[ index ] );
      printf( "lon_se[%lld] = %lg, ", index, longitudes_se[ index ] );
      printf( "lat_se[%lld] = %lg, ", index, latitudes_se[ index ] );
      printf( "lon_nw[%lld] = %lg, ", index, longitudes_nw[ index ] );
      printf( "lat_nw[%lld] = %lg, ", index, latitudes_nw[ index ] );
      printf( "lon_ne[%lld] = %lg, ", index, longitudes_ne[ index ] );
      printf( "lat_ne[%lld] = %lg, ", index, latitudes_ne[ index ] );
      printf( "\n" );
    }

    /* Clamp any out-of-range values: */

    printf( "\nclamping:\n" );

#pragma omp parallel for

    for ( cell = 0; cell < cells; ++cell ) {
      longitudes_nw[cell] = CLAMPED_TO_RANGE(longitudes_nw[cell],-180.0,180.0);
      longitudes_sw[cell] = CLAMPED_TO_RANGE(longitudes_sw[cell],-180.0,180.0);
      longitudes_se[cell] = CLAMPED_TO_RANGE(longitudes_se[cell],-180.0,180.0);
      longitudes_ne[cell] = CLAMPED_TO_RANGE(longitudes_ne[cell],-180.0,180.0);
      latitudes_nw[cell] = CLAMPED_TO_RANGE( latitudes_nw[cell], -90.0, 90.0 );
      latitudes_sw[cell] = CLAMPED_TO_RANGE( latitudes_sw[cell], -90.0, 90.0 );
      latitudes_se[cell] = CLAMPED_TO_RANGE( latitudes_se[cell], -90.0, 90.0 );
      latitudes_ne[cell] = CLAMPED_TO_RANGE( latitudes_ne[cell], -90.0, 90.0 );

      printf( "lon_sw[%lld] = %lg, ", cell, longitudes_sw[ cell  ] );
      printf( "lat_sw[%lld] = %lg, ", cell, latitudes_sw[ cell  ] );
      printf( "lon_se[%lld] = %lg, ", cell, longitudes_se[ cell  ] );
      printf( "lat_se[%lld] = %lg, ", cell, latitudes_se[ cell  ] );
      printf( "lon_nw[%lld] = %lg, ", cell, longitudes_nw[ cell  ] );
      printf( "lat_nw[%lld] = %lg, ", cell, latitudes_nw[ cell  ] );
      printf( "lon_ne[%lld] = %lg, ", cell, longitudes_ne[ cell  ] );
      printf( "lat_ne[%lld] = %lg, ", cell, latitudes_ne[ cell  ] );
      printf( "\n" );
    }

  } /* End else non-degenerate cases: */

  POST0( validLongitudesAndLatitudes( 4 * rows * columns,
                                      corners, corners + 4 * rows * columns ));
}



